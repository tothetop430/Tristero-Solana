{"version":3,"sources":["../src/providers/solana.ts","../src/signers/solana.ts","../src/ecdsa.ts"],"names":["arrayify","hexlify","Connection","sendAndConfirmRawTransaction","SignedTransaction","TransactionPending","TransactionReceipt"],"mappings":"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","sourcesContent":["import { arrayify } from '@ethersproject/bytes'\nimport {\n    ConfirmOptions,\n    Connection,\n    Finality,\n    GetVersionedTransactionConfig,\n    ParsedTransactionWithMeta,\n    PublicKey,\n    SendOptions,\n    TransactionSignature,\n    sendAndConfirmRawTransaction,\n} from '@solana/web3.js'\n\nimport {\n    Block,\n    BlockTag,\n    BlockWithTransactions,\n    Provider,\n    SignedTransaction,\n    TransactionPending,\n    TransactionReceipt,\n    TransactionResponse,\n} from '@layerzerolabs/lz-core'\n\nexport class SolanaProvider implements Provider {\n    nativeProvider: Connection\n\n    constructor(url: string) {\n        this.nativeProvider = new Connection(url, 'confirmed')\n    }\n\n    static from(url: string): SolanaProvider\n\n    static from(source: string): SolanaProvider {\n        if (typeof source === 'string') {\n            return new SolanaProvider(source)\n        } else {\n            throw new Error('Invalid parameters')\n        }\n    }\n\n    get native(): unknown {\n        return this.nativeProvider\n    }\n\n    async getBalance(address: string): Promise<string> {\n        return this.nativeProvider.getBalance(new PublicKey(address)).then((balance) => balance.toString())\n    }\n\n    async getBlock(slot: string | number): Promise<Block> {\n        const response = await this.nativeProvider.getParsedBlock(parseInt(slot.toString()), {\n            commitment: 'confirmed',\n        })\n        return Block.from(response)\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this.nativeProvider.getBlockHeight({ commitment: 'confirmed' })\n    }\n\n    async getSlot(finality?: Finality): Promise<number> {\n        return this.nativeProvider.getSlot(finality)\n    }\n\n    async getBlockTimestamp(slot: string | number): Promise<number> {\n        const t = await this.nativeProvider.getBlockTime(parseInt(slot.toString()))\n        if (t === null) {\n            throw new Error('Block timestamp not available')\n        }\n        return t\n    }\n\n    /**\n     *\n     * @param txHash string The transaction hash is TransactionSignature in Solana\n     * @returns TransactionResponse\n     */\n    async getTransaction(txHash: string): Promise<TransactionResponse> {\n        const response: ParsedTransactionWithMeta | null = await this.nativeProvider.getParsedTransaction(txHash, {\n            commitment: 'confirmed',\n        })\n        return TransactionResponse.from(response)\n    }\n\n    async getTransactionReceipt(txHash: string): Promise<TransactionReceipt> {\n        const response: ParsedTransactionWithMeta | null = await this.nativeProvider.getParsedTransaction(txHash, {\n            commitment: 'confirmed',\n        } satisfies GetVersionedTransactionConfig)\n        if (response === null) {\n            throw new Error('Transaction not found')\n        }\n        return TransactionReceipt.from(response)\n    }\n\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getTransactionCount(\n        _addressOrName: string | Promise<string>,\n        _blockTag?: BlockTag | Promise<BlockTag>\n    ): Promise<number> {\n        await Promise.resolve()\n        throw new Error('Method not implemented.')\n    }\n\n    async getBlockWithTransactions(blockTag: string | number): Promise<BlockWithTransactions> {\n        if (typeof blockTag === 'string') {\n            blockTag = parseInt(blockTag)\n        }\n        const response = await this.nativeProvider.getBlock(blockTag, { transactionDetails: 'full' })\n        if (response === null) {\n            throw new Error('Block not found')\n        }\n        return BlockWithTransactions.from(response)\n    }\n\n    async sendTransaction(transaction: SignedTransaction, sendOptions?: SendOptions): Promise<TransactionPending> {\n        const _transaction = transaction.signed as string\n\n        const response = await this.nativeProvider.sendRawTransaction(Buffer.from(arrayify(_transaction)), sendOptions)\n        return TransactionPending.from(response)\n    }\n\n    async sendAndConfirm(transaction: SignedTransaction, opts?: ConfirmOptions): Promise<TransactionReceipt> {\n        const _transaction = transaction.signed as string\n        const response: TransactionSignature = await sendAndConfirmRawTransaction(\n            this.nativeProvider,\n            Buffer.from(arrayify(_transaction)),\n            opts\n        )\n        return TransactionReceipt.from(response)\n    }\n}\n","import { isVersionedTransaction } from '@coral-xyz/anchor/dist/cjs/utils/common'\nimport { arrayify, hexlify } from '@ethersproject/bytes'\nimport {\n    ConfirmOptions,\n    Connection,\n    Keypair,\n    Signer as NativeSolanaSigner,\n    PublicKey,\n    SendOptions,\n    Transaction,\n    TransactionInstruction,\n    VersionedTransaction,\n    sendAndConfirmRawTransaction,\n} from '@solana/web3.js'\nimport * as bip39 from 'bip39'\nimport { derivePath } from 'ed25519-hd-key'\n\nimport {\n    Provider,\n    SignedTransaction,\n    Signer,\n    TransactionPending,\n    TransactionReceipt,\n    TransactionRequest,\n} from '@layerzerolabs/lz-core'\n\nimport { getECDSAPublicKey } from '../ecdsa'\n\nexport interface SolanaPopulatedTransaction {\n    instructions: TransactionInstruction[]\n    signers?: NativeSolanaSigner[]\n    lzSingers?: SolanaSigner[]\n    table?: PublicKey\n}\n\nexport class SolanaSigner implements Signer {\n    private readonly keypair: Keypair\n    private provider?: Connection\n    private ecdsaPrivateKey?: string\n    private ecdsaPublicKey?: string\n\n    private constructor(keypair: Keypair, ecdsaPrivateKey?: string) {\n        this.keypair = keypair\n        this.ecdsaPrivateKey = ecdsaPrivateKey\n        if (ecdsaPrivateKey !== undefined) {\n            this.ecdsaPublicKey = getECDSAPublicKey(ecdsaPrivateKey)\n        }\n    }\n\n    static from(source: Keypair): SolanaSigner\n    static from(mnemonic: string, path: string): SolanaSigner\n\n    static from(source: Keypair | string, path?: string): SolanaSigner {\n        if (source instanceof Keypair) {\n            return new this(source)\n        } else if (typeof source === 'string') {\n            const { ecdsaPrivateKey, keypair } = getKeypair(source, path)\n            return new this(keypair, ecdsaPrivateKey)\n        } else {\n            throw new Error('Invalid parameters')\n        }\n    }\n\n    get native(): unknown {\n        return this.keypair\n    }\n\n    connect(provider: Provider): this {\n        if (!(provider.native instanceof Connection)) {\n            throw new Error('Only @solana/web3.js Connection is supported.')\n        }\n        this.provider = provider.native\n        return this\n    }\n\n    async getAddress(): Promise<string> {\n        return Promise.resolve(this.keypair.publicKey.toBase58())\n    }\n\n    get address(): string {\n        return this.publicKey.toBase58()\n    }\n\n    get publicKey(): PublicKey {\n        return this.keypair.publicKey\n    }\n\n    get secretKey(): Uint8Array {\n        return this.keypair.secretKey\n    }\n\n    get ECDSAPrivateKey(): string {\n        if (this.ecdsaPrivateKey === undefined) {\n            throw new Error('ECDSA private key is not available')\n        }\n        return this.ecdsaPrivateKey\n    }\n\n    get ECDSAPublicKey(): string {\n        if (this.ecdsaPublicKey === undefined) {\n            throw new Error('ECDSA public key is not available')\n        }\n        return this.ecdsaPublicKey\n    }\n\n    async sendAndConfirm(transaction: SignedTransaction, opts?: ConfirmOptions): Promise<TransactionReceipt> {\n        const provider = this.assetAndGetProvider()\n        const stx = arrayify(transaction.signed as string)\n        const response = await sendAndConfirmRawTransaction(provider, Buffer.from(stx), opts)\n        return TransactionReceipt.from(response)\n    }\n\n    async sendTransaction(transaction: SignedTransaction, sendOptions?: SendOptions): Promise<TransactionPending> {\n        const provider = this.assetAndGetProvider()\n        const stx = arrayify(transaction.signed as string)\n        const response = await provider.sendRawTransaction(stx, sendOptions)\n        return TransactionPending.from(response)\n    }\n\n    async signTransaction(transaction: TransactionRequest, opts?: SendOptions): Promise<SignedTransaction> {\n        type NativePopulatedTransaction = Parameters<typeof this.buildTxByPopulatedTx>[0]\n        const populatedTransaction = transaction.request as NativePopulatedTransaction\n\n        const provider = this.assetAndGetProvider()\n\n        const tx = this.buildTxByPopulatedTx(populatedTransaction)\n        if (isVersionedTransaction(tx)) {\n            if (populatedTransaction.signers) {\n                tx.sign(populatedTransaction.signers)\n            }\n\n            // sign by keypair\n            tx.sign([this.keypair])\n        } else {\n            tx.feePayer = tx.feePayer ?? this.publicKey\n            tx.recentBlockhash = (await provider.getLatestBlockhash(opts?.preflightCommitment)).blockhash\n\n            if (populatedTransaction.signers) {\n                for (const signer of populatedTransaction.signers) {\n                    tx.partialSign(signer)\n                }\n            }\n            if (populatedTransaction.lzSingers) {\n                for (const signer of populatedTransaction.lzSingers) {\n                    signer.partialSign(tx)\n                }\n            }\n            // sign by keypair\n            tx.partialSign(this.keypair)\n        }\n        const response = hexlify(tx.serialize())\n        return SignedTransaction.from(response)\n    }\n\n    async signBuffer(_buffer: Uint8Array): Promise<Uint8Array> {\n        await Promise.resolve()\n        throw new Error('Method not implemented.')\n    }\n\n    partialSign(tx: Transaction | VersionedTransaction): void {\n        if (isVersionedTransaction(tx)) {\n            tx.sign([this.keypair])\n        } else {\n            tx.partialSign(this.keypair)\n        }\n    }\n\n    private buildTxByPopulatedTx(populatedTransaction: SolanaPopulatedTransaction): Transaction | VersionedTransaction {\n        // const versionedTx = await txWithAddressLookupTable(\n        //     this.anchorProvider.connection,\n        //     this.wallet.publicKey,\n        //     transaction.instructions,\n        //     transaction.table\n        // )\n        const tx = new Transaction()\n        // TODO support address lookup table\n        // FIXME: disabled temporarily when moved to corekit\n        tx.add(...populatedTransaction.instructions)\n        // TODO sign by signers\n        return tx\n    }\n\n    private assetAndGetProvider(): Connection {\n        if (!this.provider) {\n            throw new Error('Signer was not connected to a provider, did you forgot to connect to provider?')\n        }\n        return this.provider\n    }\n}\n\nfunction getKeypair(mnemonic: string, path = \"m/44'/501'/0'/0'\"): { ecdsaPrivateKey: string; keypair: Keypair } {\n    const seed = bip39.mnemonicToSeedSync(mnemonic, '') // (mnemonic, password)\n    const privateKey = derivePath(path, seed.toString('hex')).key\n    return { ecdsaPrivateKey: hexlify(privateKey), keypair: Keypair.fromSeed(privateKey) }\n}\n","import { hexlify } from '@ethersproject/bytes'\nimport { getPublicKey, sign } from '@noble/secp256k1'\n\nexport { recoverPublicKey } from '@noble/secp256k1'\n\nexport async function signWithECDSA(\n    data: Buffer,\n    privateKey: string\n): Promise<{ signature: Uint8Array; recoveryId: number }> {\n    const [signature, recoveryId] = await sign(data, privateKey.replace('0x', ''), {\n        canonical: true,\n        recovered: true,\n        der: false,\n    })\n    return {\n        signature,\n        recoveryId,\n    }\n}\n\nexport function getECDSAPublicKey(privateKey: string): string {\n    // remove the compression byte\n    return hexlify(getPublicKey(privateKey.replace('0x', '')).subarray(1))\n}\n"]}