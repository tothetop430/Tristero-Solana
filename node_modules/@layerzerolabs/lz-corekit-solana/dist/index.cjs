'use strict';

var bytes = require('@ethersproject/bytes');
var web3_js = require('@solana/web3.js');
var lzCore = require('@layerzerolabs/lz-core');
var common = require('@coral-xyz/anchor/dist/cjs/utils/common');
var bip39 = require('bip39');
var ed25519HdKey = require('ed25519-hd-key');
var secp256k1 = require('@noble/secp256k1');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var bip39__namespace = /*#__PURE__*/_interopNamespace(bip39);

// src/providers/solana.ts
var SolanaProvider = class _SolanaProvider {
  constructor(url) {
    this.nativeProvider = new web3_js.Connection(url, "confirmed");
  }
  static from(source) {
    if (typeof source === "string") {
      return new _SolanaProvider(source);
    } else {
      throw new Error("Invalid parameters");
    }
  }
  get native() {
    return this.nativeProvider;
  }
  async getBalance(address) {
    return this.nativeProvider.getBalance(new web3_js.PublicKey(address)).then((balance) => balance.toString());
  }
  async getBlock(slot) {
    const response = await this.nativeProvider.getParsedBlock(parseInt(slot.toString()), {
      commitment: "confirmed"
    });
    return lzCore.Block.from(response);
  }
  async getBlockNumber() {
    return this.nativeProvider.getBlockHeight({ commitment: "confirmed" });
  }
  async getSlot(finality) {
    return this.nativeProvider.getSlot(finality);
  }
  async getBlockTimestamp(slot) {
    const t = await this.nativeProvider.getBlockTime(parseInt(slot.toString()));
    if (t === null) {
      throw new Error("Block timestamp not available");
    }
    return t;
  }
  /**
   *
   * @param txHash string The transaction hash is TransactionSignature in Solana
   * @returns TransactionResponse
   */
  async getTransaction(txHash) {
    const response = await this.nativeProvider.getParsedTransaction(txHash, {
      commitment: "confirmed"
    });
    return lzCore.TransactionResponse.from(response);
  }
  async getTransactionReceipt(txHash) {
    const response = await this.nativeProvider.getParsedTransaction(txHash, {
      commitment: "confirmed"
    });
    if (response === null) {
      throw new Error("Transaction not found");
    }
    return lzCore.TransactionReceipt.from(response);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionCount(_addressOrName, _blockTag) {
    await Promise.resolve();
    throw new Error("Method not implemented.");
  }
  async getBlockWithTransactions(blockTag) {
    if (typeof blockTag === "string") {
      blockTag = parseInt(blockTag);
    }
    const response = await this.nativeProvider.getBlock(blockTag, { transactionDetails: "full" });
    if (response === null) {
      throw new Error("Block not found");
    }
    return lzCore.BlockWithTransactions.from(response);
  }
  async sendTransaction(transaction, sendOptions) {
    const _transaction = transaction.signed;
    const response = await this.nativeProvider.sendRawTransaction(Buffer.from(bytes.arrayify(_transaction)), sendOptions);
    return lzCore.TransactionPending.from(response);
  }
  async sendAndConfirm(transaction, opts) {
    const _transaction = transaction.signed;
    const response = await web3_js.sendAndConfirmRawTransaction(
      this.nativeProvider,
      Buffer.from(bytes.arrayify(_transaction)),
      opts
    );
    return lzCore.TransactionReceipt.from(response);
  }
};
async function signWithECDSA(data, privateKey) {
  const [signature, recoveryId] = await secp256k1.sign(data, privateKey.replace("0x", ""), {
    canonical: true,
    recovered: true,
    der: false
  });
  return {
    signature,
    recoveryId
  };
}
function getECDSAPublicKey(privateKey) {
  return bytes.hexlify(secp256k1.getPublicKey(privateKey.replace("0x", "")).subarray(1));
}

// src/signers/solana.ts
var SolanaSigner = class {
  constructor(keypair, ecdsaPrivateKey) {
    this.keypair = keypair;
    this.ecdsaPrivateKey = ecdsaPrivateKey;
    if (ecdsaPrivateKey !== void 0) {
      this.ecdsaPublicKey = getECDSAPublicKey(ecdsaPrivateKey);
    }
  }
  static from(source, path) {
    if (source instanceof web3_js.Keypair) {
      return new this(source);
    } else if (typeof source === "string") {
      const { ecdsaPrivateKey, keypair } = getKeypair(source, path);
      return new this(keypair, ecdsaPrivateKey);
    } else {
      throw new Error("Invalid parameters");
    }
  }
  get native() {
    return this.keypair;
  }
  connect(provider) {
    if (!(provider.native instanceof web3_js.Connection)) {
      throw new Error("Only @solana/web3.js Connection is supported.");
    }
    this.provider = provider.native;
    return this;
  }
  async getAddress() {
    return Promise.resolve(this.keypair.publicKey.toBase58());
  }
  get address() {
    return this.publicKey.toBase58();
  }
  get publicKey() {
    return this.keypair.publicKey;
  }
  get secretKey() {
    return this.keypair.secretKey;
  }
  get ECDSAPrivateKey() {
    if (this.ecdsaPrivateKey === void 0) {
      throw new Error("ECDSA private key is not available");
    }
    return this.ecdsaPrivateKey;
  }
  get ECDSAPublicKey() {
    if (this.ecdsaPublicKey === void 0) {
      throw new Error("ECDSA public key is not available");
    }
    return this.ecdsaPublicKey;
  }
  async sendAndConfirm(transaction, opts) {
    const provider = this.assetAndGetProvider();
    const stx = bytes.arrayify(transaction.signed);
    const response = await web3_js.sendAndConfirmRawTransaction(provider, Buffer.from(stx), opts);
    return lzCore.TransactionReceipt.from(response);
  }
  async sendTransaction(transaction, sendOptions) {
    const provider = this.assetAndGetProvider();
    const stx = bytes.arrayify(transaction.signed);
    const response = await provider.sendRawTransaction(stx, sendOptions);
    return lzCore.TransactionPending.from(response);
  }
  async signTransaction(transaction, opts) {
    const populatedTransaction = transaction.request;
    const provider = this.assetAndGetProvider();
    const tx = this.buildTxByPopulatedTx(populatedTransaction);
    if (common.isVersionedTransaction(tx)) {
      if (populatedTransaction.signers) {
        tx.sign(populatedTransaction.signers);
      }
      tx.sign([this.keypair]);
    } else {
      tx.feePayer = tx.feePayer ?? this.publicKey;
      tx.recentBlockhash = (await provider.getLatestBlockhash(opts?.preflightCommitment)).blockhash;
      if (populatedTransaction.signers) {
        for (const signer of populatedTransaction.signers) {
          tx.partialSign(signer);
        }
      }
      if (populatedTransaction.lzSingers) {
        for (const signer of populatedTransaction.lzSingers) {
          signer.partialSign(tx);
        }
      }
      tx.partialSign(this.keypair);
    }
    const response = bytes.hexlify(tx.serialize());
    return lzCore.SignedTransaction.from(response);
  }
  async signBuffer(_buffer) {
    await Promise.resolve();
    throw new Error("Method not implemented.");
  }
  partialSign(tx) {
    if (common.isVersionedTransaction(tx)) {
      tx.sign([this.keypair]);
    } else {
      tx.partialSign(this.keypair);
    }
  }
  buildTxByPopulatedTx(populatedTransaction) {
    const tx = new web3_js.Transaction();
    tx.add(...populatedTransaction.instructions);
    return tx;
  }
  assetAndGetProvider() {
    if (!this.provider) {
      throw new Error("Signer was not connected to a provider, did you forgot to connect to provider?");
    }
    return this.provider;
  }
};
function getKeypair(mnemonic, path = "m/44'/501'/0'/0'") {
  const seed = bip39__namespace.mnemonicToSeedSync(mnemonic, "");
  const privateKey = ed25519HdKey.derivePath(path, seed.toString("hex")).key;
  return { ecdsaPrivateKey: bytes.hexlify(privateKey), keypair: web3_js.Keypair.fromSeed(privateKey) };
}

Object.defineProperty(exports, "recoverPublicKey", {
  enumerable: true,
  get: function () { return secp256k1.recoverPublicKey; }
});
exports.SolanaProvider = SolanaProvider;
exports.SolanaSigner = SolanaSigner;
exports.getECDSAPublicKey = getECDSAPublicKey;
exports.signWithECDSA = signWithECDSA;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.cjs.map