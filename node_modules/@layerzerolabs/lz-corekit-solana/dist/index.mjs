import { arrayify, hexlify } from '@ethersproject/bytes';
import { Connection, PublicKey, sendAndConfirmRawTransaction, Keypair, Transaction } from '@solana/web3.js';
import { Block, TransactionResponse, TransactionReceipt, BlockWithTransactions, TransactionPending, SignedTransaction } from '@layerzerolabs/lz-core';
import { isVersionedTransaction } from '@coral-xyz/anchor/dist/cjs/utils/common';
import * as bip39 from 'bip39';
import { derivePath } from 'ed25519-hd-key';
import { sign, getPublicKey } from '@noble/secp256k1';
export { recoverPublicKey } from '@noble/secp256k1';

// src/providers/solana.ts
var SolanaProvider = class _SolanaProvider {
  constructor(url) {
    this.nativeProvider = new Connection(url, "confirmed");
  }
  static from(source) {
    if (typeof source === "string") {
      return new _SolanaProvider(source);
    } else {
      throw new Error("Invalid parameters");
    }
  }
  get native() {
    return this.nativeProvider;
  }
  async getBalance(address) {
    return this.nativeProvider.getBalance(new PublicKey(address)).then((balance) => balance.toString());
  }
  async getBlock(slot) {
    const response = await this.nativeProvider.getParsedBlock(parseInt(slot.toString()), {
      commitment: "confirmed"
    });
    return Block.from(response);
  }
  async getBlockNumber() {
    return this.nativeProvider.getBlockHeight({ commitment: "confirmed" });
  }
  async getSlot(finality) {
    return this.nativeProvider.getSlot(finality);
  }
  async getBlockTimestamp(slot) {
    const t = await this.nativeProvider.getBlockTime(parseInt(slot.toString()));
    if (t === null) {
      throw new Error("Block timestamp not available");
    }
    return t;
  }
  /**
   *
   * @param txHash string The transaction hash is TransactionSignature in Solana
   * @returns TransactionResponse
   */
  async getTransaction(txHash) {
    const response = await this.nativeProvider.getParsedTransaction(txHash, {
      commitment: "confirmed"
    });
    return TransactionResponse.from(response);
  }
  async getTransactionReceipt(txHash) {
    const response = await this.nativeProvider.getParsedTransaction(txHash, {
      commitment: "confirmed"
    });
    if (response === null) {
      throw new Error("Transaction not found");
    }
    return TransactionReceipt.from(response);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionCount(_addressOrName, _blockTag) {
    await Promise.resolve();
    throw new Error("Method not implemented.");
  }
  async getBlockWithTransactions(blockTag) {
    if (typeof blockTag === "string") {
      blockTag = parseInt(blockTag);
    }
    const response = await this.nativeProvider.getBlock(blockTag, { transactionDetails: "full" });
    if (response === null) {
      throw new Error("Block not found");
    }
    return BlockWithTransactions.from(response);
  }
  async sendTransaction(transaction, sendOptions) {
    const _transaction = transaction.signed;
    const response = await this.nativeProvider.sendRawTransaction(Buffer.from(arrayify(_transaction)), sendOptions);
    return TransactionPending.from(response);
  }
  async sendAndConfirm(transaction, opts) {
    const _transaction = transaction.signed;
    const response = await sendAndConfirmRawTransaction(
      this.nativeProvider,
      Buffer.from(arrayify(_transaction)),
      opts
    );
    return TransactionReceipt.from(response);
  }
};
async function signWithECDSA(data, privateKey) {
  const [signature, recoveryId] = await sign(data, privateKey.replace("0x", ""), {
    canonical: true,
    recovered: true,
    der: false
  });
  return {
    signature,
    recoveryId
  };
}
function getECDSAPublicKey(privateKey) {
  return hexlify(getPublicKey(privateKey.replace("0x", "")).subarray(1));
}

// src/signers/solana.ts
var SolanaSigner = class {
  constructor(keypair, ecdsaPrivateKey) {
    this.keypair = keypair;
    this.ecdsaPrivateKey = ecdsaPrivateKey;
    if (ecdsaPrivateKey !== void 0) {
      this.ecdsaPublicKey = getECDSAPublicKey(ecdsaPrivateKey);
    }
  }
  static from(source, path) {
    if (source instanceof Keypair) {
      return new this(source);
    } else if (typeof source === "string") {
      const { ecdsaPrivateKey, keypair } = getKeypair(source, path);
      return new this(keypair, ecdsaPrivateKey);
    } else {
      throw new Error("Invalid parameters");
    }
  }
  get native() {
    return this.keypair;
  }
  connect(provider) {
    if (!(provider.native instanceof Connection)) {
      throw new Error("Only @solana/web3.js Connection is supported.");
    }
    this.provider = provider.native;
    return this;
  }
  async getAddress() {
    return Promise.resolve(this.keypair.publicKey.toBase58());
  }
  get address() {
    return this.publicKey.toBase58();
  }
  get publicKey() {
    return this.keypair.publicKey;
  }
  get secretKey() {
    return this.keypair.secretKey;
  }
  get ECDSAPrivateKey() {
    if (this.ecdsaPrivateKey === void 0) {
      throw new Error("ECDSA private key is not available");
    }
    return this.ecdsaPrivateKey;
  }
  get ECDSAPublicKey() {
    if (this.ecdsaPublicKey === void 0) {
      throw new Error("ECDSA public key is not available");
    }
    return this.ecdsaPublicKey;
  }
  async sendAndConfirm(transaction, opts) {
    const provider = this.assetAndGetProvider();
    const stx = arrayify(transaction.signed);
    const response = await sendAndConfirmRawTransaction(provider, Buffer.from(stx), opts);
    return TransactionReceipt.from(response);
  }
  async sendTransaction(transaction, sendOptions) {
    const provider = this.assetAndGetProvider();
    const stx = arrayify(transaction.signed);
    const response = await provider.sendRawTransaction(stx, sendOptions);
    return TransactionPending.from(response);
  }
  async signTransaction(transaction, opts) {
    const populatedTransaction = transaction.request;
    const provider = this.assetAndGetProvider();
    const tx = this.buildTxByPopulatedTx(populatedTransaction);
    if (isVersionedTransaction(tx)) {
      if (populatedTransaction.signers) {
        tx.sign(populatedTransaction.signers);
      }
      tx.sign([this.keypair]);
    } else {
      tx.feePayer = tx.feePayer ?? this.publicKey;
      tx.recentBlockhash = (await provider.getLatestBlockhash(opts?.preflightCommitment)).blockhash;
      if (populatedTransaction.signers) {
        for (const signer of populatedTransaction.signers) {
          tx.partialSign(signer);
        }
      }
      if (populatedTransaction.lzSingers) {
        for (const signer of populatedTransaction.lzSingers) {
          signer.partialSign(tx);
        }
      }
      tx.partialSign(this.keypair);
    }
    const response = hexlify(tx.serialize());
    return SignedTransaction.from(response);
  }
  async signBuffer(_buffer) {
    await Promise.resolve();
    throw new Error("Method not implemented.");
  }
  partialSign(tx) {
    if (isVersionedTransaction(tx)) {
      tx.sign([this.keypair]);
    } else {
      tx.partialSign(this.keypair);
    }
  }
  buildTxByPopulatedTx(populatedTransaction) {
    const tx = new Transaction();
    tx.add(...populatedTransaction.instructions);
    return tx;
  }
  assetAndGetProvider() {
    if (!this.provider) {
      throw new Error("Signer was not connected to a provider, did you forgot to connect to provider?");
    }
    return this.provider;
  }
};
function getKeypair(mnemonic, path = "m/44'/501'/0'/0'") {
  const seed = bip39.mnemonicToSeedSync(mnemonic, "");
  const privateKey = derivePath(path, seed.toString("hex")).key;
  return { ecdsaPrivateKey: hexlify(privateKey), keypair: Keypair.fromSeed(privateKey) };
}

export { SolanaProvider, SolanaSigner, getECDSAPublicKey, signWithECDSA };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map