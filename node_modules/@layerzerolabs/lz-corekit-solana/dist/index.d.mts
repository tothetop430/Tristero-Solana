import { Connection, Finality, SendOptions, ConfirmOptions, TransactionInstruction, Signer, PublicKey, Keypair, Transaction, VersionedTransaction } from '@solana/web3.js';
import { Provider, Block, TransactionResponse, TransactionReceipt, BlockTag, BlockWithTransactions, SignedTransaction, TransactionPending, Signer as Signer$1, TransactionRequest } from '@layerzerolabs/lz-core';
export { recoverPublicKey } from '@noble/secp256k1';

declare class SolanaProvider implements Provider {
    nativeProvider: Connection;
    constructor(url: string);
    static from(url: string): SolanaProvider;
    get native(): unknown;
    getBalance(address: string): Promise<string>;
    getBlock(slot: string | number): Promise<Block>;
    getBlockNumber(): Promise<number>;
    getSlot(finality?: Finality): Promise<number>;
    getBlockTimestamp(slot: string | number): Promise<number>;
    /**
     *
     * @param txHash string The transaction hash is TransactionSignature in Solana
     * @returns TransactionResponse
     */
    getTransaction(txHash: string): Promise<TransactionResponse>;
    getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
    getTransactionCount(_addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    getBlockWithTransactions(blockTag: string | number): Promise<BlockWithTransactions>;
    sendTransaction(transaction: SignedTransaction, sendOptions?: SendOptions): Promise<TransactionPending>;
    sendAndConfirm(transaction: SignedTransaction, opts?: ConfirmOptions): Promise<TransactionReceipt>;
}

interface SolanaPopulatedTransaction {
    instructions: TransactionInstruction[];
    signers?: Signer[];
    lzSingers?: SolanaSigner[];
    table?: PublicKey;
}
declare class SolanaSigner implements Signer$1 {
    private readonly keypair;
    private provider?;
    private ecdsaPrivateKey?;
    private ecdsaPublicKey?;
    private constructor();
    static from(source: Keypair): SolanaSigner;
    static from(mnemonic: string, path: string): SolanaSigner;
    get native(): unknown;
    connect(provider: Provider): this;
    getAddress(): Promise<string>;
    get address(): string;
    get publicKey(): PublicKey;
    get secretKey(): Uint8Array;
    get ECDSAPrivateKey(): string;
    get ECDSAPublicKey(): string;
    sendAndConfirm(transaction: SignedTransaction, opts?: ConfirmOptions): Promise<TransactionReceipt>;
    sendTransaction(transaction: SignedTransaction, sendOptions?: SendOptions): Promise<TransactionPending>;
    signTransaction(transaction: TransactionRequest, opts?: SendOptions): Promise<SignedTransaction>;
    signBuffer(_buffer: Uint8Array): Promise<Uint8Array>;
    partialSign(tx: Transaction | VersionedTransaction): void;
    private buildTxByPopulatedTx;
    private assetAndGetProvider;
}

declare function signWithECDSA(data: Buffer, privateKey: string): Promise<{
    signature: Uint8Array;
    recoveryId: number;
}>;
declare function getECDSAPublicKey(privateKey: string): string;

export { type SolanaPopulatedTransaction, SolanaProvider, SolanaSigner, getECDSAPublicKey, signWithECDSA };
