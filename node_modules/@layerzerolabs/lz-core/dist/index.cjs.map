{"version":3,"sources":["../src/transaction.ts","../src/signer.ts"],"names":[],"mappings":";AAmBO,IAAM,QAAN,MAAM,OAAM;AAAA,EAEP,YAAmB,OAAgB;AAAhB;AAD3B,SAAS,OAAO;AAAA,EAC4B;AAAA,EAC5C,OAAO,KAAQ,KAA2B;AACtC,WAAO,IAAI,OAAM,GAAG;AAAA,EACxB;AACJ;AAKO,IAAM,wBAAN,MAAM,uBAAsB;AAAA,EAEvB,YAAmB,OAAgB;AAAhB;AAD3B,SAAS,OAAO;AAAA,EAC4B;AAAA,EAC5C,OAAO,KAAQ,KAA2C;AACtD,WAAO,IAAI,uBAAsB,GAAG;AAAA,EACxC;AACJ;AAyBO,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EAEpB,YAAmB,SAAkB;AAAlB;AAD3B,SAAS,OAAO;AAAA,EAC8B;AAAA,EAC9C,OAAO,KAAQ,KAAmE;AAC9E,WAAO,IAAI,oBAAmB,GAAG;AAAA,EACrC;AACJ;AAKO,IAAM,sBAAN,MAAM,qBAAoB;AAAA,EAErB,YAAmB,UAAmB;AAAnB;AAD3B,SAAS,OAAO;AAAA,EAC+B;AAAA,EAC/C,OAAO,KAAQ,KAAoE;AAC/E,WAAO,IAAI,qBAAoB,GAAG;AAAA,EACtC;AACJ;AAKO,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EAEpB,YAAmB,SAAkB;AAAlB;AAD3B,SAAS,OAAO;AAAA,EAC8B;AAAA,EAC9C,OAAO,KAAQ,KAAmE;AAC9E,WAAO,IAAI,oBAAmB,GAAG;AAAA,EACrC;AACJ;AAKO,IAAM,oBAAN,MAAM,mBAAkB;AAAA,EAEnB,YAAmB,QAAiB;AAAjB;AAD3B,SAAS,OAAO;AAAA,EAC6B;AAAA,EAC7C,OAAO,KAAQ,KAAkE;AAC7E,WAAO,IAAI,mBAAkB,GAAG;AAAA,EACpC;AACJ;AAKO,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EAEpB,YAAmB,SAAkB;AAAlB;AAD3B,SAAS,OAAO;AAAA,EAC8B;AAAA,EAC9C,OAAO,KAAQ,KAAmE;AAC9E,WAAO,IAAI,oBAAmB,GAAG;AAAA,EACrC;AACJ;;;AC7DO,SAAS,cAAiB,KAAqC;AAClE,MAAI,OAAO,QAAQ,YAAY,QAAQ;AAAM,WAAO;AACpD,QAAM,KAAM,IAA8B;AAC1C,SAAO,OAAO,OAAO,cAAc,OAAO,GAAG,WAAW,YAAY,GAAG,WAAW;AACtF","sourcesContent":["import { NonPromise } from './promise'\n\n/**\n * By declare a unique field `type` in each class, it ensure that the instance of one class can not\n *  be assigned to a variable of another class. Furthermore, it also help to distinguish the type of\n * the instance at runtime.\n * By private the constructor, it ensure that the instance of the class can only be created by the\n * static method `from`, and which can enforce the type of the input parameter should not be a promise.\n * Finally, it will be helpful for the compiler to infer the type of the instance and avoid the mistake.\n */\n\n/**\n * TransactionHash represents a transaction hash.\n */\nexport type TransactionHash = string | number\n\n/**\n * Block represents a block.\n */\nexport class Block {\n    readonly type = 'Block'\n    private constructor(public block: unknown) {}\n    static from<T>(raw: NonPromise<T>): Block {\n        return new Block(raw)\n    }\n}\n\n/**\n * BlockWithTransactions represents a block with transactions.\n */\nexport class BlockWithTransactions {\n    readonly type = 'BlockWithTransactions'\n    private constructor(public block: unknown) {}\n    static from<T>(raw: NonPromise<T>): BlockWithTransactions {\n        return new BlockWithTransactions(raw)\n    }\n}\n\n/**\n * BlockTag represents a block tag.\n */\nexport type BlockTag = string | number\n\n/**\n * Finality represents the finality of a block.\n */\nexport type Finality = 'confirmed' | 'finalized'\n\n/**\n * A union type to represent all the possible types of a transaction.\n */\ntype TransactionTypes =\n    | TransactionRequest\n    | TransactionResponse\n    | TransactionReceipt\n    | SignedTransaction\n    | TransactionPending\n\n/**\n * TransactionRequest represents the request of a transaction.\n */\nexport class TransactionRequest {\n    readonly type = 'TransactionRequest'\n    private constructor(public request: unknown) {}\n    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionRequest {\n        return new TransactionRequest(raw)\n    }\n}\n\n/**\n * TransactionResponse represents the response of a transaction.\n */\nexport class TransactionResponse {\n    readonly type = 'TransactionResponse'\n    private constructor(public response: unknown) {}\n    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionResponse {\n        return new TransactionResponse(raw)\n    }\n}\n\n/**\n * TransactionReceipt represents the receipt of a transaction.\n */\nexport class TransactionReceipt {\n    readonly type = 'TransactionReceipt'\n    private constructor(public receipt: unknown) {}\n    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionReceipt {\n        return new TransactionReceipt(raw)\n    }\n}\n\n/**\n * SignedTransaction represents a signed transaction.\n */\nexport class SignedTransaction {\n    readonly type = 'SignedTransaction'\n    private constructor(public signed: unknown) {}\n    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): SignedTransaction {\n        return new SignedTransaction(raw)\n    }\n}\n\n/**\n * TransactionPending represents a pending transaction.\n */\nexport class TransactionPending {\n    readonly type = 'TransactionPending'\n    private constructor(public pending: unknown) {}\n    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionPending {\n        return new TransactionPending(raw)\n    }\n}\n","import { Provider } from './provider'\nimport { SignedTransaction, TransactionPending, TransactionReceipt, TransactionRequest } from './transaction'\n\nexport interface Signer {\n    /**\n     * Connect to a provider\n     * @param provider\n     */\n    connect(provider: Provider): Signer\n\n    /**\n     * Sign a transaction\n     * @param transaction\n     */\n    signTransaction(transaction: TransactionRequest): Promise<SignedTransaction>\n\n    /**\n     * Send a transaction\n     * @param transaction\n     * @param sendOptions\n     */\n    sendTransaction(transaction: SignedTransaction, sendOptions?: unknown): Promise<TransactionPending>\n\n    /**\n     * Send a transaction and wait for confirmation\n     * @param transaction\n     * @param opts\n     */\n    sendAndConfirm(transaction: SignedTransaction, opts?: unknown): Promise<TransactionReceipt>\n\n    /**\n     * Sign a buffer (e.g. a message hash)\n     */\n    signBuffer(buffer: Uint8Array): Promise<Uint8Array>\n\n    /**\n     * returns the address of the signer\n     */\n    getAddress(): Promise<string>\n\n    /**\n     * Native signer object\n     */\n    native: unknown\n}\n\nexport interface Connectable<T> {\n    connect<U>(provider: U): T\n}\n\nexport function isConnectable<T>(obj: unknown): obj is Connectable<T> {\n    if (typeof obj !== 'object' || obj === null) return false\n    const fn = (obj as { connect?: unknown }).connect\n    return typeof fn === 'function' && typeof fn.length === 'number' && fn.length === 1\n}\n"]}