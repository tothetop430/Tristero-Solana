type NonPromise<T> = T extends Promise<unknown> ? never : T;

/**
 * By declare a unique field `type` in each class, it ensure that the instance of one class can not
 *  be assigned to a variable of another class. Furthermore, it also help to distinguish the type of
 * the instance at runtime.
 * By private the constructor, it ensure that the instance of the class can only be created by the
 * static method `from`, and which can enforce the type of the input parameter should not be a promise.
 * Finally, it will be helpful for the compiler to infer the type of the instance and avoid the mistake.
 */
/**
 * TransactionHash represents a transaction hash.
 */
type TransactionHash = string | number;
/**
 * Block represents a block.
 */
declare class Block {
    block: unknown;
    readonly type = "Block";
    private constructor();
    static from<T>(raw: NonPromise<T>): Block;
}
/**
 * BlockWithTransactions represents a block with transactions.
 */
declare class BlockWithTransactions {
    block: unknown;
    readonly type = "BlockWithTransactions";
    private constructor();
    static from<T>(raw: NonPromise<T>): BlockWithTransactions;
}
/**
 * BlockTag represents a block tag.
 */
type BlockTag = string | number;
/**
 * Finality represents the finality of a block.
 */
type Finality = 'confirmed' | 'finalized';
/**
 * A union type to represent all the possible types of a transaction.
 */
type TransactionTypes = TransactionRequest | TransactionResponse | TransactionReceipt | SignedTransaction | TransactionPending;
/**
 * TransactionRequest represents the request of a transaction.
 */
declare class TransactionRequest {
    request: unknown;
    readonly type = "TransactionRequest";
    private constructor();
    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionRequest;
}
/**
 * TransactionResponse represents the response of a transaction.
 */
declare class TransactionResponse {
    response: unknown;
    readonly type = "TransactionResponse";
    private constructor();
    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionResponse;
}
/**
 * TransactionReceipt represents the receipt of a transaction.
 */
declare class TransactionReceipt {
    receipt: unknown;
    readonly type = "TransactionReceipt";
    private constructor();
    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionReceipt;
}
/**
 * SignedTransaction represents a signed transaction.
 */
declare class SignedTransaction {
    signed: unknown;
    readonly type = "SignedTransaction";
    private constructor();
    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): SignedTransaction;
}
/**
 * TransactionPending represents a pending transaction.
 */
declare class TransactionPending {
    pending: unknown;
    readonly type = "TransactionPending";
    private constructor();
    static from<T>(raw: Exclude<NonPromise<T>, TransactionTypes>): TransactionPending;
}

interface Provider {
    /**
     * Get the block specified by blockTag
     * @param {BlockTag} [blockTag]
     * @returns
     */
    getBlock(blockTag: BlockTag): Promise<Block>;
    getBlockWithTransactions(blockTag: BlockTag): Promise<BlockWithTransactions>;
    /**
     * Get information about a transaction
     * @param {string} txHash
     * @returns
     */
    getTransaction(txHash: string): Promise<TransactionResponse>;
    /**
     * Get the receipt of a transaction
     * @param txHash
     */
    getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
    /**
     * Get the current block number
     * @returns Promise<number> the current block number
     */
    getBlockNumber(): Promise<number>;
    /**
     * Get the current slot number for commitment
     * @param commitment
     */
    getSlot(commitment?: Finality): Promise<number>;
    /**
     * Get the number of transactions sent from this address
     * @param {string|Promise<string>} addressOrName The address to get the numbers of transactions from
     * @param {BlockTag|Promise<BlockTag>} [blockTag] The block tag to get the numbers of transactions from
     * @returns Promise<number> The number of transactions sent from this address
     */
    getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    /**
     * Get the balance of an address
     * @param address
     */
    getBalance(address: string): Promise<string>;
    /**
     * Gets the UNIX timestamp for the block identified by blockTag.  The UNIX timestamp is defined as the count of
     * seconds since the Unix Epoch on January 1st, 1970 at UTC.  If blockTag is not provided, the latest block is used.
     * @param {string?} blockTag
     * @returns Promise<number> the UNIX timestamp of the block identified by blockTag
     */
    getBlockTimestamp(blockTag: BlockTag): Promise<number>;
    /**
     * sendTransaction sends a signed transaction in bytes to the blockchain.
     * @param transaction
     * @param sendOptions
     */
    sendTransaction(transaction: SignedTransaction, sendOptions?: unknown): Promise<TransactionPending>;
    /**
     * Send a transaction and wait for confirmation
     * @param transaction
     * @param opts
     */
    sendAndConfirm(transaction: SignedTransaction, opts?: unknown): Promise<TransactionReceipt>;
    readonly native: unknown;
}

interface Signer {
    /**
     * Connect to a provider
     * @param provider
     */
    connect(provider: Provider): Signer;
    /**
     * Sign a transaction
     * @param transaction
     */
    signTransaction(transaction: TransactionRequest): Promise<SignedTransaction>;
    /**
     * Send a transaction
     * @param transaction
     * @param sendOptions
     */
    sendTransaction(transaction: SignedTransaction, sendOptions?: unknown): Promise<TransactionPending>;
    /**
     * Send a transaction and wait for confirmation
     * @param transaction
     * @param opts
     */
    sendAndConfirm(transaction: SignedTransaction, opts?: unknown): Promise<TransactionReceipt>;
    /**
     * Sign a buffer (e.g. a message hash)
     */
    signBuffer(buffer: Uint8Array): Promise<Uint8Array>;
    /**
     * returns the address of the signer
     */
    getAddress(): Promise<string>;
    /**
     * Native signer object
     */
    native: unknown;
}
interface Connectable<T> {
    connect<U>(provider: U): T;
}
declare function isConnectable<T>(obj: unknown): obj is Connectable<T>;

export { Block, type BlockTag, BlockWithTransactions, type Connectable, type Finality, type Provider, SignedTransaction, type Signer, type TransactionHash, TransactionPending, TransactionReceipt, TransactionRequest, TransactionResponse, isConnectable };
