'use strict';

var address = require('@ethersproject/address');
var bytes = require('@ethersproject/bytes');
var web3_js = require('@solana/web3.js');
var abi = require('@ethersproject/abi');
var bignumber = require('@ethersproject/bignumber');
var solidity = require('@ethersproject/solidity');
var invariant = require('tiny-invariant');
var keccak256 = require('@ethersproject/keccak256');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var invariant__default = /*#__PURE__*/_interopDefault(invariant);

// src/utils/hex.ts
function hexZeroPadTo32(addr) {
  return bytes.hexZeroPad(addr, 32);
}
function bytes32ToEthAddress(bytes32) {
  if (bytes32 instanceof Uint8Array) {
    bytes32 = bytes.hexlify(bytes32);
  }
  return address.getAddress(bytes32.slice(-40));
}
function trim0x(str) {
  return str.replace(/^0x/, "");
}
function addressToBytes32(address) {
  if (isSolanaAddress(address)) {
    return new web3_js.PublicKey(address).toBytes();
  } else if (address.startsWith("0x") && address.length <= 66) {
    return bytes.arrayify(hexZeroPadTo32(address));
  }
  throw new Error("Invalid address");
}
var solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/;
function isSolanaAddress(address) {
  return solanaAddressRegex.test(address);
}

// src/utils/precrime.ts
var CONFIG_VERSION_OFFSET = 0;
var MAX_BATCH_SIZE_OFFSET = 2;
var NUMBER_OF_PEERS_OFFSET = 10;
var PEERS_OFFSET = 12;
function parsePrecrimeConfig(precrimeConfig) {
  const data = trim0x(precrimeConfig);
  const version = parseInt(data.slice(0, 4), 16);
  if (version === 1) {
    return parsePrecrimeConfigV1(precrimeConfig);
  } else if (version === 2) {
    return parsePrecrimeConfigV2(precrimeConfig);
  }
  throw new Error(`Unsupported precrime config version: ${version}`);
}
function parsePrecrimeConfigV1(precrimeConfig) {
  const data = trim0x(precrimeConfig);
  const version = parseInt(data.slice(0, 4), 16);
  const maxBatchSize = parseInt(data.slice(4, 20), 16);
  const remoteChainsLength = parseInt(data.slice(20, 84), 16);
  const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64);
  const remoteAddressesBytes = data.slice(
    84 + remoteChainsLength * 64,
    84 + remoteChainsLength * 64 + remoteChainsLength * 64
  );
  const remoteChainsBytesArray = [];
  const remoteAddressesBytesArray = [];
  let start = 0;
  let end = 64;
  for (let i = 0; i < remoteChainsLength; i++) {
    remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16));
    remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`);
    start += 64;
    end += 64;
  }
  return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray };
}
function parsePrecrimeConfigV2(precrimeConfig) {
  const buffer = Buffer.from(trim0x(precrimeConfig), "hex");
  const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET);
  const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET);
  const peers = new Array();
  if (buffer.length > NUMBER_OF_PEERS_OFFSET) {
    const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET);
    for (let i = 0; i < numOfPeers; i++) {
      const offset = PEERS_OFFSET + i * (4 + 2 * 32);
      const eid = buffer.readUInt32BE(offset);
      const preCrimeAddress = "0x" + buffer.slice(offset + 4, offset + 4 + 32).toString("hex");
      const oappAddress = "0x" + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString("hex");
      peers.push({
        eid,
        preCrimeAddress,
        oappAddress
      });
    }
  }
  return {
    version,
    maxBatchSize,
    peers
  };
}
var parseError = (errorData, intf) => {
  const buildInError = parseBuildInError(errorData);
  if (buildInError !== void 0) {
    return buildInError;
  }
  if (intf) {
    try {
      return intf.parseError(errorData);
    } catch (e) {
      console.error(e);
    }
  }
};
function parseBuildInError(errorData) {
  if (errorData.startsWith("0x08c379a0")) {
    const content = `0x${errorData.substring(10)}`;
    const reason = abi.defaultAbiCoder.decode(["string"], content);
    return reason[0];
  }
  if (errorData.startsWith("0x4e487b71")) {
    const content = `0x${errorData.substring(10)}`;
    const code = abi.defaultAbiCoder.decode(["uint"], content);
    return code[0];
  }
  if (errorData === "0x") {
    return "";
  }
  return void 0;
}
var OptionType = /* @__PURE__ */ ((OptionType2) => {
  OptionType2[OptionType2["TYPE_1"] = 1] = "TYPE_1";
  OptionType2[OptionType2["TYPE_2"] = 2] = "TYPE_2";
  OptionType2[OptionType2["TYPE_3"] = 3] = "TYPE_3";
  return OptionType2;
})(OptionType || {});
var MAX_UINT_128 = bignumber.BigNumber.from("0xffffffffffffffffffffffffffffffff");
function optionsType1(_extraGas) {
  const extraGas = bignumber.BigNumber.from(_extraGas);
  invariant__default.default(extraGas.lte(MAX_UINT_128), "extraGas should be less than MAX_UINT_128");
  return solidity.pack(["uint16", "uint256"], [1 /* TYPE_1 */, extraGas]);
}
function optionsType2(_extraGas, _dstNativeAmt, _dstNativeAddress) {
  const extraGas = bignumber.BigNumber.from(_extraGas);
  invariant__default.default(extraGas.lte(MAX_UINT_128), "extraGas should be less than MAX_UINT_128");
  const dstNativeAmt = bignumber.BigNumber.from(_dstNativeAmt);
  invariant__default.default(dstNativeAmt.lte(MAX_UINT_128), "dstNativeAmt should be less than MAX_UINT_128");
  return solidity.pack(
    ["uint16", "uint256", "uint256", "bytes"],
    [2 /* TYPE_2 */, bignumber.BigNumber.from(extraGas), bignumber.BigNumber.from(dstNativeAmt), _dstNativeAddress]
  );
}
var WorkerId = /* @__PURE__ */ ((WorkerId2) => {
  WorkerId2[WorkerId2["EXECUTOR"] = 1] = "EXECUTOR";
  WorkerId2[WorkerId2["VERIFIER"] = 2] = "VERIFIER";
  WorkerId2[WorkerId2["TREASURY"] = 255] = "TREASURY";
  return WorkerId2;
})(WorkerId || {});
var ExecutorOptionType = /* @__PURE__ */ ((ExecutorOptionType2) => {
  ExecutorOptionType2[ExecutorOptionType2["LZ_RECEIVE"] = 1] = "LZ_RECEIVE";
  ExecutorOptionType2[ExecutorOptionType2["NATIVE_DROP"] = 2] = "NATIVE_DROP";
  ExecutorOptionType2[ExecutorOptionType2["COMPOSE"] = 3] = "COMPOSE";
  ExecutorOptionType2[ExecutorOptionType2["ORDERED"] = 4] = "ORDERED";
  return ExecutorOptionType2;
})(ExecutorOptionType || {});
var VerifierOptionType = /* @__PURE__ */ ((VerifierOptionType2) => {
  VerifierOptionType2[VerifierOptionType2["PRECRIME"] = 1] = "PRECRIME";
  return VerifierOptionType2;
})(VerifierOptionType || {});
var Options = class _Options {
  workerOptions = [];
  // dissuade public instantiation
  constructor() {
  }
  /**
   * Create a new options instance.
   */
  static newOptions() {
    return new _Options();
  }
  /**
   * Create an options instance from a hex string.
   * @param {string} optionsHex The hex string to decode.
   */
  static fromOptions(optionsHex) {
    const options = new _Options();
    const optionsBytes = bytes.arrayify(optionsHex);
    const optionsType = bignumber.BigNumber.from(optionsBytes.slice(0, 2)).toNumber();
    if (optionsType === 3 /* TYPE_3 */) {
      let cursor = 2;
      while (cursor < optionsBytes.byteLength) {
        const workerId = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();
        cursor += 1;
        const size = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber();
        cursor += 2;
        if (workerId === 1 /* EXECUTOR */) {
          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();
          cursor += 1;
          const params = optionsBytes.slice(cursor, cursor + size - 1);
          cursor += size - 1;
          options.addOption(workerId, { type: optionType, params: bytes.hexlify(params) });
        } else if (workerId === 2 /* VERIFIER */) {
          const verifierIdx = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();
          cursor += 1;
          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();
          cursor += 1;
          const params = optionsBytes.slice(cursor, cursor + size - 2);
          cursor += size - 2;
          const option = {
            type: optionType,
            index: verifierIdx,
            params: bytes.hexlify(params)
          };
          options.addOption(workerId, option);
        }
      }
    } else if (optionsType === 2 /* TYPE_2 */) {
      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();
      const dstNativeAmt = bignumber.BigNumber.from(optionsBytes.slice(34, 66)).toBigInt();
      const dstNativeAddress = bytes.hexlify(optionsBytes.slice(66, optionsBytes.byteLength));
      options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress);
    } else if (optionsType === 1 /* TYPE_1 */) {
      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();
      options.addExecutorLzReceiveOption(extraGas);
    }
    return options;
  }
  /**
   * Add ExecutorOptionType.LZ_RECEIVE option.
   * @param {GasLimit} gasLimit
   * @param {NativeDrop} nativeDrop
   */
  addExecutorLzReceiveOption(gasLimit, nativeDrop = 0) {
    const gasLimitBN = bignumber.BigNumber.from(gasLimit);
    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), "gasLimit shouldn't be greater than MAX_UINT_128");
    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);
    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), "value shouldn't be greater than MAX_UINT_128");
    this.addOption(1 /* EXECUTOR */, {
      type: 1 /* LZ_RECEIVE */,
      params: nativeDropBN.eq(0) ? solidity.pack(["uint128"], [gasLimitBN]) : solidity.pack(["uint128", "uint128"], [gasLimitBN, nativeDropBN])
    });
    return this;
  }
  /**
   * Add ExecutorOptionType.NATIVE_DROP option.
   * @param {NativeDrop} nativeDrop
   * @param {string} receiver
   */
  addExecutorNativeDropOption(nativeDrop, receiver) {
    const amountBN = bignumber.BigNumber.from(nativeDrop);
    invariant__default.default(amountBN.lte(MAX_UINT_128), "nativeDrop shouldn't be greater than MAX_UINT_128");
    this.addOption(1 /* EXECUTOR */, {
      type: 2 /* NATIVE_DROP */,
      params: solidity.pack(["uint128", "bytes32"], [amountBN, addressToBytes32(receiver)])
    });
    return this;
  }
  /**
   * Add ExecutorOptionType.COMPOSE option.
   * @param {number} index
   * @param {GasLimit} gasLimit
   * @param {NativeDrop} nativeDrop
   */
  addExecutorComposeOption(index, gasLimit, nativeDrop = 0) {
    const gasLimitBN = bignumber.BigNumber.from(gasLimit);
    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), "gasLimit shouldn't be greater than MAX_UINT_128");
    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);
    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), "nativeDrop shouldn't be greater than MAX_UINT_128");
    const option = nativeDropBN.gt(0) ? {
      type: 3 /* COMPOSE */,
      params: solidity.pack(["uint16", "uint128", "uint128"], [index, gasLimitBN, nativeDropBN])
    } : {
      type: 3 /* COMPOSE */,
      params: solidity.pack(["uint16", "uint128"], [index, gasLimitBN])
    };
    this.addOption(1 /* EXECUTOR */, option);
    return this;
  }
  /**
   * Add ExecutorOptionType.ORDERED option.
   */
  addExecutorOrderedExecutionOption() {
    this.addOption(1 /* EXECUTOR */, {
      type: 4 /* ORDERED */,
      params: "0x"
    });
    return this;
  }
  /**
   * Add VerifierOptionType.PRECRIME option.
   * @param {number} verifierIdx
   */
  addVerifierPrecrimeOption(verifierIdx) {
    const option = {
      type: 1 /* PRECRIME */,
      index: verifierIdx,
      params: "0x"
    };
    this.addOption(2 /* VERIFIER */, option);
    return this;
  }
  /**
   * Serialize Options to hex string.
   */
  toHex() {
    let hex = solidity.pack(["uint16"], [3 /* TYPE_3 */]);
    this.workerOptions.forEach((w) => {
      for (const option of w.options) {
        if (w.workerId === 1 /* EXECUTOR */) {
          hex += trim0x(
            solidity.pack(
              ["uint8", "uint16", "uint8", "bytes"],
              [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]
            )
          );
        } else if (w.workerId === 2 /* VERIFIER */) {
          const verifierOption = option;
          hex += trim0x(
            solidity.pack(
              ["uint8", "uint16", "uint8", "uint8", "bytes"],
              [
                w.workerId,
                trim0x(option.params).length / 2 + 2,
                verifierOption.index,
                verifierOption.type,
                verifierOption.params
              ]
            )
          );
        }
      }
    });
    return hex;
  }
  /**
   * Serialize Options to Uint8Array.
   */
  toBytes() {
    return bytes.arrayify(this.toHex());
  }
  addOption(workerId, option) {
    const worker = this.workerOptions.find((w) => w.workerId === workerId);
    if (worker) {
      worker.options.push(option);
    } else {
      this.workerOptions.push({ workerId, options: [option] });
    }
  }
  /**
   * Decode ExecutorOptionType.LZ_RECEIVE option.  Returns undefined if the option is not present.
   */
  decodeExecutorLzReceiveOption() {
    let options = this.findOptions(1 /* EXECUTOR */, 1 /* LZ_RECEIVE */);
    if (options === void 0 || Array.isArray(options) && options.length === 0) {
      return;
    }
    let totalGas = bignumber.BigNumber.from(0).toBigInt();
    let totalValue = bignumber.BigNumber.from(0).toBigInt();
    options = Array.isArray(options) ? options : [options];
    for (const option of options) {
      const buffer = Buffer.from(trim0x(option.params), "hex");
      const gas = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();
      const value = bignumber.BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt();
      totalGas = totalGas + gas;
      totalValue = totalValue + value;
    }
    return { gas: totalGas, value: totalValue };
  }
  /**
   * Decode ExecutorOptionType.NATIVE_DROP options.  Returns undefined if the options is not present.
   */
  decodeExecutorNativeDropOption() {
    const options = this.findOptions(1 /* EXECUTOR */, 2 /* NATIVE_DROP */);
    if (!options || options.length === 0) {
      return [];
    }
    const results = options.reduce((acc, cur) => {
      const buffer = Buffer.from(trim0x(cur.params), "hex");
      const amount = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();
      const receiver = bytes.hexlify(buffer.subarray(16, 48));
      if (acc[receiver]) {
        acc[receiver].amount = acc[receiver].amount + amount;
      } else {
        acc[receiver] = { amount, receiver };
      }
      return acc;
    }, {});
    return Object.values(results);
  }
  /**
   * Decode ExecutorOptionType.COMPOSE options.  Returns undefined if the options is not present.
   */
  decodeExecutorComposeOption() {
    const options = this.findOptions(1 /* EXECUTOR */, 3 /* COMPOSE */);
    if (!options || options.length === 0) {
      return [];
    }
    const results = options.reduce(
      (acc, cur) => {
        const buffer = Buffer.from(trim0x(cur.params), "hex");
        const index = bignumber.BigNumber.from(buffer.subarray(0, 2)).toNumber();
        const gas = bignumber.BigNumber.from(buffer.subarray(2, 18)).toBigInt();
        const value = (buffer.length === 34 ? bignumber.BigNumber.from(buffer.subarray(18, 34)) : bignumber.BigNumber.from(0)).toBigInt();
        if (acc[index]) {
          acc[index].gas = acc[index].gas + gas;
          acc[index].value = acc[index].value + value;
        } else {
          acc[index] = { index, gas, value };
        }
        return acc;
      },
      {}
    );
    return Object.values(results);
  }
  /**
   * Decode ExecutorOptionType.ORDERED options.  Returns undefined if the options is not present.
   */
  decodeExecutorOrderedExecutionOption() {
    const option = this.findOptions(1 /* EXECUTOR */, 4 /* ORDERED */);
    return option !== void 0;
  }
  findOptions(workerId, optionType) {
    const worker = this.workerOptions.find((w) => w.workerId === workerId);
    if (worker) {
      if (optionType === 4 /* ORDERED */) {
        return worker.options.find((o) => o.type === optionType);
      }
      return worker.options.filter((o) => o.type === optionType);
    }
  }
  /**
   * Find VerifierOption by verifierIdx and optionType.  Returns undefined if the option is not present.
   * @param {number} verifierIdx
   * @param {number} optionType
   */
  findVerifierOption(verifierIdx, optionType) {
    const worker = this.workerOptions.find((w) => w.workerId === 2 /* VERIFIER */);
    if (worker) {
      const opt = worker.options.find((o) => o.type === optionType && o.index === verifierIdx);
      if (opt) {
        return opt;
      }
    }
  }
};

// src/model/packet.ts
function packetToMessageOrigin(packet) {
  return {
    srcEid: packet.srcEid,
    sender: packet.sender,
    nonce: packet.nonce
  };
}
var PACKET_VERSION_OFFSET = 0;
var NONCE_OFFSET = 1;
var SRC_CHAIN_OFFSET = 9;
var SRC_ADDRESS_OFFSET = 13;
var DST_CHAIN_OFFSET = 45;
var DST_ADDRESS_OFFSET = 49;
var GUID_OFFSET = 81;
var MESSAGE_OFFSET = 113;
var PacketV1Codec = class _PacketV1Codec {
  buffer;
  static from(payloadEncoded) {
    return new _PacketV1Codec(payloadEncoded);
  }
  static fromBytes(payload) {
    return new _PacketV1Codec("0x" + Buffer.from(payload).toString("hex"));
  }
  constructor(payloadEncoded) {
    this.buffer = Buffer.from(trim0x(payloadEncoded), "hex");
  }
  /**
   * encode packet to hex string
   */
  static encode(packet) {
    const buff = this.encodeBytes(packet);
    return "0x" + Buffer.from(buff).toString("hex");
  }
  /**
   * encode packet to Uint8Array
   * @param packet
   */
  static encodeBytes(packet) {
    const message = trim0x(packet.message);
    const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2);
    buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET);
    buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET);
    buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET);
    buffer.write(Buffer.from(addressToBytes32(packet.sender)).toString("hex"), SRC_ADDRESS_OFFSET, 32, "hex");
    buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET);
    buffer.write(Buffer.from(addressToBytes32(packet.receiver)).toString("hex"), DST_ADDRESS_OFFSET, 32, "hex");
    buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, "hex");
    buffer.write(message, MESSAGE_OFFSET, message.length / 2, "hex");
    return new Uint8Array(buffer);
  }
  version() {
    return this.buffer.readUInt8(PACKET_VERSION_OFFSET);
  }
  nonce() {
    return this.buffer.readBigUint64BE(NONCE_OFFSET).toString();
  }
  srcEid() {
    return this.buffer.readUint32BE(SRC_CHAIN_OFFSET);
  }
  sender() {
    return "0x" + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString("hex");
  }
  senderAddressB20() {
    return bytes32ToEthAddress(this.sender());
  }
  dstEid() {
    return this.buffer.readUint32BE(DST_CHAIN_OFFSET);
  }
  receiver() {
    return "0x" + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString("hex");
  }
  receiverAddressB20() {
    return bytes32ToEthAddress(this.receiver());
  }
  guid() {
    return "0x" + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString("hex");
  }
  message() {
    return "0x" + this.buffer.slice(MESSAGE_OFFSET).toString("hex");
  }
  payloadHash() {
    return keccak256.keccak256(this.payload());
  }
  payload() {
    return "0x" + this.buffer.slice(GUID_OFFSET).toString("hex");
  }
  header() {
    return "0x" + this.buffer.slice(0, GUID_OFFSET).toString("hex");
  }
  headerHash() {
    return keccak256.keccak256(this.header());
  }
  /**
   * deserialize packet from hex string
   * @deprecated use toPacket instead
   */
  decode() {
    return this.toPacket();
  }
  toPacket() {
    return {
      version: this.version(),
      nonce: this.nonce(),
      srcEid: this.srcEid(),
      sender: this.sender(),
      dstEid: this.dstEid(),
      receiver: this.receiver(),
      guid: this.guid(),
      message: this.message(),
      // derived
      payload: this.payload()
    };
  }
};
function calculateGuid(packetHead) {
  return keccak256.keccak256(
    solidity.pack(
      ["uint64", "uint32", "bytes32", "uint32", "bytes32"],
      [
        bignumber.BigNumber.from(packetHead.nonce),
        packetHead.srcEid,
        addressToBytes32(packetHead.sender),
        packetHead.dstEid,
        addressToBytes32(packetHead.receiver)
      ]
    )
  );
}

// src/codec/packet-serializer.ts
var PacketSerializer = class {
  static serialize(packet) {
    return PacketV1Codec.encode(packet);
  }
  static serializeBytes(packet) {
    return PacketV1Codec.encodeBytes(packet);
  }
  static deserialize(bytesLike) {
    let codec;
    if (bytesLike instanceof Uint8Array) {
      codec = PacketV1Codec.fromBytes(bytesLike);
    } else {
      codec = PacketV1Codec.from(bytesLike);
    }
    return codec.toPacket();
  }
};

Object.defineProperty(exports, "keccak256", {
  enumerable: true,
  get: function () { return keccak256.keccak256; }
});
exports.ExecutorOptionType = ExecutorOptionType;
exports.OptionType = OptionType;
exports.Options = Options;
exports.PacketSerializer = PacketSerializer;
exports.PacketV1Codec = PacketV1Codec;
exports.VerifierOptionType = VerifierOptionType;
exports.WorkerId = WorkerId;
exports.addressToBytes32 = addressToBytes32;
exports.bytes32ToEthAddress = bytes32ToEthAddress;
exports.calculateGuid = calculateGuid;
exports.hexZeroPadTo32 = hexZeroPadTo32;
exports.isSolanaAddress = isSolanaAddress;
exports.optionsType1 = optionsType1;
exports.optionsType2 = optionsType2;
exports.packetToMessageOrigin = packetToMessageOrigin;
exports.parseError = parseError;
exports.parsePrecrimeConfig = parsePrecrimeConfig;
exports.trim0x = trim0x;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.cjs.map