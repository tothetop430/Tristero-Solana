{"version":3,"sources":["../src/utils/hex.ts","../src/utils/precrime.ts","../src/utils/parse-error.ts","../src/options/options.ts","../src/model/packet.ts","../src/codec/packet-v1-codec.ts","../src/codec/packet-serializer.ts"],"names":["arrayify","hexlify","OptionType","WorkerId","ExecutorOptionType","VerifierOptionType","BigNumber","solidityPack","keccak256"],"mappings":"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","sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { arrayify, hexZeroPad, hexlify } from '@ethersproject/bytes'\nimport { PublicKey } from '@solana/web3.js'\n\nexport function hexZeroPadTo32(addr: string): string {\n    return hexZeroPad(addr, 32)\n}\n\nexport function bytes32ToEthAddress(bytes32: string | Uint8Array): string {\n    if (bytes32 instanceof Uint8Array) {\n        bytes32 = hexlify(bytes32)\n    }\n    return getAddress(bytes32.slice(-40))\n}\n\nexport function trim0x(str: string): string {\n    return str.replace(/^0x/, '')\n}\n\n/**\n * Convert address to bytes32\n * @param address 0x prefixed address(20bytes or 32bytes) or solana address\n */\nexport function addressToBytes32(address: string): Uint8Array {\n    if (isSolanaAddress(address)) {\n        return new PublicKey(address).toBytes()\n    } else if (address.startsWith('0x') && address.length <= 66) {\n        return arrayify(hexZeroPadTo32(address))\n    }\n    throw new Error('Invalid address')\n}\n\nconst solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/\n\nexport function isSolanaAddress(address: string): boolean {\n    return solanaAddressRegex.test(address)\n}\n","import { PreCrimePeer, PrecrimeConfig, PrecrimeConfigV1, PrecrimeConfigV2 } from '../model'\n\nimport { trim0x } from './hex'\n\nconst CONFIG_VERSION_OFFSET = 0\nconst MAX_BATCH_SIZE_OFFSET = 2\nconst NUMBER_OF_PEERS_OFFSET = 10\nconst PEERS_OFFSET = 12\n\nexport function parsePrecrimeConfig(precrimeConfig: string): PrecrimeConfig {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    if (version === 1) {\n        return parsePrecrimeConfigV1(precrimeConfig)\n    } else if (version === 2) {\n        return parsePrecrimeConfigV2(precrimeConfig)\n    }\n    throw new Error(`Unsupported precrime config version: ${version}`)\n}\n\nfunction parsePrecrimeConfigV1(precrimeConfig: string): PrecrimeConfigV1 {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    const maxBatchSize = parseInt(data.slice(4, 20), 16)\n    const remoteChainsLength = parseInt(data.slice(20, 84), 16)\n    const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64)\n    const remoteAddressesBytes = data.slice(\n        84 + remoteChainsLength * 64,\n        84 + remoteChainsLength * 64 + remoteChainsLength * 64\n    )\n\n    const remoteChainsBytesArray: number[] = []\n    const remoteAddressesBytesArray: string[] = []\n    let start = 0\n    let end = 64\n    for (let i = 0; i < remoteChainsLength; i++) {\n        remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16))\n        remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`)\n        start += 64\n        end += 64\n    }\n    return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray }\n}\n\nfunction parsePrecrimeConfigV2(precrimeConfig: string): PrecrimeConfigV2 {\n    const buffer = Buffer.from(trim0x(precrimeConfig), 'hex')\n    const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET)\n    const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET)\n    const peers = new Array<PreCrimePeer>()\n    if (buffer.length > NUMBER_OF_PEERS_OFFSET) {\n        const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET)\n        for (let i = 0; i < numOfPeers; i++) {\n            const offset = PEERS_OFFSET + i * (4 + 2 * 32)\n            const eid = buffer.readUInt32BE(offset)\n            const preCrimeAddress = '0x' + buffer.slice(offset + 4, offset + 4 + 32).toString('hex')\n            const oappAddress = '0x' + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString('hex')\n            peers.push({\n                eid,\n                preCrimeAddress,\n                oappAddress,\n            })\n        }\n    }\n    return {\n        version,\n        maxBatchSize,\n        peers,\n    }\n}\n","import { type Interface, defaultAbiCoder } from '@ethersproject/abi'\n\nexport const parseError = (\n    errorData: string,\n    intf?: Interface\n): ReturnType<Interface['parseError']> | string | number | undefined => {\n    const buildInError = parseBuildInError(errorData)\n    if (buildInError !== undefined) {\n        return buildInError\n    }\n\n    if (intf) {\n        try {\n            return intf.parseError(errorData)\n        } catch (e) {\n            console.error(e)\n        }\n    }\n}\n\nfunction parseBuildInError(errorData: string): string | number | undefined {\n    if (errorData.startsWith('0x08c379a0')) {\n        // decode Error(string)\n\n        const content = `0x${errorData.substring(10)}`\n        const reason = defaultAbiCoder.decode(['string'], content)\n\n        return reason[0] as string // reason: string; for standard revert error string\n    }\n\n    if (errorData.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const content = `0x${errorData.substring(10)}`\n        const code = defaultAbiCoder.decode(['uint'], content)\n\n        return code[0] as number\n    }\n\n    if (errorData === '0x') {\n        return ''\n    }\n\n    return undefined\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { arrayify, hexlify } from '@ethersproject/bytes'\nimport { pack as solidityPack } from '@ethersproject/solidity'\nimport invariant from 'tiny-invariant'\n\nimport { addressToBytes32, trim0x } from '../utils'\n\n// gasLimit input type\nexport type GasLimit = string | number | bigint\n\n// native drop input type\nexport type NativeDrop = string | number | bigint\n\n/**\n * Enumerates the supported option types.\n */\nexport enum OptionType {\n    /**\n     * Allows the specification of the gas allowance for the remote executor transaction, measured in destination gas\n     * units.\n     *\n     * Format:\n     * bytes  [2     32      ]\n     * fields [type  extraGas]\n     */\n    TYPE_1 = 1,\n\n    /**\n     * Combines the functionality of TYPE_1 along with destination gas drop to a remote address.\n     *\n     * Format:\n     * bytes  [2     32        32            bytes[]         ]\n     * fields [type  extraGas  dstNativeAmt  dstNativeAddress]\n     */\n    TYPE_2 = 2,\n\n    /**\n     * EndpointV2 specific options.\n     */\n    TYPE_3 = 3,\n}\n\nconst MAX_UINT_128 = BigNumber.from('0xffffffffffffffffffffffffffffffff')\n\n/**\n * Builds OptionsType.TYPE_1.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n */\nexport function optionsType1(_extraGas: GasLimit): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    return solidityPack(['uint16', 'uint256'], [OptionType.TYPE_1, extraGas])\n}\n\n/**\n * Builds OptionsType.TYPE_2.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n * @param {NativeDrop} _dstNativeAmt The amount of native token to be sent to the destination chain.\n * @param {string} _dstNativeAddress The destination address of _dstNativeAmt.\n */\nexport function optionsType2(_extraGas: GasLimit, _dstNativeAmt: NativeDrop, _dstNativeAddress: string): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    const dstNativeAmt = BigNumber.from(_dstNativeAmt)\n    invariant(dstNativeAmt.lte(MAX_UINT_128), 'dstNativeAmt should be less than MAX_UINT_128')\n    return solidityPack(\n        ['uint16', 'uint256', 'uint256', 'bytes'],\n        [OptionType.TYPE_2, BigNumber.from(extraGas), BigNumber.from(dstNativeAmt), _dstNativeAddress]\n    )\n}\n\n/**\n * Enumerates the supported worker IDs.\n */\nexport enum WorkerId {\n    EXECUTOR = 1,\n    VERIFIER = 2,\n    TREASURY = 255,\n}\n\nexport interface WorkerOptions {\n    workerId: number // uint8\n    options: Option[] // toBytes: num(uint8),[type(uint8),size(uint16),data],[type(uint8),size(uint16),data],[type(uint8),size(uint16),data]...\n}\n\nexport interface Option {\n    type: number // uint8\n    params: string // bytes\n}\n\nexport type VerifierOption = Option & {\n    index: number // uint8\n}\n\n/**\n * Enumerates the supported executor option types.\n */\nexport enum ExecutorOptionType {\n    LZ_RECEIVE = 1,\n    NATIVE_DROP = 2,\n    COMPOSE = 3,\n    ORDERED = 4,\n}\n\n/**\n * Enumerates the supported verifier option types.\n */\nexport enum VerifierOptionType {\n    PRECRIME = 1,\n}\n\n/**\n * ExecutorLzReceiveOption type.\n */\nexport interface ExecutorLzReceiveOption {\n    gas: bigint\n    value: bigint\n}\n\n/**\n * ExecutorNativeDropOption type.\n */\nexport type ExecutorNativeDropOption = { amount: bigint; receiver: string }[]\n\n/**\n * ComposeOption type.\n */\nexport type ComposeOption = { index: number; gas: bigint; value: bigint }[]\n\n/**\n * Options builder, available only for EndpointV2.\n */\nexport class Options {\n    protected workerOptions: WorkerOptions[] = []\n\n    // dissuade public instantiation\n    protected constructor() {}\n\n    /**\n     * Create a new options instance.\n     */\n    public static newOptions(): Options {\n        return new Options()\n    }\n\n    /**\n     * Create an options instance from a hex string.\n     * @param {string} optionsHex The hex string to decode.\n     */\n    public static fromOptions(optionsHex: string): Options {\n        const options = new Options()\n        const optionsBytes = arrayify(optionsHex)\n        // 0-2 bytes is options type\n        const optionsType = BigNumber.from(optionsBytes.slice(0, 2)).toNumber()\n        if (optionsType === OptionType.TYPE_3) {\n            let cursor = 2\n            while (cursor < optionsBytes.byteLength) {\n                const workerId = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                cursor += 1\n\n                const size = BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber()\n                cursor += 2\n\n                if (workerId === WorkerId.EXECUTOR) {\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 1)\n                    cursor += size - 1\n                    options.addOption(workerId, { type: optionType, params: hexlify(params) })\n                } else if (workerId === WorkerId.VERIFIER) {\n                    const verifierIdx = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 2)\n                    cursor += size - 2\n                    const option: VerifierOption = {\n                        type: optionType,\n                        index: verifierIdx,\n                        params: hexlify(params),\n                    }\n                    options.addOption(workerId, option)\n                }\n                // TODO - other workerId\n            }\n        } else if (optionsType === OptionType.TYPE_2) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            const dstNativeAmt = BigNumber.from(optionsBytes.slice(34, 66)).toBigInt()\n            const dstNativeAddress = hexlify(optionsBytes.slice(66, optionsBytes.byteLength))\n            options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress)\n        } else if (optionsType === OptionType.TYPE_1) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            options.addExecutorLzReceiveOption(extraGas)\n        }\n\n        return options\n    }\n\n    /**\n     * Add ExecutorOptionType.LZ_RECEIVE option.\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorLzReceiveOption(gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"value shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.LZ_RECEIVE,\n            params: nativeDropBN.eq(0)\n                ? solidityPack(['uint128'], [gasLimitBN])\n                : solidityPack(['uint128', 'uint128'], [gasLimitBN, nativeDropBN]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.NATIVE_DROP option.\n     * @param {NativeDrop} nativeDrop\n     * @param {string} receiver\n     */\n    public addExecutorNativeDropOption(nativeDrop: NativeDrop, receiver: string): this {\n        const amountBN = BigNumber.from(nativeDrop)\n        invariant(amountBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.NATIVE_DROP,\n            params: solidityPack(['uint128', 'bytes32'], [amountBN, addressToBytes32(receiver)]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.COMPOSE option.\n     * @param {number} index\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorComposeOption(index: number, gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        const option = nativeDropBN.gt(0)\n            ? {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128', 'uint128'], [index, gasLimitBN, nativeDropBN]),\n              }\n            : {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128'], [index, gasLimitBN]),\n              }\n\n        this.addOption(WorkerId.EXECUTOR, option)\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.ORDERED option.\n     */\n    public addExecutorOrderedExecutionOption(): this {\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.ORDERED,\n            params: '0x',\n        })\n        return this\n    }\n\n    /**\n     * Add VerifierOptionType.PRECRIME option.\n     * @param {number} verifierIdx\n     */\n    public addVerifierPrecrimeOption(verifierIdx: number): this {\n        const option: VerifierOption = {\n            type: VerifierOptionType.PRECRIME,\n            index: verifierIdx,\n            params: '0x',\n        }\n        this.addOption(WorkerId.VERIFIER, option)\n        return this\n    }\n\n    /**\n     * Serialize Options to hex string.\n     */\n    public toHex(): string {\n        // output encoded hex, type(uint16)\n        let hex = solidityPack(['uint16'], [OptionType.TYPE_3])\n        this.workerOptions.forEach((w) => {\n            for (const option of w.options) {\n                if (w.workerId === WorkerId.EXECUTOR) {\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'bytes'],\n                            [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n                        )\n                    )\n                } else if (w.workerId === WorkerId.VERIFIER) {\n                    const verifierOption = option as VerifierOption\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'uint8', 'bytes'],\n                            [\n                                w.workerId,\n                                trim0x(option.params).length / 2 + 2,\n                                verifierOption.index,\n                                verifierOption.type,\n                                verifierOption.params,\n                            ]\n                        )\n                    )\n                }\n                // TODO other workerId\n            }\n        })\n        return hex\n    }\n\n    /**\n     * Serialize Options to Uint8Array.\n     */\n    public toBytes(): Uint8Array {\n        return arrayify(this.toHex())\n    }\n\n    private addOption(workerId: number, option: Option): void {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            worker.options.push(option)\n        } else {\n            this.workerOptions.push({ workerId, options: [option] })\n        }\n    }\n\n    /**\n     * Decode ExecutorOptionType.LZ_RECEIVE option.  Returns undefined if the option is not present.\n     */\n    public decodeExecutorLzReceiveOption(): ExecutorLzReceiveOption | undefined {\n        let options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.LZ_RECEIVE)\n        if (options === undefined || (Array.isArray(options) && options.length === 0)) {\n            return\n        }\n        let totalGas = BigNumber.from(0).toBigInt()\n        let totalValue = BigNumber.from(0).toBigInt()\n        options = Array.isArray(options) ? options : [options]\n        for (const option of options) {\n            const buffer = Buffer.from(trim0x(option.params), 'hex')\n            const gas = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const value = BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt()\n            totalGas = totalGas + gas\n            totalValue = totalValue + value\n        }\n\n        return { gas: totalGas, value: totalValue }\n    }\n\n    /**\n     * Decode ExecutorOptionType.NATIVE_DROP options.  Returns undefined if the options is not present.\n     */\n    public decodeExecutorNativeDropOption(): ExecutorNativeDropOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.NATIVE_DROP) as Option[]\n        if (!options || options.length === 0) {\n            return []\n        }\n\n        const results = options.reduce((acc: { [key: string]: { amount: bigint; receiver: string } }, cur: Option) => {\n            const buffer = Buffer.from(trim0x(cur.params), 'hex')\n            const amount = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const receiver = hexlify(buffer.subarray(16, 48))\n            if (acc[receiver]) {\n                acc[receiver].amount = acc[receiver].amount + amount\n            } else {\n                acc[receiver] = { amount, receiver }\n            }\n            return acc\n        }, {})\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.COMPOSE options.  Returns undefined if the options is not present.\n     */\n    public decodeExecutorComposeOption(): ComposeOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.COMPOSE) as Option[]\n        if (!options || options.length === 0) {\n            return []\n        }\n        const results = options.reduce(\n            (acc: { [key: number]: { index: number; gas: bigint; value: bigint } }, cur: Option) => {\n                const buffer = Buffer.from(trim0x(cur.params), 'hex')\n                const index = BigNumber.from(buffer.subarray(0, 2)).toNumber()\n                const gas = BigNumber.from(buffer.subarray(2, 18)).toBigInt()\n                const value = (\n                    buffer.length === 34 ? BigNumber.from(buffer.subarray(18, 34)) : BigNumber.from(0)\n                ).toBigInt()\n                if (acc[index]) {\n                    acc[index].gas = acc[index].gas + gas\n                    acc[index].value = acc[index].value + value\n                } else {\n                    acc[index] = { index, gas, value }\n                }\n                return acc\n            },\n            {}\n        )\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.ORDERED options.  Returns undefined if the options is not present.\n     */\n    public decodeExecutorOrderedExecutionOption(): boolean {\n        const option = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.ORDERED)\n        return option !== undefined\n    }\n\n    private findOptions(workerId: number, optionType: number): Option[] | Option | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            if (optionType === ExecutorOptionType.ORDERED) {\n                return worker.options.find((o) => o.type === optionType)\n            }\n            return worker.options.filter((o) => o.type === optionType)\n        }\n    }\n\n    /**\n     * Find VerifierOption by verifierIdx and optionType.  Returns undefined if the option is not present.\n     * @param {number} verifierIdx\n     * @param {number} optionType\n     */\n    public findVerifierOption(verifierIdx: number, optionType: number): VerifierOption | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === WorkerId.VERIFIER)\n        if (worker) {\n            const opt = worker.options.find((o) => o.type === optionType && (o as VerifierOption).index === verifierIdx)\n            if (opt) {\n                return opt as VerifierOption\n            }\n        }\n    }\n}\n","export interface PacketPath {\n    srcEid: number\n    sender: string\n    dstEid: number\n    receiver: string\n}\n\nexport type PacketHeader = {\n    version: number\n    nonce: string\n} & PacketPath\n\nexport type Packet = PacketHeader & {\n    guid: string\n    message: string\n    // derived\n    payload: string // payload = guid + message\n}\n\n// message origin\nexport interface MessageOrigin {\n    srcEid: number\n    sender: string\n    nonce: string\n}\n\nexport function packetToMessageOrigin(packet: Packet): MessageOrigin {\n    return {\n        srcEid: packet.srcEid,\n        sender: packet.sender,\n        nonce: packet.nonce,\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { keccak256 } from '@ethersproject/keccak256'\nimport { pack as solidityPack } from '@ethersproject/solidity'\n\nimport { Packet, PacketHeader } from '../model'\nimport { addressToBytes32, bytes32ToEthAddress, trim0x } from '../utils'\n\n// header (version + path + guid)\n// version\nconst PACKET_VERSION_OFFSET = 0\n//    nonce\nconst NONCE_OFFSET = 1\n//    path\nconst SRC_CHAIN_OFFSET = 9\nconst SRC_ADDRESS_OFFSET = 13\nconst DST_CHAIN_OFFSET = 45\nconst DST_ADDRESS_OFFSET = 49\n// payload (guid + message)\nconst GUID_OFFSET = 81 // keccak256(nonce + path)\nconst MESSAGE_OFFSET = 113\n\nexport class PacketV1Codec {\n    buffer: Buffer\n\n    static from(payloadEncoded: string): PacketV1Codec {\n        return new PacketV1Codec(payloadEncoded)\n    }\n\n    static fromBytes(payload: Uint8Array): PacketV1Codec {\n        return new PacketV1Codec('0x' + Buffer.from(payload).toString('hex'))\n    }\n\n    protected constructor(payloadEncoded: string) {\n        this.buffer = Buffer.from(trim0x(payloadEncoded), 'hex')\n    }\n\n    /**\n     * encode packet to hex string\n     */\n    static encode(packet: Packet): string {\n        const buff = this.encodeBytes(packet)\n        return '0x' + Buffer.from(buff).toString('hex')\n    }\n\n    /**\n     * encode packet to Uint8Array\n     * @param packet\n     */\n    static encodeBytes(packet: Packet): Uint8Array {\n        const message = trim0x(packet.message)\n        const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2)\n        buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET)\n        buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET)\n        buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.sender)).toString('hex'), SRC_ADDRESS_OFFSET, 32, 'hex')\n        buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.receiver)).toString('hex'), DST_ADDRESS_OFFSET, 32, 'hex')\n        buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, 'hex')\n        buffer.write(message, MESSAGE_OFFSET, message.length / 2, 'hex')\n        return new Uint8Array(buffer)\n    }\n\n    version(): number {\n        return this.buffer.readUInt8(PACKET_VERSION_OFFSET)\n    }\n\n    nonce(): string {\n        return this.buffer.readBigUint64BE(NONCE_OFFSET).toString()\n    }\n\n    srcEid(): number {\n        return this.buffer.readUint32BE(SRC_CHAIN_OFFSET)\n    }\n\n    sender(): string {\n        return '0x' + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString('hex')\n    }\n\n    senderAddressB20(): string {\n        return bytes32ToEthAddress(this.sender())\n    }\n\n    dstEid(): number {\n        return this.buffer.readUint32BE(DST_CHAIN_OFFSET)\n    }\n\n    receiver(): string {\n        return '0x' + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString('hex')\n    }\n\n    receiverAddressB20(): string {\n        return bytes32ToEthAddress(this.receiver())\n    }\n\n    guid(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString('hex')\n    }\n\n    message(): string {\n        return '0x' + this.buffer.slice(MESSAGE_OFFSET).toString('hex')\n    }\n\n    payloadHash(): string {\n        return keccak256(this.payload())\n    }\n\n    payload(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET).toString('hex')\n    }\n\n    header(): string {\n        return '0x' + this.buffer.slice(0, GUID_OFFSET).toString('hex')\n    }\n\n    headerHash(): string {\n        return keccak256(this.header())\n    }\n\n    /**\n     * deserialize packet from hex string\n     * @deprecated use toPacket instead\n     */\n    decode(): Packet {\n        return this.toPacket()\n    }\n\n    toPacket(): Packet {\n        return {\n            version: this.version(),\n            nonce: this.nonce(),\n            srcEid: this.srcEid(),\n            sender: this.sender(),\n            dstEid: this.dstEid(),\n            receiver: this.receiver(),\n            guid: this.guid(),\n            message: this.message(),\n            // derived\n            payload: this.payload(),\n        }\n    }\n}\n\nexport function calculateGuid(packetHead: PacketHeader): string {\n    return keccak256(\n        solidityPack(\n            ['uint64', 'uint32', 'bytes32', 'uint32', 'bytes32'],\n            [\n                BigNumber.from(packetHead.nonce),\n                packetHead.srcEid,\n                addressToBytes32(packetHead.sender),\n                packetHead.dstEid,\n                addressToBytes32(packetHead.receiver),\n            ]\n        )\n    )\n}\n\nexport { keccak256 } from '@ethersproject/keccak256'\n","import { Packet } from '../model'\n\nimport { PacketV1Codec } from './packet-v1-codec'\n\nexport class PacketSerializer {\n    static serialize(packet: Packet): string {\n        return PacketV1Codec.encode(packet)\n    }\n\n    static serializeBytes(packet: Packet): Uint8Array {\n        return PacketV1Codec.encodeBytes(packet)\n    }\n\n    static deserialize(bytesLike: Uint8Array | string): Packet {\n        let codec: PacketV1Codec\n        if (bytesLike instanceof Uint8Array) {\n            codec = PacketV1Codec.fromBytes(bytesLike)\n        } else {\n            codec = PacketV1Codec.from(bytesLike)\n        }\n        return codec.toPacket()\n    }\n}\n"]}