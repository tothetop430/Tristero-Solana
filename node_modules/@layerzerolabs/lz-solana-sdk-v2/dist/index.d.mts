import * as web3 from '@solana/web3.js';
import { PublicKey, Connection, Commitment, GetAccountInfoConfig, TransactionInstruction, AccountMeta, GetNonceConfig, Transaction, AccountInfo, TransactionSignature, Finality, GetVersionedTransactionConfig, Blockhash, VersionedTransaction, Keypair, NonceAccount, MessageV0 } from '@solana/web3.js';
import { PacketPath, PacketV1Codec, Packet as Packet$2 } from '@layerzerolabs/lz-v2-utilities';
import * as beet from '@metaplex-foundation/beet';
import { bignum, FixableBeetArgsStruct, BeetArgsStruct } from '@metaplex-foundation/beet';
import * as beetSolana from '@metaplex-foundation/beet-solana';
import BN from 'bn.js';
import { SolanaSigner } from '@layerzerolabs/lz-corekit-solana';
import { EndpointId, Environment, Network } from '@layerzerolabs/lz-definitions';
import { web3 as web3$1 } from '@coral-xyz/anchor';

declare const ENDPOINT_SEED = "Endpoint";
declare const MESSAGE_LIB_SEED = "MessageLib";
declare const SEND_LIBRARY_CONFIG_SEED = "SendLibraryConfig";
declare const RECEIVE_LIBRARY_CONFIG_SEED = "ReceiveLibraryConfig";
declare const NONCE_SEED = "Nonce";
declare const PENDING_NONCE_SEED = "PendingNonce";
declare const PAYLOAD_HASH_SEED = "PayloadHash";
declare const COMPOSED_MESSAGE_HASH_SEED = "ComposedMessageHash";
declare const OAPP_SEED = "OApp";
declare const COUNT_SEED = "Count";
declare const REMOTE_SEED = "Remote";
declare const LZ_RECEIVE_TYPES_SEED = "LzReceiveTypes";
declare const LZ_COMPOSE_TYPES_SEED = "LzComposeTypes";
declare const ULN_SEED = "MessageLib";
declare const ULN_CONFIG_SEED = "UlnConfig";
declare const SEND_CONFIG_SEED = "SendConfig";
declare const RECEIVE_CONFIG_SEED = "ReceiveConfig";
declare const OPTIONS_SEED = "Options";
declare const CONFIRMATIONS_SEED = "Confirmations";
declare const WORKER_SEED = "Worker";
declare const DVN_CONFIG_SEED = "DvnConfig";
declare const EVENT_SEED = "__event_authority";
declare const EXECUTOR_CONFIG_SEED = "ExecutorConfig";
declare const PRICE_FEED_SEED = "PriceFeed";
declare const OFT_SEED$1 = "Oft";
declare const PEER_SEED = "Peer";
declare const MINT_SEED = "Mint";
declare const ENFORCED_OPTIONS_SEED = "EnforcedOptions";
/**
 * derive address for endpoint program
 */
declare class EndpointPDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    setting(): [PublicKey, number];
    defaultSendLibraryConfig(dstEndpointId: number): [PublicKey, number];
    sendLibraryConfig(sender: PublicKey, dstEndpointId: number): [PublicKey, number];
    /**
     * @param messageLibrary PDA(derive by message lib program)
     */
    messageLibraryInfo(messageLibrary: PublicKey): [PublicKey, number];
    defaultReceiveLibraryConfig(srcEndpointId: number): [PublicKey, number];
    receiveLibraryConfig(receiver: PublicKey, srcEndpointId: number): [PublicKey, number];
    receiveLibraryTimeout(_dstEndpointId: number): [PublicKey, number];
    defaultMessageLib(): [PublicKey, number];
    blockMessageLib(blockMsgLib: PublicKey): [PublicKey, number];
    /**
     * @param localOapp
     * @param remoteChainId
     * @param remoteOapp
     */
    nonce(localOapp: PublicKey, remoteChainId: number, remoteOapp: Uint8Array): [PublicKey, number];
    pendingNonce(localOapp: PublicKey, remoteChainId: number, remoteOapp: Uint8Array): [PublicKey, number];
    oappRegistry(localOapp: PublicKey): [PublicKey, number];
    /***
     * @param receiver
     * @param srcEid
     * @param sender
     * @param nonce
     * @param payloadHash
     * @srcChainId u32 to Uint8Array([0,0,0,0])
     * @sender [u8; 32] sender Address
     * @nonce u64 to Uint8Array([0,0,0,0,0,0,0,0])
     * @payloadHash [u8; 32]
     */
    payloadHash(receiver: PublicKey, srcEid: number, sender: Uint8Array, nonce: number): [PublicKey, number];
    composedMessage(from: PublicKey, guid: Uint8Array, index: number, to: PublicKey, messageHash: Uint8Array): [PublicKey, number];
}
/***
 * derive address by message lib program
 */
declare class MessageLibPDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    messageLib(): [PublicKey, number];
    sendConfig(eid: number, oapp: PublicKey): [PublicKey, number];
    receiveConfig(eid: number, oapp: PublicKey): [PublicKey, number];
}
declare class UlnPDADeriver extends MessageLibPDADeriver {
    setting(): [PublicKey, number];
    config(eid: number): [PublicKey, number];
    defaultSendConfig(eid: number): [PublicKey, number];
    defaultReceiveConfig(eid: number): [PublicKey, number];
    options(eit: number): [PublicKey, number];
    workerConfig(worker: PublicKey): [PublicKey, number];
    confirmations(headerHash: Uint8Array, payloadHash: Uint8Array, dvn: PublicKey): [PublicKey, number];
}
/**
 * derive address by base oapp program
 */
declare class OAppBasePDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    remote(dstChainId: number): [PublicKey, number];
    lzReceiveTypesAccounts(): [PublicKey, number];
    lzComposeTypesAccounts(): [PublicKey, number];
}
/**
 * derive address by omnicounter program
 */
declare class OmniCounterPDADeriver extends OAppBasePDADeriver {
    counterId: number;
    constructor(program: PublicKey, counterId: number);
    count(): [PublicKey, number];
    remote(dstChainId: number): [PublicKey, number];
    lzReceiveTypesAccounts(): [PublicKey, number];
    lzComposeTypesAccounts(): [PublicKey, number];
}
declare class DVNDeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    authority(): [PublicKey, number];
    config(): [PublicKey, number];
    executeHash(digestHash: Buffer): [PublicKey, number];
}
declare class EventPDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    eventAuthority(): [PublicKey, number];
}
declare class ExecutorPDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    config(): [PublicKey, number];
}
declare class PriceFeedPDADeriver {
    program: PublicKey;
    constructor(program: PublicKey);
    priceFeed(): [PublicKey, number];
}
declare class OftPDADeriver {
    program: PublicKey;
    constructor(program?: PublicKey);
    config(): [PublicKey, number];
    enforcedOptions(oftConfig: PublicKey, eid: number): [PublicKey, number];
    peer(oftConfig: PublicKey, eid: number): [PublicKey, number];
    oftConfig(mintOrEscrow: PublicKey): [PublicKey, number];
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ComposeMessageState}
 * @category Accounts
 * @category generated
 */
type ComposeMessageStateArgs = {
    received: boolean;
    bump: number;
};
declare const composeMessageStateDiscriminator: number[];
/**
 * Holds the data for the {@link ComposeMessageState} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ComposeMessageState implements ComposeMessageStateArgs {
    readonly received: boolean;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link ComposeMessageState} instance from the provided args.
     */
    static fromArgs(args: ComposeMessageStateArgs): ComposeMessageState;
    /**
     * Deserializes the {@link ComposeMessageState} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ComposeMessageState, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ComposeMessageState} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ComposeMessageState>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        received: any;
        bump: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link ComposeMessageState} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ComposeMessageState, number];
    /**
     * Serializes the {@link ComposeMessageState} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ComposeMessageState}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ComposeMessageState} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link ComposeMessageState} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link ComposeMessageState} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        received: boolean;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const composeMessageStateBeet: beet.BeetStruct<ComposeMessageState, ComposeMessageStateArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link EndpointSettings}
 * @category Accounts
 * @category generated
 */
type EndpointSettingsArgs = {
    eid: number;
    bump: number;
    admin: web3.PublicKey;
    lzTokenMint: beet.COption<web3.PublicKey>;
};
declare const endpointSettingsDiscriminator: number[];
/**
 * Holds the data for the {@link EndpointSettings} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class EndpointSettings implements EndpointSettingsArgs {
    readonly eid: number;
    readonly bump: number;
    readonly admin: web3.PublicKey;
    readonly lzTokenMint: beet.COption<web3.PublicKey>;
    private constructor();
    /**
     * Creates a {@link EndpointSettings} instance from the provided args.
     */
    static fromArgs(args: EndpointSettingsArgs): EndpointSettings;
    /**
     * Deserializes the {@link EndpointSettings} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [EndpointSettings, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link EndpointSettings} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<EndpointSettings>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<EndpointSettingsArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link EndpointSettings} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [EndpointSettings, number];
    /**
     * Serializes the {@link EndpointSettings} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link EndpointSettings} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: EndpointSettingsArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link EndpointSettings} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: EndpointSettingsArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link EndpointSettings} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        eid: number;
        bump: number;
        admin: string;
        lzTokenMint: beet.COption<web3.PublicKey>;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const endpointSettingsBeet: beet.FixableBeetStruct<EndpointSettings, EndpointSettingsArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum MessageLibType {
    Send = 0,
    Receive = 1,
    SendAndReceive = 2
}
/**
 * @category userTypes
 * @category generated
 */
declare const messageLibTypeBeet: beet.FixedSizeBeet<MessageLibType, MessageLibType>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link MessageLibInfo}
 * @category Accounts
 * @category generated
 */
type MessageLibInfoArgs = {
    messageLibType: MessageLibType;
    bump: number;
    messageLibBump: number;
};
declare const messageLibInfoDiscriminator: number[];
/**
 * Holds the data for the {@link MessageLibInfo} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class MessageLibInfo implements MessageLibInfoArgs {
    readonly messageLibType: MessageLibType;
    readonly bump: number;
    readonly messageLibBump: number;
    private constructor();
    /**
     * Creates a {@link MessageLibInfo} instance from the provided args.
     */
    static fromArgs(args: MessageLibInfoArgs): MessageLibInfo;
    /**
     * Deserializes the {@link MessageLibInfo} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [MessageLibInfo, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link MessageLibInfo} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<MessageLibInfo>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        bump: any;
        messageLibType: any;
        messageLibBump: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link MessageLibInfo} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [MessageLibInfo, number];
    /**
     * Serializes the {@link MessageLibInfo} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link MessageLibInfo}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link MessageLibInfo} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link MessageLibInfo} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link MessageLibInfo} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        messageLibType: string;
        bump: number;
        messageLibBump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const messageLibInfoBeet: beet.BeetStruct<MessageLibInfo, MessageLibInfoArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link Nonce}
 * @category Accounts
 * @category generated
 */
type NonceArgs$1 = {
    bump: number;
    outboundNonce: beet.bignum;
    inboundNonce: beet.bignum;
};
declare const nonceDiscriminator$1: number[];
/**
 * Holds the data for the {@link Nonce} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class Nonce$1 implements NonceArgs$1 {
    readonly bump: number;
    readonly outboundNonce: beet.bignum;
    readonly inboundNonce: beet.bignum;
    private constructor();
    /**
     * Creates a {@link Nonce} instance from the provided args.
     */
    static fromArgs(args: NonceArgs$1): Nonce$1;
    /**
     * Deserializes the {@link Nonce} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [Nonce$1, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link Nonce} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<Nonce$1>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        bump: any;
        outboundNonce: any;
        inboundNonce: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link Nonce} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [Nonce$1, number];
    /**
     * Serializes the {@link Nonce} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link Nonce}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link Nonce} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link Nonce} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link Nonce} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        outboundNonce: number | {
            toNumber: () => number;
        };
        inboundNonce: number | {
            toNumber: () => number;
        };
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const nonceBeet$1: beet.BeetStruct<Nonce$1, NonceArgs$1 & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link OAppRegistry}
 * @category Accounts
 * @category generated
 */
type OAppRegistryArgs = {
    delegate: web3.PublicKey;
    bump: number;
};
declare const oAppRegistryDiscriminator: number[];
/**
 * Holds the data for the {@link OAppRegistry} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class OAppRegistry implements OAppRegistryArgs {
    readonly delegate: web3.PublicKey;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link OAppRegistry} instance from the provided args.
     */
    static fromArgs(args: OAppRegistryArgs): OAppRegistry;
    /**
     * Deserializes the {@link OAppRegistry} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [OAppRegistry, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link OAppRegistry} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<OAppRegistry>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        delegate: any;
        bump: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link OAppRegistry} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [OAppRegistry, number];
    /**
     * Serializes the {@link OAppRegistry} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link OAppRegistry}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link OAppRegistry} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link OAppRegistry} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link OAppRegistry} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        delegate: string;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const oAppRegistryBeet: beet.BeetStruct<OAppRegistry, OAppRegistryArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link PayloadHash}
 * @category Accounts
 * @category generated
 */
type PayloadHashArgs = {
    hash: number[];
    bump: number;
};
declare const payloadHashDiscriminator: number[];
/**
 * Holds the data for the {@link PayloadHash} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class PayloadHash implements PayloadHashArgs {
    readonly hash: number[];
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link PayloadHash} instance from the provided args.
     */
    static fromArgs(args: PayloadHashArgs): PayloadHash;
    /**
     * Deserializes the {@link PayloadHash} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [PayloadHash, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link PayloadHash} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<PayloadHash>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        bump: any;
        hash: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link PayloadHash} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [PayloadHash, number];
    /**
     * Serializes the {@link PayloadHash} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link PayloadHash}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link PayloadHash} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link PayloadHash} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link PayloadHash} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        hash: number[];
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const payloadHashBeet: beet.BeetStruct<PayloadHash, PayloadHashArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link PendingInboundNonce}
 * @category Accounts
 * @category generated
 */
type PendingInboundNonceArgs = {
    nonces: beet.bignum[];
    bump: number;
};
declare const pendingInboundNonceDiscriminator: number[];
/**
 * Holds the data for the {@link PendingInboundNonce} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class PendingInboundNonce implements PendingInboundNonceArgs {
    readonly nonces: beet.bignum[];
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link PendingInboundNonce} instance from the provided args.
     */
    static fromArgs(args: PendingInboundNonceArgs): PendingInboundNonce;
    /**
     * Deserializes the {@link PendingInboundNonce} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [PendingInboundNonce, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link PendingInboundNonce} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<PendingInboundNonce>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<PendingInboundNonceArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link PendingInboundNonce} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [PendingInboundNonce, number];
    /**
     * Serializes the {@link PendingInboundNonce} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link PendingInboundNonce} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: PendingInboundNonceArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link PendingInboundNonce} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: PendingInboundNonceArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link PendingInboundNonce} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        nonces: beet.bignum[];
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const pendingInboundNonceBeet: beet.FixableBeetStruct<PendingInboundNonce, PendingInboundNonceArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReceiveLibraryTimeout = {
    messageLib: web3.PublicKey;
    expiry: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const receiveLibraryTimeoutBeet: beet.BeetArgsStruct<ReceiveLibraryTimeout>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ReceiveLibraryConfig}
 * @category Accounts
 * @category generated
 */
type ReceiveLibraryConfigArgs = {
    messageLib: web3.PublicKey;
    timeout: beet.COption<ReceiveLibraryTimeout>;
    bump: number;
};
declare const receiveLibraryConfigDiscriminator: number[];
/**
 * Holds the data for the {@link ReceiveLibraryConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ReceiveLibraryConfig implements ReceiveLibraryConfigArgs {
    readonly messageLib: web3.PublicKey;
    readonly timeout: beet.COption<ReceiveLibraryTimeout>;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link ReceiveLibraryConfig} instance from the provided args.
     */
    static fromArgs(args: ReceiveLibraryConfigArgs): ReceiveLibraryConfig;
    /**
     * Deserializes the {@link ReceiveLibraryConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ReceiveLibraryConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ReceiveLibraryConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ReceiveLibraryConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ReceiveLibraryConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link ReceiveLibraryConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ReceiveLibraryConfig, number];
    /**
     * Serializes the {@link ReceiveLibraryConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ReceiveLibraryConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ReceiveLibraryConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ReceiveLibraryConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ReceiveLibraryConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link ReceiveLibraryConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        messageLib: string;
        timeout: beet.COption<ReceiveLibraryTimeout>;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const receiveLibraryConfigBeet: beet.FixableBeetStruct<ReceiveLibraryConfig, ReceiveLibraryConfigArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link SendLibraryConfig}
 * @category Accounts
 * @category generated
 */
type SendLibraryConfigArgs = {
    messageLib: web3.PublicKey;
    bump: number;
};
declare const sendLibraryConfigDiscriminator: number[];
/**
 * Holds the data for the {@link SendLibraryConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class SendLibraryConfig implements SendLibraryConfigArgs {
    readonly messageLib: web3.PublicKey;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link SendLibraryConfig} instance from the provided args.
     */
    static fromArgs(args: SendLibraryConfigArgs): SendLibraryConfig;
    /**
     * Deserializes the {@link SendLibraryConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [SendLibraryConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link SendLibraryConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<SendLibraryConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        messageLib: any;
        bump: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link SendLibraryConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [SendLibraryConfig, number];
    /**
     * Serializes the {@link SendLibraryConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link SendLibraryConfig}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link SendLibraryConfig} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link SendLibraryConfig} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link SendLibraryConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        messageLib: string;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const sendLibraryConfigBeet: beet.BeetStruct<SendLibraryConfig, SendLibraryConfigArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$6: {
    ComposeMessageState: typeof ComposeMessageState;
    EndpointSettings: typeof EndpointSettings;
    OAppRegistry: typeof OAppRegistry;
    MessageLibInfo: typeof MessageLibInfo;
    ReceiveLibraryConfig: typeof ReceiveLibraryConfig;
    SendLibraryConfig: typeof SendLibraryConfig;
    Nonce: typeof Nonce$1;
    PayloadHash: typeof PayloadHash;
    PendingInboundNonce: typeof PendingInboundNonce;
};

type index$s_ComposeMessageState = ComposeMessageState;
declare const index$s_ComposeMessageState: typeof ComposeMessageState;
type index$s_ComposeMessageStateArgs = ComposeMessageStateArgs;
type index$s_EndpointSettings = EndpointSettings;
declare const index$s_EndpointSettings: typeof EndpointSettings;
type index$s_EndpointSettingsArgs = EndpointSettingsArgs;
type index$s_MessageLibInfo = MessageLibInfo;
declare const index$s_MessageLibInfo: typeof MessageLibInfo;
type index$s_MessageLibInfoArgs = MessageLibInfoArgs;
type index$s_OAppRegistry = OAppRegistry;
declare const index$s_OAppRegistry: typeof OAppRegistry;
type index$s_OAppRegistryArgs = OAppRegistryArgs;
type index$s_PayloadHash = PayloadHash;
declare const index$s_PayloadHash: typeof PayloadHash;
type index$s_PayloadHashArgs = PayloadHashArgs;
type index$s_PendingInboundNonce = PendingInboundNonce;
declare const index$s_PendingInboundNonce: typeof PendingInboundNonce;
type index$s_PendingInboundNonceArgs = PendingInboundNonceArgs;
type index$s_ReceiveLibraryConfig = ReceiveLibraryConfig;
declare const index$s_ReceiveLibraryConfig: typeof ReceiveLibraryConfig;
type index$s_ReceiveLibraryConfigArgs = ReceiveLibraryConfigArgs;
type index$s_SendLibraryConfig = SendLibraryConfig;
declare const index$s_SendLibraryConfig: typeof SendLibraryConfig;
type index$s_SendLibraryConfigArgs = SendLibraryConfigArgs;
declare const index$s_composeMessageStateBeet: typeof composeMessageStateBeet;
declare const index$s_composeMessageStateDiscriminator: typeof composeMessageStateDiscriminator;
declare const index$s_endpointSettingsBeet: typeof endpointSettingsBeet;
declare const index$s_endpointSettingsDiscriminator: typeof endpointSettingsDiscriminator;
declare const index$s_messageLibInfoBeet: typeof messageLibInfoBeet;
declare const index$s_messageLibInfoDiscriminator: typeof messageLibInfoDiscriminator;
declare const index$s_oAppRegistryBeet: typeof oAppRegistryBeet;
declare const index$s_oAppRegistryDiscriminator: typeof oAppRegistryDiscriminator;
declare const index$s_payloadHashBeet: typeof payloadHashBeet;
declare const index$s_payloadHashDiscriminator: typeof payloadHashDiscriminator;
declare const index$s_pendingInboundNonceBeet: typeof pendingInboundNonceBeet;
declare const index$s_pendingInboundNonceDiscriminator: typeof pendingInboundNonceDiscriminator;
declare const index$s_receiveLibraryConfigBeet: typeof receiveLibraryConfigBeet;
declare const index$s_receiveLibraryConfigDiscriminator: typeof receiveLibraryConfigDiscriminator;
declare const index$s_sendLibraryConfigBeet: typeof sendLibraryConfigBeet;
declare const index$s_sendLibraryConfigDiscriminator: typeof sendLibraryConfigDiscriminator;
declare namespace index$s {
  export { index$s_ComposeMessageState as ComposeMessageState, type index$s_ComposeMessageStateArgs as ComposeMessageStateArgs, index$s_EndpointSettings as EndpointSettings, type index$s_EndpointSettingsArgs as EndpointSettingsArgs, index$s_MessageLibInfo as MessageLibInfo, type index$s_MessageLibInfoArgs as MessageLibInfoArgs, Nonce$1 as Nonce, type NonceArgs$1 as NonceArgs, index$s_OAppRegistry as OAppRegistry, type index$s_OAppRegistryArgs as OAppRegistryArgs, index$s_PayloadHash as PayloadHash, type index$s_PayloadHashArgs as PayloadHashArgs, index$s_PendingInboundNonce as PendingInboundNonce, type index$s_PendingInboundNonceArgs as PendingInboundNonceArgs, index$s_ReceiveLibraryConfig as ReceiveLibraryConfig, type index$s_ReceiveLibraryConfigArgs as ReceiveLibraryConfigArgs, index$s_SendLibraryConfig as SendLibraryConfig, type index$s_SendLibraryConfigArgs as SendLibraryConfigArgs, accountProviders$6 as accountProviders, index$s_composeMessageStateBeet as composeMessageStateBeet, index$s_composeMessageStateDiscriminator as composeMessageStateDiscriminator, index$s_endpointSettingsBeet as endpointSettingsBeet, index$s_endpointSettingsDiscriminator as endpointSettingsDiscriminator, index$s_messageLibInfoBeet as messageLibInfoBeet, index$s_messageLibInfoDiscriminator as messageLibInfoDiscriminator, nonceBeet$1 as nonceBeet, nonceDiscriminator$1 as nonceDiscriminator, index$s_oAppRegistryBeet as oAppRegistryBeet, index$s_oAppRegistryDiscriminator as oAppRegistryDiscriminator, index$s_payloadHashBeet as payloadHashBeet, index$s_payloadHashDiscriminator as payloadHashDiscriminator, index$s_pendingInboundNonceBeet as pendingInboundNonceBeet, index$s_pendingInboundNonceDiscriminator as pendingInboundNonceDiscriminator, index$s_receiveLibraryConfigBeet as receiveLibraryConfigBeet, index$s_receiveLibraryConfigDiscriminator as receiveLibraryConfigDiscriminator, index$s_sendLibraryConfigBeet as sendLibraryConfigBeet, index$s_sendLibraryConfigDiscriminator as sendLibraryConfigDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode$5 = Error & {
    code: number;
};
type MaybeErrorWithCode$5 = ErrorWithCode$5 | null | undefined;
/**
 * InvalidSendLibrary: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSendLibraryError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidReceiveLibrary: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidReceiveLibraryError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * SameValue: ''
 *
 * @category Errors
 * @category generated
 */
declare class SameValueError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * AccountNotFound: ''
 *
 * @category Errors
 * @category generated
 */
declare class AccountNotFoundError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * OnlySendLib: ''
 *
 * @category Errors
 * @category generated
 */
declare class OnlySendLibError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * OnlyReceiveLib: ''
 *
 * @category Errors
 * @category generated
 */
declare class OnlyReceiveLibError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidExpiry: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidExpiryError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * OnlyNonDefaultLib: ''
 *
 * @category Errors
 * @category generated
 */
declare class OnlyNonDefaultLibError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidAmount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidAmountError$3 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidNonce: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidNonceError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Unauthorized: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnauthorizedError$2 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * PayloadHashNotFound: ''
 *
 * @category Errors
 * @category generated
 */
declare class PayloadHashNotFoundError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ComposeNotFound: ''
 *
 * @category Errors
 * @category generated
 */
declare class ComposeNotFoundError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidPayloadHash: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidPayloadHashError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * LzTokenUnavailable: ''
 *
 * @category Errors
 * @category generated
 */
declare class LzTokenUnavailableError$2 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ReadOnlyAccount: ''
 *
 * @category Errors
 * @category generated
 */
declare class ReadOnlyAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMessageLib: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMessageLibError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * WritableAccountNotAllowed: ''
 *
 * @category Errors
 * @category generated
 */
declare class WritableAccountNotAllowedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode$5(code: number): MaybeErrorWithCode$5;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName$5(name: string): MaybeErrorWithCode$5;

type index$r_AccountNotFoundError = AccountNotFoundError;
declare const index$r_AccountNotFoundError: typeof AccountNotFoundError;
type index$r_ComposeNotFoundError = ComposeNotFoundError;
declare const index$r_ComposeNotFoundError: typeof ComposeNotFoundError;
type index$r_InvalidExpiryError = InvalidExpiryError;
declare const index$r_InvalidExpiryError: typeof InvalidExpiryError;
type index$r_InvalidMessageLibError = InvalidMessageLibError;
declare const index$r_InvalidMessageLibError: typeof InvalidMessageLibError;
type index$r_InvalidNonceError = InvalidNonceError;
declare const index$r_InvalidNonceError: typeof InvalidNonceError;
type index$r_InvalidPayloadHashError = InvalidPayloadHashError;
declare const index$r_InvalidPayloadHashError: typeof InvalidPayloadHashError;
type index$r_InvalidReceiveLibraryError = InvalidReceiveLibraryError;
declare const index$r_InvalidReceiveLibraryError: typeof InvalidReceiveLibraryError;
type index$r_InvalidSendLibraryError = InvalidSendLibraryError;
declare const index$r_InvalidSendLibraryError: typeof InvalidSendLibraryError;
type index$r_OnlyNonDefaultLibError = OnlyNonDefaultLibError;
declare const index$r_OnlyNonDefaultLibError: typeof OnlyNonDefaultLibError;
type index$r_OnlyReceiveLibError = OnlyReceiveLibError;
declare const index$r_OnlyReceiveLibError: typeof OnlyReceiveLibError;
type index$r_OnlySendLibError = OnlySendLibError;
declare const index$r_OnlySendLibError: typeof OnlySendLibError;
type index$r_PayloadHashNotFoundError = PayloadHashNotFoundError;
declare const index$r_PayloadHashNotFoundError: typeof PayloadHashNotFoundError;
type index$r_ReadOnlyAccountError = ReadOnlyAccountError;
declare const index$r_ReadOnlyAccountError: typeof ReadOnlyAccountError;
type index$r_SameValueError = SameValueError;
declare const index$r_SameValueError: typeof SameValueError;
type index$r_WritableAccountNotAllowedError = WritableAccountNotAllowedError;
declare const index$r_WritableAccountNotAllowedError: typeof WritableAccountNotAllowedError;
declare namespace index$r {
  export { index$r_AccountNotFoundError as AccountNotFoundError, index$r_ComposeNotFoundError as ComposeNotFoundError, InvalidAmountError$3 as InvalidAmountError, index$r_InvalidExpiryError as InvalidExpiryError, index$r_InvalidMessageLibError as InvalidMessageLibError, index$r_InvalidNonceError as InvalidNonceError, index$r_InvalidPayloadHashError as InvalidPayloadHashError, index$r_InvalidReceiveLibraryError as InvalidReceiveLibraryError, index$r_InvalidSendLibraryError as InvalidSendLibraryError, LzTokenUnavailableError$2 as LzTokenUnavailableError, index$r_OnlyNonDefaultLibError as OnlyNonDefaultLibError, index$r_OnlyReceiveLibError as OnlyReceiveLibError, index$r_OnlySendLibError as OnlySendLibError, index$r_PayloadHashNotFoundError as PayloadHashNotFoundError, index$r_ReadOnlyAccountError as ReadOnlyAccountError, index$r_SameValueError as SameValueError, UnauthorizedError$2 as UnauthorizedError, index$r_WritableAccountNotAllowedError as WritableAccountNotAllowedError, errorFromCode$5 as errorFromCode, errorFromName$5 as errorFromName };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type BurnParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const burnParamsBeet: beet.BeetArgsStruct<BurnParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Burn
 * @category generated
 */
type BurnInstructionArgs = {
    params: BurnParams;
};
/**
 * @category Instructions
 * @category Burn
 * @category generated
 */
declare const burnStruct: beet.BeetArgsStruct<BurnInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _burn_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [] nonce
 * @property [_writable_] payloadHash
 * @property [_writable_] endpoint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Burn
 * @category generated
 */
type BurnInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    nonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    endpoint: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const burnInstructionDiscriminator: number[];
/**
 * Creates a _Burn_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Burn
 * @category generated
 */
declare function createBurnInstruction(accounts: BurnInstructionAccounts, args: BurnInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Burn_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Burn
 * @category generated
 */
declare function createBurnInstructionAccounts(accounts: BurnInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ClearParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    guid: number[];
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const clearParamsBeet: beet.FixableBeetArgsStruct<ClearParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Clear
 * @category generated
 */
type ClearInstructionArgs = {
    params: ClearParams;
};
/**
 * @category Instructions
 * @category Clear
 * @category generated
 */
declare const clearStruct: beet.FixableBeetArgsStruct<ClearInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _clear_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [] nonce
 * @property [_writable_] payloadHash
 * @property [_writable_] endpoint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Clear
 * @category generated
 */
type ClearInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    nonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    endpoint: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const clearInstructionDiscriminator: number[];
/**
 * Creates a _Clear_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Clear
 * @category generated
 */
declare function createClearInstruction(accounts: ClearInstructionAccounts, args: ClearInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Clear_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Clear
 * @category generated
 */
declare function createClearInstructionAccounts(accounts: ClearInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ClearComposeParams = {
    from: web3.PublicKey;
    guid: number[];
    index: number;
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const clearComposeParamsBeet: beet.FixableBeetArgsStruct<ClearComposeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ClearCompose
 * @category generated
 */
type ClearComposeInstructionArgs = {
    params: ClearComposeParams;
};
/**
 * @category Instructions
 * @category ClearCompose
 * @category generated
 */
declare const clearComposeStruct: beet.FixableBeetArgsStruct<ClearComposeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _clearCompose_ instruction
 *
 * @property [**signer**] to
 * @property [_writable_] composeMessage
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category ClearCompose
 * @category generated
 */
type ClearComposeInstructionAccounts = {
    to: web3.PublicKey;
    composeMessage: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const clearComposeInstructionDiscriminator: number[];
/**
 * Creates a _ClearCompose_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ClearCompose
 * @category generated
 */
declare function createClearComposeInstruction(accounts: ClearComposeInstructionAccounts, args: ClearComposeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _ClearCompose_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category ClearCompose
 * @category generated
 */
declare function createClearComposeInstructionAccounts(accounts: ClearComposeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitConfigParams$2 = {
    oapp: web3.PublicKey;
    eid: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initConfigParamsBeet$2: beet.BeetArgsStruct<InitConfigParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionArgs$2 = {
    params: InitConfigParams$2;
};
/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare const initConfigStruct$2: beet.BeetArgsStruct<InitConfigInstructionArgs$2 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initConfig_ instruction
 *
 * @property [**signer**] delegate
 * @property [] oappRegistry
 * @property [] messageLibInfo
 * @property [] messageLib
 * @property [] messageLibProgram
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionAccounts$2 = {
    delegate: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    messageLib: web3.PublicKey;
    messageLibProgram: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initConfigInstructionDiscriminator$2: number[];
/**
 * Creates a _InitConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstruction$2(accounts: InitConfigInstructionAccounts$2, args: InitConfigInstructionArgs$2, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstructionAccounts$2(accounts: InitConfigInstructionAccounts$2, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitDefaultReceiveLibraryParams = {
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initDefaultReceiveLibraryParamsBeet: beet.BeetArgsStruct<InitDefaultReceiveLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitDefaultReceiveLibrary
 * @category generated
 */
type InitDefaultReceiveLibraryInstructionArgs = {
    params: InitDefaultReceiveLibraryParams;
};
/**
 * @category Instructions
 * @category InitDefaultReceiveLibrary
 * @category generated
 */
declare const initDefaultReceiveLibraryStruct: beet.BeetArgsStruct<InitDefaultReceiveLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initDefaultReceiveLibrary_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [] endpoint
 * @property [_writable_] defaultReceiveLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category InitDefaultReceiveLibrary
 * @category generated
 */
type InitDefaultReceiveLibraryInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    defaultReceiveLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initDefaultReceiveLibraryInstructionDiscriminator: number[];
/**
 * Creates a _InitDefaultReceiveLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitDefaultReceiveLibrary
 * @category generated
 */
declare function createInitDefaultReceiveLibraryInstruction(accounts: InitDefaultReceiveLibraryInstructionAccounts, args: InitDefaultReceiveLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitDefaultReceiveLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitDefaultReceiveLibrary
 * @category generated
 */
declare function createInitDefaultReceiveLibraryInstructionAccounts(accounts: InitDefaultReceiveLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitDefaultSendLibraryParams = {
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initDefaultSendLibraryParamsBeet: beet.BeetArgsStruct<InitDefaultSendLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitDefaultSendLibrary
 * @category generated
 */
type InitDefaultSendLibraryInstructionArgs = {
    params: InitDefaultSendLibraryParams;
};
/**
 * @category Instructions
 * @category InitDefaultSendLibrary
 * @category generated
 */
declare const initDefaultSendLibraryStruct: beet.BeetArgsStruct<InitDefaultSendLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initDefaultSendLibrary_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [] endpoint
 * @property [_writable_] defaultSendLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category InitDefaultSendLibrary
 * @category generated
 */
type InitDefaultSendLibraryInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    defaultSendLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initDefaultSendLibraryInstructionDiscriminator: number[];
/**
 * Creates a _InitDefaultSendLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitDefaultSendLibrary
 * @category generated
 */
declare function createInitDefaultSendLibraryInstruction(accounts: InitDefaultSendLibraryInstructionAccounts, args: InitDefaultSendLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitDefaultSendLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitDefaultSendLibrary
 * @category generated
 */
declare function createInitDefaultSendLibraryInstructionAccounts(accounts: InitDefaultSendLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitEndpointParams = {
    eid: number;
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initEndpointParamsBeet: beet.BeetArgsStruct<InitEndpointParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitEndpoint
 * @category generated
 */
type InitEndpointInstructionArgs = {
    params: InitEndpointParams;
};
/**
 * @category Instructions
 * @category InitEndpoint
 * @category generated
 */
declare const initEndpointStruct: beet.BeetArgsStruct<InitEndpointInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initEndpoint_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] endpoint
 * @category Instructions
 * @category InitEndpoint
 * @category generated
 */
type InitEndpointInstructionAccounts = {
    payer: web3.PublicKey;
    endpoint: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initEndpointInstructionDiscriminator: number[];
/**
 * Creates a _InitEndpoint_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitEndpoint
 * @category generated
 */
declare function createInitEndpointInstruction(accounts: InitEndpointInstructionAccounts, args: InitEndpointInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitEndpoint_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitEndpoint
 * @category generated
 */
declare function createInitEndpointInstructionAccounts(accounts: InitEndpointInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitNonceParams = {
    localOapp: web3.PublicKey;
    remoteEid: number;
    remoteOapp: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const initNonceParamsBeet: beet.BeetArgsStruct<InitNonceParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitNonce
 * @category generated
 */
type InitNonceInstructionArgs = {
    params: InitNonceParams;
};
/**
 * @category Instructions
 * @category InitNonce
 * @category generated
 */
declare const initNonceStruct: beet.BeetArgsStruct<InitNonceInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initNonce_ instruction
 *
 * @property [_writable_, **signer**] delegate
 * @property [] oappRegistry
 * @property [_writable_] nonce
 * @property [_writable_] pendingInboundNonce
 * @category Instructions
 * @category InitNonce
 * @category generated
 */
type InitNonceInstructionAccounts = {
    delegate: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    nonce: web3.PublicKey;
    pendingInboundNonce: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initNonceInstructionDiscriminator: number[];
/**
 * Creates a _InitNonce_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitNonce
 * @category generated
 */
declare function createInitNonceInstruction(accounts: InitNonceInstructionAccounts, args: InitNonceInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitNonce_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitNonce
 * @category generated
 */
declare function createInitNonceInstructionAccounts(accounts: InitNonceInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitReceiveLibraryParams = {
    receiver: web3.PublicKey;
    eid: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initReceiveLibraryParamsBeet: beet.BeetArgsStruct<InitReceiveLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitReceiveLibrary
 * @category generated
 */
type InitReceiveLibraryInstructionArgs = {
    params: InitReceiveLibraryParams;
};
/**
 * @category Instructions
 * @category InitReceiveLibrary
 * @category generated
 */
declare const initReceiveLibraryStruct: beet.BeetArgsStruct<InitReceiveLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initReceiveLibrary_ instruction
 *
 * @property [_writable_, **signer**] delegate
 * @property [] oappRegistry
 * @property [_writable_] receiveLibraryConfig
 * @category Instructions
 * @category InitReceiveLibrary
 * @category generated
 */
type InitReceiveLibraryInstructionAccounts = {
    delegate: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    receiveLibraryConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initReceiveLibraryInstructionDiscriminator: number[];
/**
 * Creates a _InitReceiveLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitReceiveLibrary
 * @category generated
 */
declare function createInitReceiveLibraryInstruction(accounts: InitReceiveLibraryInstructionAccounts, args: InitReceiveLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitReceiveLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitReceiveLibrary
 * @category generated
 */
declare function createInitReceiveLibraryInstructionAccounts(accounts: InitReceiveLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitSendLibraryParams = {
    sender: web3.PublicKey;
    eid: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initSendLibraryParamsBeet: beet.BeetArgsStruct<InitSendLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitSendLibrary
 * @category generated
 */
type InitSendLibraryInstructionArgs = {
    params: InitSendLibraryParams;
};
/**
 * @category Instructions
 * @category InitSendLibrary
 * @category generated
 */
declare const initSendLibraryStruct: beet.BeetArgsStruct<InitSendLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initSendLibrary_ instruction
 *
 * @property [_writable_, **signer**] delegate
 * @property [] oappRegistry
 * @property [_writable_] sendLibraryConfig
 * @category Instructions
 * @category InitSendLibrary
 * @category generated
 */
type InitSendLibraryInstructionAccounts = {
    delegate: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    sendLibraryConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initSendLibraryInstructionDiscriminator: number[];
/**
 * Creates a _InitSendLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitSendLibrary
 * @category generated
 */
declare function createInitSendLibraryInstruction(accounts: InitSendLibraryInstructionAccounts, args: InitSendLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitSendLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitSendLibrary
 * @category generated
 */
declare function createInitSendLibraryInstructionAccounts(accounts: InitSendLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitVerifyParams$1 = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initVerifyParamsBeet$1: beet.BeetArgsStruct<InitVerifyParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
type InitVerifyInstructionArgs$1 = {
    params: InitVerifyParams$1;
};
/**
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare const initVerifyStruct$1: beet.BeetArgsStruct<InitVerifyInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initVerify_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [] nonce
 * @property [_writable_] payloadHash
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
type InitVerifyInstructionAccounts$1 = {
    payer: web3.PublicKey;
    nonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initVerifyInstructionDiscriminator$1: number[];
/**
 * Creates a _InitVerify_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare function createInitVerifyInstruction$1(accounts: InitVerifyInstructionAccounts$1, args: InitVerifyInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitVerify_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare function createInitVerifyInstructionAccounts$1(accounts: InitVerifyInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzComposeAlertParams = {
    from: web3.PublicKey;
    to: web3.PublicKey;
    guid: number[];
    index: number;
    computeUnits: beet.bignum;
    value: beet.bignum;
    message: Uint8Array;
    extraData: Uint8Array;
    reason: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzComposeAlertParamsBeet: beet.FixableBeetArgsStruct<LzComposeAlertParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category LzComposeAlert
 * @category generated
 */
type LzComposeAlertInstructionArgs = {
    params: LzComposeAlertParams;
};
/**
 * @category Instructions
 * @category LzComposeAlert
 * @category generated
 */
declare const lzComposeAlertStruct: beet.FixableBeetArgsStruct<LzComposeAlertInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _lzComposeAlert_ instruction
 *
 * @property [**signer**] executor
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category LzComposeAlert
 * @category generated
 */
type LzComposeAlertInstructionAccounts = {
    executor: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const lzComposeAlertInstructionDiscriminator: number[];
/**
 * Creates a _LzComposeAlert_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category LzComposeAlert
 * @category generated
 */
declare function createLzComposeAlertInstruction(accounts: LzComposeAlertInstructionAccounts, args: LzComposeAlertInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _LzComposeAlert_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category LzComposeAlert
 * @category generated
 */
declare function createLzComposeAlertInstructionAccounts(accounts: LzComposeAlertInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzReceiveAlertParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    guid: number[];
    computeUnits: beet.bignum;
    value: beet.bignum;
    message: Uint8Array;
    extraData: Uint8Array;
    reason: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzReceiveAlertParamsBeet: beet.FixableBeetArgsStruct<LzReceiveAlertParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category LzReceiveAlert
 * @category generated
 */
type LzReceiveAlertInstructionArgs = {
    params: LzReceiveAlertParams;
};
/**
 * @category Instructions
 * @category LzReceiveAlert
 * @category generated
 */
declare const lzReceiveAlertStruct: beet.FixableBeetArgsStruct<LzReceiveAlertInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _lzReceiveAlert_ instruction
 *
 * @property [**signer**] executor
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category LzReceiveAlert
 * @category generated
 */
type LzReceiveAlertInstructionAccounts = {
    executor: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const lzReceiveAlertInstructionDiscriminator: number[];
/**
 * Creates a _LzReceiveAlert_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category LzReceiveAlert
 * @category generated
 */
declare function createLzReceiveAlertInstruction(accounts: LzReceiveAlertInstructionAccounts, args: LzReceiveAlertInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _LzReceiveAlert_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category LzReceiveAlert
 * @category generated
 */
declare function createLzReceiveAlertInstructionAccounts(accounts: LzReceiveAlertInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type NilifyParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const nilifyParamsBeet: beet.BeetArgsStruct<NilifyParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Nilify
 * @category generated
 */
type NilifyInstructionArgs = {
    params: NilifyParams;
};
/**
 * @category Instructions
 * @category Nilify
 * @category generated
 */
declare const nilifyStruct: beet.BeetArgsStruct<NilifyInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _nilify_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [_writable_] nonce
 * @property [_writable_] pendingInboundNonce
 * @property [_writable_] payloadHash
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Nilify
 * @category generated
 */
type NilifyInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    nonce: web3.PublicKey;
    pendingInboundNonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const nilifyInstructionDiscriminator: number[];
/**
 * Creates a _Nilify_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Nilify
 * @category generated
 */
declare function createNilifyInstruction(accounts: NilifyInstructionAccounts, args: NilifyInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Nilify_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Nilify
 * @category generated
 */
declare function createNilifyInstructionAccounts(accounts: NilifyInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteParams$3 = {
    sender: web3.PublicKey;
    dstEid: number;
    receiver: number[];
    message: Uint8Array;
    options: Uint8Array;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteParamsBeet$3: beet.FixableBeetArgsStruct<QuoteParams$3>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionArgs$3 = {
    params: QuoteParams$3;
};
/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare const quoteStruct$3: beet.FixableBeetArgsStruct<QuoteInstructionArgs$3 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quote_ instruction
 *
 * @property [] sendLibraryProgram
 * @property [] sendLibraryConfig
 * @property [] defaultSendLibraryConfig
 * @property [] sendLibraryInfo
 * @property [] endpoint
 * @property [] nonce
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionAccounts$3 = {
    sendLibraryProgram: web3.PublicKey;
    sendLibraryConfig: web3.PublicKey;
    defaultSendLibraryConfig: web3.PublicKey;
    sendLibraryInfo: web3.PublicKey;
    endpoint: web3.PublicKey;
    nonce: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteInstructionDiscriminator$3: number[];
/**
 * Creates a _Quote_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstruction$3(accounts: QuoteInstructionAccounts$3, args: QuoteInstructionArgs$3, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Quote_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstructionAccounts$3(accounts: QuoteInstructionAccounts$3, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type RegisterLibraryParams = {
    libProgram: web3.PublicKey;
    libType: MessageLibType;
};
/**
 * @category userTypes
 * @category generated
 */
declare const registerLibraryParamsBeet: beet.BeetArgsStruct<RegisterLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category RegisterLibrary
 * @category generated
 */
type RegisterLibraryInstructionArgs = {
    params: RegisterLibraryParams;
};
/**
 * @category Instructions
 * @category RegisterLibrary
 * @category generated
 */
declare const registerLibraryStruct: beet.BeetArgsStruct<RegisterLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _registerLibrary_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [] endpoint
 * @property [_writable_] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category RegisterLibrary
 * @category generated
 */
type RegisterLibraryInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const registerLibraryInstructionDiscriminator: number[];
/**
 * Creates a _RegisterLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category RegisterLibrary
 * @category generated
 */
declare function createRegisterLibraryInstruction(accounts: RegisterLibraryInstructionAccounts, args: RegisterLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _RegisterLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category RegisterLibrary
 * @category generated
 */
declare function createRegisterLibraryInstructionAccounts(accounts: RegisterLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type RegisterOAppParams = {
    delegate: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const registerOAppParamsBeet: beet.BeetArgsStruct<RegisterOAppParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category RegisterOapp
 * @category generated
 */
type RegisterOappInstructionArgs = {
    params: RegisterOAppParams;
};
/**
 * @category Instructions
 * @category RegisterOapp
 * @category generated
 */
declare const registerOappStruct: beet.BeetArgsStruct<RegisterOappInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _registerOapp_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [**signer**] oapp
 * @property [_writable_] oappRegistry
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category RegisterOapp
 * @category generated
 */
type RegisterOappInstructionAccounts = {
    payer: web3.PublicKey;
    oapp: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const registerOappInstructionDiscriminator: number[];
/**
 * Creates a _RegisterOapp_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category RegisterOapp
 * @category generated
 */
declare function createRegisterOappInstruction(accounts: RegisterOappInstructionAccounts, args: RegisterOappInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _RegisterOapp_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category RegisterOapp
 * @category generated
 */
declare function createRegisterOappInstructionAccounts(accounts: RegisterOappInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendParams$3 = {
    dstEid: number;
    receiver: number[];
    message: Uint8Array;
    options: Uint8Array;
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendParamsBeet$3: beet.FixableBeetArgsStruct<SendParams$3>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionArgs$3 = {
    params: SendParams$3;
};
/**
 * @category Instructions
 * @category Send
 * @category generated
 */
declare const sendStruct$3: beet.FixableBeetArgsStruct<SendInstructionArgs$3 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _send_ instruction
 *
 * @property [**signer**] sender
 * @property [] sendLibraryProgram
 * @property [] sendLibraryConfig
 * @property [] defaultSendLibraryConfig
 * @property [] sendLibraryInfo
 * @property [] endpoint
 * @property [_writable_] nonce
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionAccounts$3 = {
    sender: web3.PublicKey;
    sendLibraryProgram: web3.PublicKey;
    sendLibraryConfig: web3.PublicKey;
    defaultSendLibraryConfig: web3.PublicKey;
    sendLibraryInfo: web3.PublicKey;
    endpoint: web3.PublicKey;
    nonce: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendInstructionDiscriminator$3: number[];
/**
 * Creates a _Send_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstruction$3(accounts: SendInstructionAccounts$3, args: SendInstructionArgs$3, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Send_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstructionAccounts$3(accounts: SendInstructionAccounts$3, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendComposeParams = {
    to: web3.PublicKey;
    guid: number[];
    index: number;
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendComposeParamsBeet: beet.FixableBeetArgsStruct<SendComposeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SendCompose
 * @category generated
 */
type SendComposeInstructionArgs = {
    params: SendComposeParams;
};
/**
 * @category Instructions
 * @category SendCompose
 * @category generated
 */
declare const sendComposeStruct: beet.FixableBeetArgsStruct<SendComposeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _sendCompose_ instruction
 *
 * @property [**signer**] from
 * @property [_writable_, **signer**] payer
 * @property [_writable_] composeMessage
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SendCompose
 * @category generated
 */
type SendComposeInstructionAccounts = {
    from: web3.PublicKey;
    payer: web3.PublicKey;
    composeMessage: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendComposeInstructionDiscriminator: number[];
/**
 * Creates a _SendCompose_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SendCompose
 * @category generated
 */
declare function createSendComposeInstruction(accounts: SendComposeInstructionAccounts, args: SendComposeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SendCompose_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SendCompose
 * @category generated
 */
declare function createSendComposeInstructionAccounts(accounts: SendComposeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetConfigParams$3 = {
    oapp: web3.PublicKey;
    eid: number;
    configType: number;
    config: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setConfigParamsBeet$3: beet.FixableBeetArgsStruct<SetConfigParams$3>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionArgs$3 = {
    params: SetConfigParams$3;
};
/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare const setConfigStruct$3: beet.FixableBeetArgsStruct<SetConfigInstructionArgs$3 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setConfig_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [] messageLibInfo
 * @property [] messageLib
 * @property [] messageLibProgram
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionAccounts$3 = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    messageLib: web3.PublicKey;
    messageLibProgram: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setConfigInstructionDiscriminator$3: number[];
/**
 * Creates a _SetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstruction$3(accounts: SetConfigInstructionAccounts$3, args: SetConfigInstructionArgs$3, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstructionAccounts$3(accounts: SetConfigInstructionAccounts$3, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDefaultReceiveLibraryParams = {
    eid: number;
    newLib: web3.PublicKey;
    gracePeriod: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDefaultReceiveLibraryParamsBeet: beet.BeetArgsStruct<SetDefaultReceiveLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDefaultReceiveLibrary
 * @category generated
 */
type SetDefaultReceiveLibraryInstructionArgs = {
    params: SetDefaultReceiveLibraryParams;
};
/**
 * @category Instructions
 * @category SetDefaultReceiveLibrary
 * @category generated
 */
declare const setDefaultReceiveLibraryStruct: beet.BeetArgsStruct<SetDefaultReceiveLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDefaultReceiveLibrary_ instruction
 *
 * @property [**signer**] admin
 * @property [] endpoint
 * @property [_writable_] defaultReceiveLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetDefaultReceiveLibrary
 * @category generated
 */
type SetDefaultReceiveLibraryInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    defaultReceiveLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDefaultReceiveLibraryInstructionDiscriminator: number[];
/**
 * Creates a _SetDefaultReceiveLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDefaultReceiveLibrary
 * @category generated
 */
declare function createSetDefaultReceiveLibraryInstruction(accounts: SetDefaultReceiveLibraryInstructionAccounts, args: SetDefaultReceiveLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDefaultReceiveLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDefaultReceiveLibrary
 * @category generated
 */
declare function createSetDefaultReceiveLibraryInstructionAccounts(accounts: SetDefaultReceiveLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDefaultReceiveLibraryTimeoutParams = {
    eid: number;
    lib: web3.PublicKey;
    expiry: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDefaultReceiveLibraryTimeoutParamsBeet: beet.BeetArgsStruct<SetDefaultReceiveLibraryTimeoutParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDefaultReceiveLibraryTimeout
 * @category generated
 */
type SetDefaultReceiveLibraryTimeoutInstructionArgs = {
    params: SetDefaultReceiveLibraryTimeoutParams;
};
/**
 * @category Instructions
 * @category SetDefaultReceiveLibraryTimeout
 * @category generated
 */
declare const setDefaultReceiveLibraryTimeoutStruct: beet.BeetArgsStruct<SetDefaultReceiveLibraryTimeoutInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDefaultReceiveLibraryTimeout_ instruction
 *
 * @property [**signer**] admin
 * @property [] endpoint
 * @property [_writable_] defaultReceiveLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetDefaultReceiveLibraryTimeout
 * @category generated
 */
type SetDefaultReceiveLibraryTimeoutInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    defaultReceiveLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDefaultReceiveLibraryTimeoutInstructionDiscriminator: number[];
/**
 * Creates a _SetDefaultReceiveLibraryTimeout_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDefaultReceiveLibraryTimeout
 * @category generated
 */
declare function createSetDefaultReceiveLibraryTimeoutInstruction(accounts: SetDefaultReceiveLibraryTimeoutInstructionAccounts, args: SetDefaultReceiveLibraryTimeoutInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDefaultReceiveLibraryTimeout_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDefaultReceiveLibraryTimeout
 * @category generated
 */
declare function createSetDefaultReceiveLibraryTimeoutInstructionAccounts(accounts: SetDefaultReceiveLibraryTimeoutInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDefaultSendLibraryParams = {
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDefaultSendLibraryParamsBeet: beet.BeetArgsStruct<SetDefaultSendLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDefaultSendLibrary
 * @category generated
 */
type SetDefaultSendLibraryInstructionArgs = {
    params: SetDefaultSendLibraryParams;
};
/**
 * @category Instructions
 * @category SetDefaultSendLibrary
 * @category generated
 */
declare const setDefaultSendLibraryStruct: beet.BeetArgsStruct<SetDefaultSendLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDefaultSendLibrary_ instruction
 *
 * @property [**signer**] admin
 * @property [] endpoint
 * @property [_writable_] defaultSendLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetDefaultSendLibrary
 * @category generated
 */
type SetDefaultSendLibraryInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    defaultSendLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDefaultSendLibraryInstructionDiscriminator: number[];
/**
 * Creates a _SetDefaultSendLibrary_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDefaultSendLibrary
 * @category generated
 */
declare function createSetDefaultSendLibraryInstruction(accounts: SetDefaultSendLibraryInstructionAccounts, args: SetDefaultSendLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDefaultSendLibrary_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDefaultSendLibrary
 * @category generated
 */
declare function createSetDefaultSendLibraryInstructionAccounts(accounts: SetDefaultSendLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDelegateParams$1 = {
    delegate: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDelegateParamsBeet$1: beet.BeetArgsStruct<SetDelegateParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
type SetDelegateInstructionArgs$1 = {
    params: SetDelegateParams$1;
};
/**
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare const setDelegateStruct$1: beet.BeetArgsStruct<SetDelegateInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDelegate_ instruction
 *
 * @property [**signer**] oapp
 * @property [_writable_] oappRegistry
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
type SetDelegateInstructionAccounts$1 = {
    oapp: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDelegateInstructionDiscriminator$1: number[];
/**
 * Creates a _SetDelegate_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare function createSetDelegateInstruction$1(accounts: SetDelegateInstructionAccounts$1, args: SetDelegateInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDelegate_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare function createSetDelegateInstructionAccounts$1(accounts: SetDelegateInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetLzTokenParams = {
    lzToken: beet.COption<web3.PublicKey>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setLzTokenParamsBeet: beet.FixableBeetArgsStruct<SetLzTokenParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetLzToken
 * @category generated
 */
type SetLzTokenInstructionArgs = {
    params: SetLzTokenParams;
};
/**
 * @category Instructions
 * @category SetLzToken
 * @category generated
 */
declare const setLzTokenStruct: beet.FixableBeetArgsStruct<SetLzTokenInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setLzToken_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] endpoint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetLzToken
 * @category generated
 */
type SetLzTokenInstructionAccounts = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setLzTokenInstructionDiscriminator: number[];
/**
 * Creates a _SetLzToken_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetLzToken
 * @category generated
 */
declare function createSetLzTokenInstruction(accounts: SetLzTokenInstructionAccounts, args: SetLzTokenInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetLzToken_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetLzToken
 * @category generated
 */
declare function createSetLzTokenInstructionAccounts(accounts: SetLzTokenInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetReceiveLibraryParams = {
    receiver: web3.PublicKey;
    eid: number;
    newLib: web3.PublicKey;
    gracePeriod: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setReceiveLibraryParamsBeet: beet.BeetArgsStruct<SetReceiveLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetReceiveLibrary
 * @category generated
 */
type SetReceiveLibraryInstructionArgs = {
    params: SetReceiveLibraryParams;
};
/**
 * @category Instructions
 * @category SetReceiveLibrary
 * @category generated
 */
declare const setReceiveLibraryStruct: beet.BeetArgsStruct<SetReceiveLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setReceiveLibrary_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [_writable_] receiveLibraryConfig
 * @property [] messageLibInfo (optional)
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetReceiveLibrary
 * @category generated
 */
type SetReceiveLibraryInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    receiveLibraryConfig: web3.PublicKey;
    messageLibInfo?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setReceiveLibraryInstructionDiscriminator: number[];
/**
 * Creates a _SetReceiveLibrary_ instruction.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetReceiveLibrary
 * @category generated
 */
declare function createSetReceiveLibraryInstruction(accounts: SetReceiveLibraryInstructionAccounts, args: SetReceiveLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetReceiveLibrary_ instructionAccounts.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetReceiveLibrary
 * @category generated
 */
declare function createSetReceiveLibraryInstructionAccounts(accounts: SetReceiveLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetReceiveLibraryTimeoutParams = {
    receiver: web3.PublicKey;
    eid: number;
    lib: web3.PublicKey;
    expiry: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setReceiveLibraryTimeoutParamsBeet: beet.BeetArgsStruct<SetReceiveLibraryTimeoutParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetReceiveLibraryTimeout
 * @category generated
 */
type SetReceiveLibraryTimeoutInstructionArgs = {
    params: SetReceiveLibraryTimeoutParams;
};
/**
 * @category Instructions
 * @category SetReceiveLibraryTimeout
 * @category generated
 */
declare const setReceiveLibraryTimeoutStruct: beet.BeetArgsStruct<SetReceiveLibraryTimeoutInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setReceiveLibraryTimeout_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [_writable_] receiveLibraryConfig
 * @property [] messageLibInfo
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetReceiveLibraryTimeout
 * @category generated
 */
type SetReceiveLibraryTimeoutInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    receiveLibraryConfig: web3.PublicKey;
    messageLibInfo: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setReceiveLibraryTimeoutInstructionDiscriminator: number[];
/**
 * Creates a _SetReceiveLibraryTimeout_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetReceiveLibraryTimeout
 * @category generated
 */
declare function createSetReceiveLibraryTimeoutInstruction(accounts: SetReceiveLibraryTimeoutInstructionAccounts, args: SetReceiveLibraryTimeoutInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetReceiveLibraryTimeout_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetReceiveLibraryTimeout
 * @category generated
 */
declare function createSetReceiveLibraryTimeoutInstructionAccounts(accounts: SetReceiveLibraryTimeoutInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetSendLibraryParams = {
    sender: web3.PublicKey;
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setSendLibraryParamsBeet: beet.BeetArgsStruct<SetSendLibraryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetSendLibrary
 * @category generated
 */
type SetSendLibraryInstructionArgs = {
    params: SetSendLibraryParams;
};
/**
 * @category Instructions
 * @category SetSendLibrary
 * @category generated
 */
declare const setSendLibraryStruct: beet.BeetArgsStruct<SetSendLibraryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setSendLibrary_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [_writable_] sendLibraryConfig
 * @property [] messageLibInfo (optional)
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetSendLibrary
 * @category generated
 */
type SetSendLibraryInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    sendLibraryConfig: web3.PublicKey;
    messageLibInfo?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setSendLibraryInstructionDiscriminator: number[];
/**
 * Creates a _SetSendLibrary_ instruction.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetSendLibrary
 * @category generated
 */
declare function createSetSendLibraryInstruction(accounts: SetSendLibraryInstructionAccounts, args: SetSendLibraryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetSendLibrary_ instructionAccounts.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetSendLibrary
 * @category generated
 */
declare function createSetSendLibraryInstructionAccounts(accounts: SetSendLibraryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SkipParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const skipParamsBeet: beet.BeetArgsStruct<SkipParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Skip
 * @category generated
 */
type SkipInstructionArgs = {
    params: SkipParams;
};
/**
 * @category Instructions
 * @category Skip
 * @category generated
 */
declare const skipStruct: beet.BeetArgsStruct<SkipInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _skip_ instruction
 *
 * @property [**signer**] signer
 * @property [] oappRegistry
 * @property [_writable_] nonce
 * @property [_writable_] pendingInboundNonce
 * @property [_writable_] payloadHash
 * @property [_writable_] endpoint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Skip
 * @category generated
 */
type SkipInstructionAccounts = {
    signer: web3.PublicKey;
    oappRegistry: web3.PublicKey;
    nonce: web3.PublicKey;
    pendingInboundNonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    endpoint: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const skipInstructionDiscriminator: number[];
/**
 * Creates a _Skip_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Skip
 * @category generated
 */
declare function createSkipInstruction(accounts: SkipInstructionAccounts, args: SkipInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Skip_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Skip
 * @category generated
 */
declare function createSkipInstructionAccounts(accounts: SkipInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransferAdminParams$4 = {
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transferAdminParamsBeet$4: beet.BeetArgsStruct<TransferAdminParams$4>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionArgs$4 = {
    params: TransferAdminParams$4;
};
/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare const transferAdminStruct$4: beet.BeetArgsStruct<TransferAdminInstructionArgs$4 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _transferAdmin_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] endpoint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionAccounts$4 = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const transferAdminInstructionDiscriminator$4: number[];
/**
 * Creates a _TransferAdmin_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstruction$4(accounts: TransferAdminInstructionAccounts$4, args: TransferAdminInstructionArgs$4, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _TransferAdmin_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstructionAccounts$4(accounts: TransferAdminInstructionAccounts$4, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type VerifyParams$1 = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const verifyParamsBeet$1: beet.BeetArgsStruct<VerifyParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Verify
 * @category generated
 */
type VerifyInstructionArgs$1 = {
    params: VerifyParams$1;
};
/**
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare const verifyStruct$1: beet.BeetArgsStruct<VerifyInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _verify_ instruction
 *
 * @property [**signer**] receiveLibrary
 * @property [] receiveLibraryConfig
 * @property [] defaultReceiveLibraryConfig
 * @property [_writable_] nonce
 * @property [_writable_] pendingInboundNonce
 * @property [_writable_] payloadHash
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Verify
 * @category generated
 */
type VerifyInstructionAccounts$1 = {
    receiveLibrary: web3.PublicKey;
    receiveLibraryConfig: web3.PublicKey;
    defaultReceiveLibraryConfig: web3.PublicKey;
    nonce: web3.PublicKey;
    pendingInboundNonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const verifyInstructionDiscriminator$1: number[];
/**
 * Creates a _Verify_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare function createVerifyInstruction$1(accounts: VerifyInstructionAccounts$1, args: VerifyInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Verify_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare function createVerifyInstructionAccounts$1(accounts: VerifyInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawRentParams$1 = {
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawRentParamsBeet$1: beet.BeetArgsStruct<WithdrawRentParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
type WithdrawRentInstructionArgs$1 = {
    params: WithdrawRentParams$1;
};
/**
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare const withdrawRentStruct$1: beet.BeetArgsStruct<WithdrawRentInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _withdrawRent_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] endpoint
 * @property [_writable_] receiver
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
type WithdrawRentInstructionAccounts$1 = {
    admin: web3.PublicKey;
    endpoint: web3.PublicKey;
    receiver: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const withdrawRentInstructionDiscriminator$1: number[];
/**
 * Creates a _WithdrawRent_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare function createWithdrawRentInstruction$1(accounts: WithdrawRentInstructionAccounts$1, args: WithdrawRentInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _WithdrawRent_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare function createWithdrawRentInstructionAccounts$1(accounts: WithdrawRentInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

type index$q_BurnInstructionAccounts = BurnInstructionAccounts;
type index$q_BurnInstructionArgs = BurnInstructionArgs;
type index$q_ClearComposeInstructionAccounts = ClearComposeInstructionAccounts;
type index$q_ClearComposeInstructionArgs = ClearComposeInstructionArgs;
type index$q_ClearInstructionAccounts = ClearInstructionAccounts;
type index$q_ClearInstructionArgs = ClearInstructionArgs;
type index$q_InitDefaultReceiveLibraryInstructionAccounts = InitDefaultReceiveLibraryInstructionAccounts;
type index$q_InitDefaultReceiveLibraryInstructionArgs = InitDefaultReceiveLibraryInstructionArgs;
type index$q_InitDefaultSendLibraryInstructionAccounts = InitDefaultSendLibraryInstructionAccounts;
type index$q_InitDefaultSendLibraryInstructionArgs = InitDefaultSendLibraryInstructionArgs;
type index$q_InitEndpointInstructionAccounts = InitEndpointInstructionAccounts;
type index$q_InitEndpointInstructionArgs = InitEndpointInstructionArgs;
type index$q_InitNonceInstructionAccounts = InitNonceInstructionAccounts;
type index$q_InitNonceInstructionArgs = InitNonceInstructionArgs;
type index$q_InitReceiveLibraryInstructionAccounts = InitReceiveLibraryInstructionAccounts;
type index$q_InitReceiveLibraryInstructionArgs = InitReceiveLibraryInstructionArgs;
type index$q_InitSendLibraryInstructionAccounts = InitSendLibraryInstructionAccounts;
type index$q_InitSendLibraryInstructionArgs = InitSendLibraryInstructionArgs;
type index$q_LzComposeAlertInstructionAccounts = LzComposeAlertInstructionAccounts;
type index$q_LzComposeAlertInstructionArgs = LzComposeAlertInstructionArgs;
type index$q_LzReceiveAlertInstructionAccounts = LzReceiveAlertInstructionAccounts;
type index$q_LzReceiveAlertInstructionArgs = LzReceiveAlertInstructionArgs;
type index$q_NilifyInstructionAccounts = NilifyInstructionAccounts;
type index$q_NilifyInstructionArgs = NilifyInstructionArgs;
type index$q_RegisterLibraryInstructionAccounts = RegisterLibraryInstructionAccounts;
type index$q_RegisterLibraryInstructionArgs = RegisterLibraryInstructionArgs;
type index$q_RegisterOappInstructionAccounts = RegisterOappInstructionAccounts;
type index$q_RegisterOappInstructionArgs = RegisterOappInstructionArgs;
type index$q_SendComposeInstructionAccounts = SendComposeInstructionAccounts;
type index$q_SendComposeInstructionArgs = SendComposeInstructionArgs;
type index$q_SetDefaultReceiveLibraryInstructionAccounts = SetDefaultReceiveLibraryInstructionAccounts;
type index$q_SetDefaultReceiveLibraryInstructionArgs = SetDefaultReceiveLibraryInstructionArgs;
type index$q_SetDefaultReceiveLibraryTimeoutInstructionAccounts = SetDefaultReceiveLibraryTimeoutInstructionAccounts;
type index$q_SetDefaultReceiveLibraryTimeoutInstructionArgs = SetDefaultReceiveLibraryTimeoutInstructionArgs;
type index$q_SetDefaultSendLibraryInstructionAccounts = SetDefaultSendLibraryInstructionAccounts;
type index$q_SetDefaultSendLibraryInstructionArgs = SetDefaultSendLibraryInstructionArgs;
type index$q_SetLzTokenInstructionAccounts = SetLzTokenInstructionAccounts;
type index$q_SetLzTokenInstructionArgs = SetLzTokenInstructionArgs;
type index$q_SetReceiveLibraryInstructionAccounts = SetReceiveLibraryInstructionAccounts;
type index$q_SetReceiveLibraryInstructionArgs = SetReceiveLibraryInstructionArgs;
type index$q_SetReceiveLibraryTimeoutInstructionAccounts = SetReceiveLibraryTimeoutInstructionAccounts;
type index$q_SetReceiveLibraryTimeoutInstructionArgs = SetReceiveLibraryTimeoutInstructionArgs;
type index$q_SetSendLibraryInstructionAccounts = SetSendLibraryInstructionAccounts;
type index$q_SetSendLibraryInstructionArgs = SetSendLibraryInstructionArgs;
type index$q_SkipInstructionAccounts = SkipInstructionAccounts;
type index$q_SkipInstructionArgs = SkipInstructionArgs;
declare const index$q_burnInstructionDiscriminator: typeof burnInstructionDiscriminator;
declare const index$q_burnStruct: typeof burnStruct;
declare const index$q_clearComposeInstructionDiscriminator: typeof clearComposeInstructionDiscriminator;
declare const index$q_clearComposeStruct: typeof clearComposeStruct;
declare const index$q_clearInstructionDiscriminator: typeof clearInstructionDiscriminator;
declare const index$q_clearStruct: typeof clearStruct;
declare const index$q_createBurnInstruction: typeof createBurnInstruction;
declare const index$q_createBurnInstructionAccounts: typeof createBurnInstructionAccounts;
declare const index$q_createClearComposeInstruction: typeof createClearComposeInstruction;
declare const index$q_createClearComposeInstructionAccounts: typeof createClearComposeInstructionAccounts;
declare const index$q_createClearInstruction: typeof createClearInstruction;
declare const index$q_createClearInstructionAccounts: typeof createClearInstructionAccounts;
declare const index$q_createInitDefaultReceiveLibraryInstruction: typeof createInitDefaultReceiveLibraryInstruction;
declare const index$q_createInitDefaultReceiveLibraryInstructionAccounts: typeof createInitDefaultReceiveLibraryInstructionAccounts;
declare const index$q_createInitDefaultSendLibraryInstruction: typeof createInitDefaultSendLibraryInstruction;
declare const index$q_createInitDefaultSendLibraryInstructionAccounts: typeof createInitDefaultSendLibraryInstructionAccounts;
declare const index$q_createInitEndpointInstruction: typeof createInitEndpointInstruction;
declare const index$q_createInitEndpointInstructionAccounts: typeof createInitEndpointInstructionAccounts;
declare const index$q_createInitNonceInstruction: typeof createInitNonceInstruction;
declare const index$q_createInitNonceInstructionAccounts: typeof createInitNonceInstructionAccounts;
declare const index$q_createInitReceiveLibraryInstruction: typeof createInitReceiveLibraryInstruction;
declare const index$q_createInitReceiveLibraryInstructionAccounts: typeof createInitReceiveLibraryInstructionAccounts;
declare const index$q_createInitSendLibraryInstruction: typeof createInitSendLibraryInstruction;
declare const index$q_createInitSendLibraryInstructionAccounts: typeof createInitSendLibraryInstructionAccounts;
declare const index$q_createLzComposeAlertInstruction: typeof createLzComposeAlertInstruction;
declare const index$q_createLzComposeAlertInstructionAccounts: typeof createLzComposeAlertInstructionAccounts;
declare const index$q_createLzReceiveAlertInstruction: typeof createLzReceiveAlertInstruction;
declare const index$q_createLzReceiveAlertInstructionAccounts: typeof createLzReceiveAlertInstructionAccounts;
declare const index$q_createNilifyInstruction: typeof createNilifyInstruction;
declare const index$q_createNilifyInstructionAccounts: typeof createNilifyInstructionAccounts;
declare const index$q_createRegisterLibraryInstruction: typeof createRegisterLibraryInstruction;
declare const index$q_createRegisterLibraryInstructionAccounts: typeof createRegisterLibraryInstructionAccounts;
declare const index$q_createRegisterOappInstruction: typeof createRegisterOappInstruction;
declare const index$q_createRegisterOappInstructionAccounts: typeof createRegisterOappInstructionAccounts;
declare const index$q_createSendComposeInstruction: typeof createSendComposeInstruction;
declare const index$q_createSendComposeInstructionAccounts: typeof createSendComposeInstructionAccounts;
declare const index$q_createSetDefaultReceiveLibraryInstruction: typeof createSetDefaultReceiveLibraryInstruction;
declare const index$q_createSetDefaultReceiveLibraryInstructionAccounts: typeof createSetDefaultReceiveLibraryInstructionAccounts;
declare const index$q_createSetDefaultReceiveLibraryTimeoutInstruction: typeof createSetDefaultReceiveLibraryTimeoutInstruction;
declare const index$q_createSetDefaultReceiveLibraryTimeoutInstructionAccounts: typeof createSetDefaultReceiveLibraryTimeoutInstructionAccounts;
declare const index$q_createSetDefaultSendLibraryInstruction: typeof createSetDefaultSendLibraryInstruction;
declare const index$q_createSetDefaultSendLibraryInstructionAccounts: typeof createSetDefaultSendLibraryInstructionAccounts;
declare const index$q_createSetLzTokenInstruction: typeof createSetLzTokenInstruction;
declare const index$q_createSetLzTokenInstructionAccounts: typeof createSetLzTokenInstructionAccounts;
declare const index$q_createSetReceiveLibraryInstruction: typeof createSetReceiveLibraryInstruction;
declare const index$q_createSetReceiveLibraryInstructionAccounts: typeof createSetReceiveLibraryInstructionAccounts;
declare const index$q_createSetReceiveLibraryTimeoutInstruction: typeof createSetReceiveLibraryTimeoutInstruction;
declare const index$q_createSetReceiveLibraryTimeoutInstructionAccounts: typeof createSetReceiveLibraryTimeoutInstructionAccounts;
declare const index$q_createSetSendLibraryInstruction: typeof createSetSendLibraryInstruction;
declare const index$q_createSetSendLibraryInstructionAccounts: typeof createSetSendLibraryInstructionAccounts;
declare const index$q_createSkipInstruction: typeof createSkipInstruction;
declare const index$q_createSkipInstructionAccounts: typeof createSkipInstructionAccounts;
declare const index$q_initDefaultReceiveLibraryInstructionDiscriminator: typeof initDefaultReceiveLibraryInstructionDiscriminator;
declare const index$q_initDefaultReceiveLibraryStruct: typeof initDefaultReceiveLibraryStruct;
declare const index$q_initDefaultSendLibraryInstructionDiscriminator: typeof initDefaultSendLibraryInstructionDiscriminator;
declare const index$q_initDefaultSendLibraryStruct: typeof initDefaultSendLibraryStruct;
declare const index$q_initEndpointInstructionDiscriminator: typeof initEndpointInstructionDiscriminator;
declare const index$q_initEndpointStruct: typeof initEndpointStruct;
declare const index$q_initNonceInstructionDiscriminator: typeof initNonceInstructionDiscriminator;
declare const index$q_initNonceStruct: typeof initNonceStruct;
declare const index$q_initReceiveLibraryInstructionDiscriminator: typeof initReceiveLibraryInstructionDiscriminator;
declare const index$q_initReceiveLibraryStruct: typeof initReceiveLibraryStruct;
declare const index$q_initSendLibraryInstructionDiscriminator: typeof initSendLibraryInstructionDiscriminator;
declare const index$q_initSendLibraryStruct: typeof initSendLibraryStruct;
declare const index$q_lzComposeAlertInstructionDiscriminator: typeof lzComposeAlertInstructionDiscriminator;
declare const index$q_lzComposeAlertStruct: typeof lzComposeAlertStruct;
declare const index$q_lzReceiveAlertInstructionDiscriminator: typeof lzReceiveAlertInstructionDiscriminator;
declare const index$q_lzReceiveAlertStruct: typeof lzReceiveAlertStruct;
declare const index$q_nilifyInstructionDiscriminator: typeof nilifyInstructionDiscriminator;
declare const index$q_nilifyStruct: typeof nilifyStruct;
declare const index$q_registerLibraryInstructionDiscriminator: typeof registerLibraryInstructionDiscriminator;
declare const index$q_registerLibraryStruct: typeof registerLibraryStruct;
declare const index$q_registerOappInstructionDiscriminator: typeof registerOappInstructionDiscriminator;
declare const index$q_registerOappStruct: typeof registerOappStruct;
declare const index$q_sendComposeInstructionDiscriminator: typeof sendComposeInstructionDiscriminator;
declare const index$q_sendComposeStruct: typeof sendComposeStruct;
declare const index$q_setDefaultReceiveLibraryInstructionDiscriminator: typeof setDefaultReceiveLibraryInstructionDiscriminator;
declare const index$q_setDefaultReceiveLibraryStruct: typeof setDefaultReceiveLibraryStruct;
declare const index$q_setDefaultReceiveLibraryTimeoutInstructionDiscriminator: typeof setDefaultReceiveLibraryTimeoutInstructionDiscriminator;
declare const index$q_setDefaultReceiveLibraryTimeoutStruct: typeof setDefaultReceiveLibraryTimeoutStruct;
declare const index$q_setDefaultSendLibraryInstructionDiscriminator: typeof setDefaultSendLibraryInstructionDiscriminator;
declare const index$q_setDefaultSendLibraryStruct: typeof setDefaultSendLibraryStruct;
declare const index$q_setLzTokenInstructionDiscriminator: typeof setLzTokenInstructionDiscriminator;
declare const index$q_setLzTokenStruct: typeof setLzTokenStruct;
declare const index$q_setReceiveLibraryInstructionDiscriminator: typeof setReceiveLibraryInstructionDiscriminator;
declare const index$q_setReceiveLibraryStruct: typeof setReceiveLibraryStruct;
declare const index$q_setReceiveLibraryTimeoutInstructionDiscriminator: typeof setReceiveLibraryTimeoutInstructionDiscriminator;
declare const index$q_setReceiveLibraryTimeoutStruct: typeof setReceiveLibraryTimeoutStruct;
declare const index$q_setSendLibraryInstructionDiscriminator: typeof setSendLibraryInstructionDiscriminator;
declare const index$q_setSendLibraryStruct: typeof setSendLibraryStruct;
declare const index$q_skipInstructionDiscriminator: typeof skipInstructionDiscriminator;
declare const index$q_skipStruct: typeof skipStruct;
declare namespace index$q {
  export { type index$q_BurnInstructionAccounts as BurnInstructionAccounts, type index$q_BurnInstructionArgs as BurnInstructionArgs, type index$q_ClearComposeInstructionAccounts as ClearComposeInstructionAccounts, type index$q_ClearComposeInstructionArgs as ClearComposeInstructionArgs, type index$q_ClearInstructionAccounts as ClearInstructionAccounts, type index$q_ClearInstructionArgs as ClearInstructionArgs, type InitConfigInstructionAccounts$2 as InitConfigInstructionAccounts, type InitConfigInstructionArgs$2 as InitConfigInstructionArgs, type index$q_InitDefaultReceiveLibraryInstructionAccounts as InitDefaultReceiveLibraryInstructionAccounts, type index$q_InitDefaultReceiveLibraryInstructionArgs as InitDefaultReceiveLibraryInstructionArgs, type index$q_InitDefaultSendLibraryInstructionAccounts as InitDefaultSendLibraryInstructionAccounts, type index$q_InitDefaultSendLibraryInstructionArgs as InitDefaultSendLibraryInstructionArgs, type index$q_InitEndpointInstructionAccounts as InitEndpointInstructionAccounts, type index$q_InitEndpointInstructionArgs as InitEndpointInstructionArgs, type index$q_InitNonceInstructionAccounts as InitNonceInstructionAccounts, type index$q_InitNonceInstructionArgs as InitNonceInstructionArgs, type index$q_InitReceiveLibraryInstructionAccounts as InitReceiveLibraryInstructionAccounts, type index$q_InitReceiveLibraryInstructionArgs as InitReceiveLibraryInstructionArgs, type index$q_InitSendLibraryInstructionAccounts as InitSendLibraryInstructionAccounts, type index$q_InitSendLibraryInstructionArgs as InitSendLibraryInstructionArgs, type InitVerifyInstructionAccounts$1 as InitVerifyInstructionAccounts, type InitVerifyInstructionArgs$1 as InitVerifyInstructionArgs, type index$q_LzComposeAlertInstructionAccounts as LzComposeAlertInstructionAccounts, type index$q_LzComposeAlertInstructionArgs as LzComposeAlertInstructionArgs, type index$q_LzReceiveAlertInstructionAccounts as LzReceiveAlertInstructionAccounts, type index$q_LzReceiveAlertInstructionArgs as LzReceiveAlertInstructionArgs, type index$q_NilifyInstructionAccounts as NilifyInstructionAccounts, type index$q_NilifyInstructionArgs as NilifyInstructionArgs, type QuoteInstructionAccounts$3 as QuoteInstructionAccounts, type QuoteInstructionArgs$3 as QuoteInstructionArgs, type index$q_RegisterLibraryInstructionAccounts as RegisterLibraryInstructionAccounts, type index$q_RegisterLibraryInstructionArgs as RegisterLibraryInstructionArgs, type index$q_RegisterOappInstructionAccounts as RegisterOappInstructionAccounts, type index$q_RegisterOappInstructionArgs as RegisterOappInstructionArgs, type index$q_SendComposeInstructionAccounts as SendComposeInstructionAccounts, type index$q_SendComposeInstructionArgs as SendComposeInstructionArgs, type SendInstructionAccounts$3 as SendInstructionAccounts, type SendInstructionArgs$3 as SendInstructionArgs, type SetConfigInstructionAccounts$3 as SetConfigInstructionAccounts, type SetConfigInstructionArgs$3 as SetConfigInstructionArgs, type index$q_SetDefaultReceiveLibraryInstructionAccounts as SetDefaultReceiveLibraryInstructionAccounts, type index$q_SetDefaultReceiveLibraryInstructionArgs as SetDefaultReceiveLibraryInstructionArgs, type index$q_SetDefaultReceiveLibraryTimeoutInstructionAccounts as SetDefaultReceiveLibraryTimeoutInstructionAccounts, type index$q_SetDefaultReceiveLibraryTimeoutInstructionArgs as SetDefaultReceiveLibraryTimeoutInstructionArgs, type index$q_SetDefaultSendLibraryInstructionAccounts as SetDefaultSendLibraryInstructionAccounts, type index$q_SetDefaultSendLibraryInstructionArgs as SetDefaultSendLibraryInstructionArgs, type SetDelegateInstructionAccounts$1 as SetDelegateInstructionAccounts, type SetDelegateInstructionArgs$1 as SetDelegateInstructionArgs, type index$q_SetLzTokenInstructionAccounts as SetLzTokenInstructionAccounts, type index$q_SetLzTokenInstructionArgs as SetLzTokenInstructionArgs, type index$q_SetReceiveLibraryInstructionAccounts as SetReceiveLibraryInstructionAccounts, type index$q_SetReceiveLibraryInstructionArgs as SetReceiveLibraryInstructionArgs, type index$q_SetReceiveLibraryTimeoutInstructionAccounts as SetReceiveLibraryTimeoutInstructionAccounts, type index$q_SetReceiveLibraryTimeoutInstructionArgs as SetReceiveLibraryTimeoutInstructionArgs, type index$q_SetSendLibraryInstructionAccounts as SetSendLibraryInstructionAccounts, type index$q_SetSendLibraryInstructionArgs as SetSendLibraryInstructionArgs, type index$q_SkipInstructionAccounts as SkipInstructionAccounts, type index$q_SkipInstructionArgs as SkipInstructionArgs, type TransferAdminInstructionAccounts$4 as TransferAdminInstructionAccounts, type TransferAdminInstructionArgs$4 as TransferAdminInstructionArgs, type VerifyInstructionAccounts$1 as VerifyInstructionAccounts, type VerifyInstructionArgs$1 as VerifyInstructionArgs, type WithdrawRentInstructionAccounts$1 as WithdrawRentInstructionAccounts, type WithdrawRentInstructionArgs$1 as WithdrawRentInstructionArgs, index$q_burnInstructionDiscriminator as burnInstructionDiscriminator, index$q_burnStruct as burnStruct, index$q_clearComposeInstructionDiscriminator as clearComposeInstructionDiscriminator, index$q_clearComposeStruct as clearComposeStruct, index$q_clearInstructionDiscriminator as clearInstructionDiscriminator, index$q_clearStruct as clearStruct, index$q_createBurnInstruction as createBurnInstruction, index$q_createBurnInstructionAccounts as createBurnInstructionAccounts, index$q_createClearComposeInstruction as createClearComposeInstruction, index$q_createClearComposeInstructionAccounts as createClearComposeInstructionAccounts, index$q_createClearInstruction as createClearInstruction, index$q_createClearInstructionAccounts as createClearInstructionAccounts, createInitConfigInstruction$2 as createInitConfigInstruction, createInitConfigInstructionAccounts$2 as createInitConfigInstructionAccounts, index$q_createInitDefaultReceiveLibraryInstruction as createInitDefaultReceiveLibraryInstruction, index$q_createInitDefaultReceiveLibraryInstructionAccounts as createInitDefaultReceiveLibraryInstructionAccounts, index$q_createInitDefaultSendLibraryInstruction as createInitDefaultSendLibraryInstruction, index$q_createInitDefaultSendLibraryInstructionAccounts as createInitDefaultSendLibraryInstructionAccounts, index$q_createInitEndpointInstruction as createInitEndpointInstruction, index$q_createInitEndpointInstructionAccounts as createInitEndpointInstructionAccounts, index$q_createInitNonceInstruction as createInitNonceInstruction, index$q_createInitNonceInstructionAccounts as createInitNonceInstructionAccounts, index$q_createInitReceiveLibraryInstruction as createInitReceiveLibraryInstruction, index$q_createInitReceiveLibraryInstructionAccounts as createInitReceiveLibraryInstructionAccounts, index$q_createInitSendLibraryInstruction as createInitSendLibraryInstruction, index$q_createInitSendLibraryInstructionAccounts as createInitSendLibraryInstructionAccounts, createInitVerifyInstruction$1 as createInitVerifyInstruction, createInitVerifyInstructionAccounts$1 as createInitVerifyInstructionAccounts, index$q_createLzComposeAlertInstruction as createLzComposeAlertInstruction, index$q_createLzComposeAlertInstructionAccounts as createLzComposeAlertInstructionAccounts, index$q_createLzReceiveAlertInstruction as createLzReceiveAlertInstruction, index$q_createLzReceiveAlertInstructionAccounts as createLzReceiveAlertInstructionAccounts, index$q_createNilifyInstruction as createNilifyInstruction, index$q_createNilifyInstructionAccounts as createNilifyInstructionAccounts, createQuoteInstruction$3 as createQuoteInstruction, createQuoteInstructionAccounts$3 as createQuoteInstructionAccounts, index$q_createRegisterLibraryInstruction as createRegisterLibraryInstruction, index$q_createRegisterLibraryInstructionAccounts as createRegisterLibraryInstructionAccounts, index$q_createRegisterOappInstruction as createRegisterOappInstruction, index$q_createRegisterOappInstructionAccounts as createRegisterOappInstructionAccounts, index$q_createSendComposeInstruction as createSendComposeInstruction, index$q_createSendComposeInstructionAccounts as createSendComposeInstructionAccounts, createSendInstruction$3 as createSendInstruction, createSendInstructionAccounts$3 as createSendInstructionAccounts, createSetConfigInstruction$3 as createSetConfigInstruction, createSetConfigInstructionAccounts$3 as createSetConfigInstructionAccounts, index$q_createSetDefaultReceiveLibraryInstruction as createSetDefaultReceiveLibraryInstruction, index$q_createSetDefaultReceiveLibraryInstructionAccounts as createSetDefaultReceiveLibraryInstructionAccounts, index$q_createSetDefaultReceiveLibraryTimeoutInstruction as createSetDefaultReceiveLibraryTimeoutInstruction, index$q_createSetDefaultReceiveLibraryTimeoutInstructionAccounts as createSetDefaultReceiveLibraryTimeoutInstructionAccounts, index$q_createSetDefaultSendLibraryInstruction as createSetDefaultSendLibraryInstruction, index$q_createSetDefaultSendLibraryInstructionAccounts as createSetDefaultSendLibraryInstructionAccounts, createSetDelegateInstruction$1 as createSetDelegateInstruction, createSetDelegateInstructionAccounts$1 as createSetDelegateInstructionAccounts, index$q_createSetLzTokenInstruction as createSetLzTokenInstruction, index$q_createSetLzTokenInstructionAccounts as createSetLzTokenInstructionAccounts, index$q_createSetReceiveLibraryInstruction as createSetReceiveLibraryInstruction, index$q_createSetReceiveLibraryInstructionAccounts as createSetReceiveLibraryInstructionAccounts, index$q_createSetReceiveLibraryTimeoutInstruction as createSetReceiveLibraryTimeoutInstruction, index$q_createSetReceiveLibraryTimeoutInstructionAccounts as createSetReceiveLibraryTimeoutInstructionAccounts, index$q_createSetSendLibraryInstruction as createSetSendLibraryInstruction, index$q_createSetSendLibraryInstructionAccounts as createSetSendLibraryInstructionAccounts, index$q_createSkipInstruction as createSkipInstruction, index$q_createSkipInstructionAccounts as createSkipInstructionAccounts, createTransferAdminInstruction$4 as createTransferAdminInstruction, createTransferAdminInstructionAccounts$4 as createTransferAdminInstructionAccounts, createVerifyInstruction$1 as createVerifyInstruction, createVerifyInstructionAccounts$1 as createVerifyInstructionAccounts, createWithdrawRentInstruction$1 as createWithdrawRentInstruction, createWithdrawRentInstructionAccounts$1 as createWithdrawRentInstructionAccounts, initConfigInstructionDiscriminator$2 as initConfigInstructionDiscriminator, initConfigStruct$2 as initConfigStruct, index$q_initDefaultReceiveLibraryInstructionDiscriminator as initDefaultReceiveLibraryInstructionDiscriminator, index$q_initDefaultReceiveLibraryStruct as initDefaultReceiveLibraryStruct, index$q_initDefaultSendLibraryInstructionDiscriminator as initDefaultSendLibraryInstructionDiscriminator, index$q_initDefaultSendLibraryStruct as initDefaultSendLibraryStruct, index$q_initEndpointInstructionDiscriminator as initEndpointInstructionDiscriminator, index$q_initEndpointStruct as initEndpointStruct, index$q_initNonceInstructionDiscriminator as initNonceInstructionDiscriminator, index$q_initNonceStruct as initNonceStruct, index$q_initReceiveLibraryInstructionDiscriminator as initReceiveLibraryInstructionDiscriminator, index$q_initReceiveLibraryStruct as initReceiveLibraryStruct, index$q_initSendLibraryInstructionDiscriminator as initSendLibraryInstructionDiscriminator, index$q_initSendLibraryStruct as initSendLibraryStruct, initVerifyInstructionDiscriminator$1 as initVerifyInstructionDiscriminator, initVerifyStruct$1 as initVerifyStruct, index$q_lzComposeAlertInstructionDiscriminator as lzComposeAlertInstructionDiscriminator, index$q_lzComposeAlertStruct as lzComposeAlertStruct, index$q_lzReceiveAlertInstructionDiscriminator as lzReceiveAlertInstructionDiscriminator, index$q_lzReceiveAlertStruct as lzReceiveAlertStruct, index$q_nilifyInstructionDiscriminator as nilifyInstructionDiscriminator, index$q_nilifyStruct as nilifyStruct, quoteInstructionDiscriminator$3 as quoteInstructionDiscriminator, quoteStruct$3 as quoteStruct, index$q_registerLibraryInstructionDiscriminator as registerLibraryInstructionDiscriminator, index$q_registerLibraryStruct as registerLibraryStruct, index$q_registerOappInstructionDiscriminator as registerOappInstructionDiscriminator, index$q_registerOappStruct as registerOappStruct, index$q_sendComposeInstructionDiscriminator as sendComposeInstructionDiscriminator, index$q_sendComposeStruct as sendComposeStruct, sendInstructionDiscriminator$3 as sendInstructionDiscriminator, sendStruct$3 as sendStruct, setConfigInstructionDiscriminator$3 as setConfigInstructionDiscriminator, setConfigStruct$3 as setConfigStruct, index$q_setDefaultReceiveLibraryInstructionDiscriminator as setDefaultReceiveLibraryInstructionDiscriminator, index$q_setDefaultReceiveLibraryStruct as setDefaultReceiveLibraryStruct, index$q_setDefaultReceiveLibraryTimeoutInstructionDiscriminator as setDefaultReceiveLibraryTimeoutInstructionDiscriminator, index$q_setDefaultReceiveLibraryTimeoutStruct as setDefaultReceiveLibraryTimeoutStruct, index$q_setDefaultSendLibraryInstructionDiscriminator as setDefaultSendLibraryInstructionDiscriminator, index$q_setDefaultSendLibraryStruct as setDefaultSendLibraryStruct, setDelegateInstructionDiscriminator$1 as setDelegateInstructionDiscriminator, setDelegateStruct$1 as setDelegateStruct, index$q_setLzTokenInstructionDiscriminator as setLzTokenInstructionDiscriminator, index$q_setLzTokenStruct as setLzTokenStruct, index$q_setReceiveLibraryInstructionDiscriminator as setReceiveLibraryInstructionDiscriminator, index$q_setReceiveLibraryStruct as setReceiveLibraryStruct, index$q_setReceiveLibraryTimeoutInstructionDiscriminator as setReceiveLibraryTimeoutInstructionDiscriminator, index$q_setReceiveLibraryTimeoutStruct as setReceiveLibraryTimeoutStruct, index$q_setSendLibraryInstructionDiscriminator as setSendLibraryInstructionDiscriminator, index$q_setSendLibraryStruct as setSendLibraryStruct, index$q_skipInstructionDiscriminator as skipInstructionDiscriminator, index$q_skipStruct as skipStruct, transferAdminInstructionDiscriminator$4 as transferAdminInstructionDiscriminator, transferAdminStruct$4 as transferAdminStruct, verifyInstructionDiscriminator$1 as verifyInstructionDiscriminator, verifyStruct$1 as verifyStruct, withdrawRentInstructionDiscriminator$1 as withdrawRentInstructionDiscriminator, withdrawRentStruct$1 as withdrawRentStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingFee$3 = {
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingFeeBeet$3: beet.BeetArgsStruct<MessagingFee$3>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingReceipt$1 = {
    guid: number[];
    nonce: beet.bignum;
    fee: MessagingFee$3;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingReceiptBeet$1: beet.BeetArgsStruct<MessagingReceipt$1>;

type index$p_BurnParams = BurnParams;
type index$p_ClearComposeParams = ClearComposeParams;
type index$p_ClearParams = ClearParams;
type index$p_InitDefaultReceiveLibraryParams = InitDefaultReceiveLibraryParams;
type index$p_InitDefaultSendLibraryParams = InitDefaultSendLibraryParams;
type index$p_InitEndpointParams = InitEndpointParams;
type index$p_InitNonceParams = InitNonceParams;
type index$p_InitReceiveLibraryParams = InitReceiveLibraryParams;
type index$p_InitSendLibraryParams = InitSendLibraryParams;
type index$p_LzComposeAlertParams = LzComposeAlertParams;
type index$p_LzReceiveAlertParams = LzReceiveAlertParams;
type index$p_MessageLibType = MessageLibType;
declare const index$p_MessageLibType: typeof MessageLibType;
type index$p_NilifyParams = NilifyParams;
type index$p_ReceiveLibraryTimeout = ReceiveLibraryTimeout;
type index$p_RegisterLibraryParams = RegisterLibraryParams;
type index$p_RegisterOAppParams = RegisterOAppParams;
type index$p_SendComposeParams = SendComposeParams;
type index$p_SetDefaultReceiveLibraryParams = SetDefaultReceiveLibraryParams;
type index$p_SetDefaultReceiveLibraryTimeoutParams = SetDefaultReceiveLibraryTimeoutParams;
type index$p_SetDefaultSendLibraryParams = SetDefaultSendLibraryParams;
type index$p_SetLzTokenParams = SetLzTokenParams;
type index$p_SetReceiveLibraryParams = SetReceiveLibraryParams;
type index$p_SetReceiveLibraryTimeoutParams = SetReceiveLibraryTimeoutParams;
type index$p_SetSendLibraryParams = SetSendLibraryParams;
type index$p_SkipParams = SkipParams;
declare const index$p_burnParamsBeet: typeof burnParamsBeet;
declare const index$p_clearComposeParamsBeet: typeof clearComposeParamsBeet;
declare const index$p_clearParamsBeet: typeof clearParamsBeet;
declare const index$p_initDefaultReceiveLibraryParamsBeet: typeof initDefaultReceiveLibraryParamsBeet;
declare const index$p_initDefaultSendLibraryParamsBeet: typeof initDefaultSendLibraryParamsBeet;
declare const index$p_initEndpointParamsBeet: typeof initEndpointParamsBeet;
declare const index$p_initNonceParamsBeet: typeof initNonceParamsBeet;
declare const index$p_initReceiveLibraryParamsBeet: typeof initReceiveLibraryParamsBeet;
declare const index$p_initSendLibraryParamsBeet: typeof initSendLibraryParamsBeet;
declare const index$p_lzComposeAlertParamsBeet: typeof lzComposeAlertParamsBeet;
declare const index$p_lzReceiveAlertParamsBeet: typeof lzReceiveAlertParamsBeet;
declare const index$p_messageLibTypeBeet: typeof messageLibTypeBeet;
declare const index$p_nilifyParamsBeet: typeof nilifyParamsBeet;
declare const index$p_receiveLibraryTimeoutBeet: typeof receiveLibraryTimeoutBeet;
declare const index$p_registerLibraryParamsBeet: typeof registerLibraryParamsBeet;
declare const index$p_registerOAppParamsBeet: typeof registerOAppParamsBeet;
declare const index$p_sendComposeParamsBeet: typeof sendComposeParamsBeet;
declare const index$p_setDefaultReceiveLibraryParamsBeet: typeof setDefaultReceiveLibraryParamsBeet;
declare const index$p_setDefaultReceiveLibraryTimeoutParamsBeet: typeof setDefaultReceiveLibraryTimeoutParamsBeet;
declare const index$p_setDefaultSendLibraryParamsBeet: typeof setDefaultSendLibraryParamsBeet;
declare const index$p_setLzTokenParamsBeet: typeof setLzTokenParamsBeet;
declare const index$p_setReceiveLibraryParamsBeet: typeof setReceiveLibraryParamsBeet;
declare const index$p_setReceiveLibraryTimeoutParamsBeet: typeof setReceiveLibraryTimeoutParamsBeet;
declare const index$p_setSendLibraryParamsBeet: typeof setSendLibraryParamsBeet;
declare const index$p_skipParamsBeet: typeof skipParamsBeet;
declare namespace index$p {
  export { type index$p_BurnParams as BurnParams, type index$p_ClearComposeParams as ClearComposeParams, type index$p_ClearParams as ClearParams, type InitConfigParams$2 as InitConfigParams, type index$p_InitDefaultReceiveLibraryParams as InitDefaultReceiveLibraryParams, type index$p_InitDefaultSendLibraryParams as InitDefaultSendLibraryParams, type index$p_InitEndpointParams as InitEndpointParams, type index$p_InitNonceParams as InitNonceParams, type index$p_InitReceiveLibraryParams as InitReceiveLibraryParams, type index$p_InitSendLibraryParams as InitSendLibraryParams, type InitVerifyParams$1 as InitVerifyParams, type index$p_LzComposeAlertParams as LzComposeAlertParams, type index$p_LzReceiveAlertParams as LzReceiveAlertParams, index$p_MessageLibType as MessageLibType, type MessagingFee$3 as MessagingFee, type MessagingReceipt$1 as MessagingReceipt, type index$p_NilifyParams as NilifyParams, type QuoteParams$3 as QuoteParams, type index$p_ReceiveLibraryTimeout as ReceiveLibraryTimeout, type index$p_RegisterLibraryParams as RegisterLibraryParams, type index$p_RegisterOAppParams as RegisterOAppParams, type index$p_SendComposeParams as SendComposeParams, type SendParams$3 as SendParams, type SetConfigParams$3 as SetConfigParams, type index$p_SetDefaultReceiveLibraryParams as SetDefaultReceiveLibraryParams, type index$p_SetDefaultReceiveLibraryTimeoutParams as SetDefaultReceiveLibraryTimeoutParams, type index$p_SetDefaultSendLibraryParams as SetDefaultSendLibraryParams, type SetDelegateParams$1 as SetDelegateParams, type index$p_SetLzTokenParams as SetLzTokenParams, type index$p_SetReceiveLibraryParams as SetReceiveLibraryParams, type index$p_SetReceiveLibraryTimeoutParams as SetReceiveLibraryTimeoutParams, type index$p_SetSendLibraryParams as SetSendLibraryParams, type index$p_SkipParams as SkipParams, type TransferAdminParams$4 as TransferAdminParams, type VerifyParams$1 as VerifyParams, type WithdrawRentParams$1 as WithdrawRentParams, index$p_burnParamsBeet as burnParamsBeet, index$p_clearComposeParamsBeet as clearComposeParamsBeet, index$p_clearParamsBeet as clearParamsBeet, initConfigParamsBeet$2 as initConfigParamsBeet, index$p_initDefaultReceiveLibraryParamsBeet as initDefaultReceiveLibraryParamsBeet, index$p_initDefaultSendLibraryParamsBeet as initDefaultSendLibraryParamsBeet, index$p_initEndpointParamsBeet as initEndpointParamsBeet, index$p_initNonceParamsBeet as initNonceParamsBeet, index$p_initReceiveLibraryParamsBeet as initReceiveLibraryParamsBeet, index$p_initSendLibraryParamsBeet as initSendLibraryParamsBeet, initVerifyParamsBeet$1 as initVerifyParamsBeet, index$p_lzComposeAlertParamsBeet as lzComposeAlertParamsBeet, index$p_lzReceiveAlertParamsBeet as lzReceiveAlertParamsBeet, index$p_messageLibTypeBeet as messageLibTypeBeet, messagingFeeBeet$3 as messagingFeeBeet, messagingReceiptBeet$1 as messagingReceiptBeet, index$p_nilifyParamsBeet as nilifyParamsBeet, quoteParamsBeet$3 as quoteParamsBeet, index$p_receiveLibraryTimeoutBeet as receiveLibraryTimeoutBeet, index$p_registerLibraryParamsBeet as registerLibraryParamsBeet, index$p_registerOAppParamsBeet as registerOAppParamsBeet, index$p_sendComposeParamsBeet as sendComposeParamsBeet, sendParamsBeet$3 as sendParamsBeet, setConfigParamsBeet$3 as setConfigParamsBeet, index$p_setDefaultReceiveLibraryParamsBeet as setDefaultReceiveLibraryParamsBeet, index$p_setDefaultReceiveLibraryTimeoutParamsBeet as setDefaultReceiveLibraryTimeoutParamsBeet, index$p_setDefaultSendLibraryParamsBeet as setDefaultSendLibraryParamsBeet, setDelegateParamsBeet$1 as setDelegateParamsBeet, index$p_setLzTokenParamsBeet as setLzTokenParamsBeet, index$p_setReceiveLibraryParamsBeet as setReceiveLibraryParamsBeet, index$p_setReceiveLibraryTimeoutParamsBeet as setReceiveLibraryTimeoutParamsBeet, index$p_setSendLibraryParamsBeet as setSendLibraryParamsBeet, index$p_skipParamsBeet as skipParamsBeet, transferAdminParamsBeet$4 as transferAdminParamsBeet, verifyParamsBeet$1 as verifyParamsBeet, withdrawRentParamsBeet$1 as withdrawRentParamsBeet };
}

/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$7: PublicKey;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type AdminTransferredEvent$1 = {
    newAdmin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const adminTransferredEventBeet$1: beet.BeetArgsStruct<AdminTransferredEvent$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ComposeDeliveredEvent = {
    from: web3.PublicKey;
    to: web3.PublicKey;
    guid: number[];
    index: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const composeDeliveredEventBeet: beet.BeetArgsStruct<ComposeDeliveredEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ComposeSentEvent = {
    from: web3.PublicKey;
    to: web3.PublicKey;
    guid: number[];
    index: number;
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const composeSentEventBeet: beet.FixableBeetArgsStruct<ComposeSentEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DefaultReceiveLibrarySetEvent = {
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const defaultReceiveLibrarySetEventBeet: beet.BeetArgsStruct<DefaultReceiveLibrarySetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DefaultReceiveLibraryTimeoutSetEvent = {
    eid: number;
    timeout: beet.COption<ReceiveLibraryTimeout>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const defaultReceiveLibraryTimeoutSetEventBeet: beet.FixableBeetArgsStruct<DefaultReceiveLibraryTimeoutSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DefaultSendLibrarySetEvent = {
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const defaultSendLibrarySetEventBeet: beet.BeetArgsStruct<DefaultSendLibrarySetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DelegateSetEvent = {
    newDelegate: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const delegateSetEventBeet: beet.BeetArgsStruct<DelegateSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InboundNonceSkippedEvent = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const inboundNonceSkippedEventBeet: beet.BeetArgsStruct<InboundNonceSkippedEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LibraryRegisteredEvent = {
    newLib: web3.PublicKey;
    newLibProgram: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const libraryRegisteredEventBeet: beet.BeetArgsStruct<LibraryRegisteredEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzComposeAlertEvent = {
    executor: web3.PublicKey;
    from: web3.PublicKey;
    to: web3.PublicKey;
    guid: number[];
    index: number;
    computeUnits: beet.bignum;
    value: beet.bignum;
    message: Uint8Array;
    extraData: Uint8Array;
    reason: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzComposeAlertEventBeet: beet.FixableBeetArgsStruct<LzComposeAlertEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzReceiveAlertEvent = {
    receiver: web3.PublicKey;
    executor: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    guid: number[];
    computeUnits: beet.bignum;
    value: beet.bignum;
    message: Uint8Array;
    extraData: Uint8Array;
    reason: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzReceiveAlertEventBeet: beet.FixableBeetArgsStruct<LzReceiveAlertEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzTokenSetEvent = {
    token: beet.COption<web3.PublicKey>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzTokenSetEventBeet: beet.FixableBeetArgsStruct<LzTokenSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type OAppRegisteredEvent = {
    oapp: web3.PublicKey;
    delegate: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const oAppRegisteredEventBeet: beet.BeetArgsStruct<OAppRegisteredEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PacketBurntEvent = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetBurntEventBeet: beet.BeetArgsStruct<PacketBurntEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PacketDeliveredEvent = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetDeliveredEventBeet: beet.BeetArgsStruct<PacketDeliveredEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PacketNilifiedEvent = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetNilifiedEventBeet: beet.BeetArgsStruct<PacketNilifiedEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PacketSentEvent = {
    encodedPacket: Uint8Array;
    options: Uint8Array;
    sendLibrary: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetSentEventBeet: beet.FixableBeetArgsStruct<PacketSentEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PacketVerifiedEvent = {
    srcEid: number;
    sender: number[];
    receiver: web3.PublicKey;
    nonce: beet.bignum;
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetVerifiedEventBeet: beet.BeetArgsStruct<PacketVerifiedEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReceiveLibrarySetEvent = {
    receiver: web3.PublicKey;
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const receiveLibrarySetEventBeet: beet.BeetArgsStruct<ReceiveLibrarySetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReceiveLibraryTimeoutSetEvent = {
    receiver: web3.PublicKey;
    eid: number;
    timeout: beet.COption<ReceiveLibraryTimeout>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const receiveLibraryTimeoutSetEventBeet: beet.FixableBeetArgsStruct<ReceiveLibraryTimeoutSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type RentWithdrawnEvent$1 = {
    receiver: web3.PublicKey;
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const rentWithdrawnEventBeet$1: beet.BeetArgsStruct<RentWithdrawnEvent$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendLibrarySetEvent = {
    sender: web3.PublicKey;
    eid: number;
    newLib: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendLibrarySetEventBeet: beet.BeetArgsStruct<SendLibrarySetEvent>;

type index$o_ComposeDeliveredEvent = ComposeDeliveredEvent;
type index$o_ComposeSentEvent = ComposeSentEvent;
type index$o_DefaultReceiveLibrarySetEvent = DefaultReceiveLibrarySetEvent;
type index$o_DefaultReceiveLibraryTimeoutSetEvent = DefaultReceiveLibraryTimeoutSetEvent;
type index$o_DefaultSendLibrarySetEvent = DefaultSendLibrarySetEvent;
type index$o_DelegateSetEvent = DelegateSetEvent;
type index$o_InboundNonceSkippedEvent = InboundNonceSkippedEvent;
type index$o_LibraryRegisteredEvent = LibraryRegisteredEvent;
type index$o_LzComposeAlertEvent = LzComposeAlertEvent;
type index$o_LzReceiveAlertEvent = LzReceiveAlertEvent;
type index$o_LzTokenSetEvent = LzTokenSetEvent;
type index$o_OAppRegisteredEvent = OAppRegisteredEvent;
type index$o_PacketBurntEvent = PacketBurntEvent;
type index$o_PacketDeliveredEvent = PacketDeliveredEvent;
type index$o_PacketNilifiedEvent = PacketNilifiedEvent;
type index$o_PacketSentEvent = PacketSentEvent;
type index$o_PacketVerifiedEvent = PacketVerifiedEvent;
type index$o_ReceiveLibrarySetEvent = ReceiveLibrarySetEvent;
type index$o_ReceiveLibraryTimeoutSetEvent = ReceiveLibraryTimeoutSetEvent;
type index$o_SendLibrarySetEvent = SendLibrarySetEvent;
declare const index$o_composeDeliveredEventBeet: typeof composeDeliveredEventBeet;
declare const index$o_composeSentEventBeet: typeof composeSentEventBeet;
declare const index$o_defaultReceiveLibrarySetEventBeet: typeof defaultReceiveLibrarySetEventBeet;
declare const index$o_defaultReceiveLibraryTimeoutSetEventBeet: typeof defaultReceiveLibraryTimeoutSetEventBeet;
declare const index$o_defaultSendLibrarySetEventBeet: typeof defaultSendLibrarySetEventBeet;
declare const index$o_delegateSetEventBeet: typeof delegateSetEventBeet;
declare const index$o_inboundNonceSkippedEventBeet: typeof inboundNonceSkippedEventBeet;
declare const index$o_libraryRegisteredEventBeet: typeof libraryRegisteredEventBeet;
declare const index$o_lzComposeAlertEventBeet: typeof lzComposeAlertEventBeet;
declare const index$o_lzReceiveAlertEventBeet: typeof lzReceiveAlertEventBeet;
declare const index$o_lzTokenSetEventBeet: typeof lzTokenSetEventBeet;
declare const index$o_oAppRegisteredEventBeet: typeof oAppRegisteredEventBeet;
declare const index$o_packetBurntEventBeet: typeof packetBurntEventBeet;
declare const index$o_packetDeliveredEventBeet: typeof packetDeliveredEventBeet;
declare const index$o_packetNilifiedEventBeet: typeof packetNilifiedEventBeet;
declare const index$o_packetSentEventBeet: typeof packetSentEventBeet;
declare const index$o_packetVerifiedEventBeet: typeof packetVerifiedEventBeet;
declare const index$o_receiveLibrarySetEventBeet: typeof receiveLibrarySetEventBeet;
declare const index$o_receiveLibraryTimeoutSetEventBeet: typeof receiveLibraryTimeoutSetEventBeet;
declare const index$o_sendLibrarySetEventBeet: typeof sendLibrarySetEventBeet;
declare namespace index$o {
  export { type AdminTransferredEvent$1 as AdminTransferredEvent, type index$o_ComposeDeliveredEvent as ComposeDeliveredEvent, type index$o_ComposeSentEvent as ComposeSentEvent, type index$o_DefaultReceiveLibrarySetEvent as DefaultReceiveLibrarySetEvent, type index$o_DefaultReceiveLibraryTimeoutSetEvent as DefaultReceiveLibraryTimeoutSetEvent, type index$o_DefaultSendLibrarySetEvent as DefaultSendLibrarySetEvent, type index$o_DelegateSetEvent as DelegateSetEvent, type index$o_InboundNonceSkippedEvent as InboundNonceSkippedEvent, type index$o_LibraryRegisteredEvent as LibraryRegisteredEvent, type index$o_LzComposeAlertEvent as LzComposeAlertEvent, type index$o_LzReceiveAlertEvent as LzReceiveAlertEvent, type index$o_LzTokenSetEvent as LzTokenSetEvent, type index$o_OAppRegisteredEvent as OAppRegisteredEvent, type index$o_PacketBurntEvent as PacketBurntEvent, type index$o_PacketDeliveredEvent as PacketDeliveredEvent, type index$o_PacketNilifiedEvent as PacketNilifiedEvent, type index$o_PacketSentEvent as PacketSentEvent, type index$o_PacketVerifiedEvent as PacketVerifiedEvent, type index$o_ReceiveLibrarySetEvent as ReceiveLibrarySetEvent, type index$o_ReceiveLibraryTimeoutSetEvent as ReceiveLibraryTimeoutSetEvent, type RentWithdrawnEvent$1 as RentWithdrawnEvent, type index$o_SendLibrarySetEvent as SendLibrarySetEvent, adminTransferredEventBeet$1 as adminTransferredEventBeet, index$o_composeDeliveredEventBeet as composeDeliveredEventBeet, index$o_composeSentEventBeet as composeSentEventBeet, index$o_defaultReceiveLibrarySetEventBeet as defaultReceiveLibrarySetEventBeet, index$o_defaultReceiveLibraryTimeoutSetEventBeet as defaultReceiveLibraryTimeoutSetEventBeet, index$o_defaultSendLibrarySetEventBeet as defaultSendLibrarySetEventBeet, index$o_delegateSetEventBeet as delegateSetEventBeet, index$o_inboundNonceSkippedEventBeet as inboundNonceSkippedEventBeet, index$o_libraryRegisteredEventBeet as libraryRegisteredEventBeet, index$o_lzComposeAlertEventBeet as lzComposeAlertEventBeet, index$o_lzReceiveAlertEventBeet as lzReceiveAlertEventBeet, index$o_lzTokenSetEventBeet as lzTokenSetEventBeet, index$o_oAppRegisteredEventBeet as oAppRegisteredEventBeet, index$o_packetBurntEventBeet as packetBurntEventBeet, index$o_packetDeliveredEventBeet as packetDeliveredEventBeet, index$o_packetNilifiedEventBeet as packetNilifiedEventBeet, index$o_packetSentEventBeet as packetSentEventBeet, index$o_packetVerifiedEventBeet as packetVerifiedEventBeet, index$o_receiveLibrarySetEventBeet as receiveLibrarySetEventBeet, index$o_receiveLibraryTimeoutSetEventBeet as receiveLibraryTimeoutSetEventBeet, rentWithdrawnEventBeet$1 as rentWithdrawnEventBeet, index$o_sendLibrarySetEventBeet as sendLibrarySetEventBeet };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link MessageLib}
 * @category Accounts
 * @category generated
 */
type MessageLibArgs = {
    eid: number;
    endpoint: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    bump: number;
    admin: web3.PublicKey;
    fee: beet.bignum;
    lzTokenFee: beet.bignum;
    wlCaller: web3.PublicKey;
};
declare const messageLibDiscriminator: number[];
/**
 * Holds the data for the {@link MessageLib} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class MessageLib implements MessageLibArgs {
    readonly eid: number;
    readonly endpoint: web3.PublicKey;
    readonly endpointProgram: web3.PublicKey;
    readonly bump: number;
    readonly admin: web3.PublicKey;
    readonly fee: beet.bignum;
    readonly lzTokenFee: beet.bignum;
    readonly wlCaller: web3.PublicKey;
    private constructor();
    /**
     * Creates a {@link MessageLib} instance from the provided args.
     */
    static fromArgs(args: MessageLibArgs): MessageLib;
    /**
     * Deserializes the {@link MessageLib} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [MessageLib, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link MessageLib} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<MessageLib>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        endpoint: any;
        admin: any;
        bump: any;
        eid: any;
        lzTokenFee: any;
        fee: any;
        accountDiscriminator: any;
        endpointProgram: any;
        wlCaller: any;
    }>;
    /**
     * Deserializes the {@link MessageLib} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [MessageLib, number];
    /**
     * Serializes the {@link MessageLib} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link MessageLib}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link MessageLib} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link MessageLib} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link MessageLib} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        eid: number;
        endpoint: string;
        endpointProgram: string;
        bump: number;
        admin: string;
        fee: number | {
            toNumber: () => number;
        };
        lzTokenFee: number | {
            toNumber: () => number;
        };
        wlCaller: string;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const messageLibBeet: beet.BeetStruct<MessageLib, MessageLibArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ReceiveConfigStore}
 * @category Accounts
 * @category generated
 */
type ReceiveConfigStoreArgs = {
    bump: number;
    data: Uint8Array;
};
declare const receiveConfigStoreDiscriminator: number[];
/**
 * Holds the data for the {@link ReceiveConfigStore} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ReceiveConfigStore implements ReceiveConfigStoreArgs {
    readonly bump: number;
    readonly data: Uint8Array;
    private constructor();
    /**
     * Creates a {@link ReceiveConfigStore} instance from the provided args.
     */
    static fromArgs(args: ReceiveConfigStoreArgs): ReceiveConfigStore;
    /**
     * Deserializes the {@link ReceiveConfigStore} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ReceiveConfigStore, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ReceiveConfigStore} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ReceiveConfigStore>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ReceiveConfigStoreArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link ReceiveConfigStore} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ReceiveConfigStore, number];
    /**
     * Serializes the {@link ReceiveConfigStore} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ReceiveConfigStore} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ReceiveConfigStoreArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ReceiveConfigStore} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ReceiveConfigStoreArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link ReceiveConfigStore} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        data: Uint8Array;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const receiveConfigStoreBeet: beet.FixableBeetStruct<ReceiveConfigStore, ReceiveConfigStoreArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link SendConfigStore}
 * @category Accounts
 * @category generated
 */
type SendConfigStoreArgs = {
    bump: number;
    data: Uint8Array;
};
declare const sendConfigStoreDiscriminator: number[];
/**
 * Holds the data for the {@link SendConfigStore} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class SendConfigStore implements SendConfigStoreArgs {
    readonly bump: number;
    readonly data: Uint8Array;
    private constructor();
    /**
     * Creates a {@link SendConfigStore} instance from the provided args.
     */
    static fromArgs(args: SendConfigStoreArgs): SendConfigStore;
    /**
     * Deserializes the {@link SendConfigStore} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [SendConfigStore, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link SendConfigStore} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<SendConfigStore>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<SendConfigStoreArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link SendConfigStore} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [SendConfigStore, number];
    /**
     * Serializes the {@link SendConfigStore} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link SendConfigStore} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: SendConfigStoreArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link SendConfigStore} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: SendConfigStoreArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link SendConfigStore} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        data: Uint8Array;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const sendConfigStoreBeet: beet.FixableBeetStruct<SendConfigStore, SendConfigStoreArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$5: {
    MessageLib: typeof MessageLib;
    ReceiveConfigStore: typeof ReceiveConfigStore;
    SendConfigStore: typeof SendConfigStore;
};

type index$n_MessageLib = MessageLib;
declare const index$n_MessageLib: typeof MessageLib;
type index$n_MessageLibArgs = MessageLibArgs;
type index$n_ReceiveConfigStore = ReceiveConfigStore;
declare const index$n_ReceiveConfigStore: typeof ReceiveConfigStore;
type index$n_ReceiveConfigStoreArgs = ReceiveConfigStoreArgs;
type index$n_SendConfigStore = SendConfigStore;
declare const index$n_SendConfigStore: typeof SendConfigStore;
type index$n_SendConfigStoreArgs = SendConfigStoreArgs;
declare const index$n_messageLibBeet: typeof messageLibBeet;
declare const index$n_messageLibDiscriminator: typeof messageLibDiscriminator;
declare const index$n_receiveConfigStoreBeet: typeof receiveConfigStoreBeet;
declare const index$n_receiveConfigStoreDiscriminator: typeof receiveConfigStoreDiscriminator;
declare const index$n_sendConfigStoreBeet: typeof sendConfigStoreBeet;
declare const index$n_sendConfigStoreDiscriminator: typeof sendConfigStoreDiscriminator;
declare namespace index$n {
  export { index$n_MessageLib as MessageLib, type index$n_MessageLibArgs as MessageLibArgs, index$n_ReceiveConfigStore as ReceiveConfigStore, type index$n_ReceiveConfigStoreArgs as ReceiveConfigStoreArgs, index$n_SendConfigStore as SendConfigStore, type index$n_SendConfigStoreArgs as SendConfigStoreArgs, accountProviders$5 as accountProviders, index$n_messageLibBeet as messageLibBeet, index$n_messageLibDiscriminator as messageLibDiscriminator, index$n_receiveConfigStoreBeet as receiveConfigStoreBeet, index$n_receiveConfigStoreDiscriminator as receiveConfigStoreDiscriminator, index$n_sendConfigStoreBeet as sendConfigStoreBeet, index$n_sendConfigStoreDiscriminator as sendConfigStoreDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode$4 = Error & {
    code: number;
};
type MaybeErrorWithCode$4 = ErrorWithCode$4 | null | undefined;
/**
 * OnlyWhitelistedCaller: ''
 *
 * @category Errors
 * @category generated
 */
declare class OnlyWhitelistedCallerError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InsufficientFee: ''
 *
 * @category Errors
 * @category generated
 */
declare class InsufficientFeeError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidAmount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidAmountError$2 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidConfigType: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidConfigTypeError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidLzTokenMint: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidLzTokenMintError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * LzTokenUnavailable: ''
 *
 * @category Errors
 * @category generated
 */
declare class LzTokenUnavailableError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * SendReentrancy: ''
 *
 * @category Errors
 * @category generated
 */
declare class SendReentrancyError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * OnlyRevert: ''
 *
 * @category Errors
 * @category generated
 */
declare class OnlyRevertError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode$4(code: number): MaybeErrorWithCode$4;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName$4(name: string): MaybeErrorWithCode$4;

type index$m_OnlyRevertError = OnlyRevertError;
declare const index$m_OnlyRevertError: typeof OnlyRevertError;
type index$m_OnlyWhitelistedCallerError = OnlyWhitelistedCallerError;
declare const index$m_OnlyWhitelistedCallerError: typeof OnlyWhitelistedCallerError;
type index$m_SendReentrancyError = SendReentrancyError;
declare const index$m_SendReentrancyError: typeof SendReentrancyError;
declare namespace index$m {
  export { InsufficientFeeError$1 as InsufficientFeeError, InvalidAmountError$2 as InvalidAmountError, InvalidConfigTypeError$1 as InvalidConfigTypeError, InvalidLzTokenMintError$1 as InvalidLzTokenMintError, LzTokenUnavailableError$1 as LzTokenUnavailableError, index$m_OnlyRevertError as OnlyRevertError, index$m_OnlyWhitelistedCallerError as OnlyWhitelistedCallerError, index$m_SendReentrancyError as SendReentrancyError, errorFromCode$4 as errorFromCode, errorFromName$4 as errorFromName };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitConfigParams$1 = {
    oapp: web3.PublicKey;
    eid: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initConfigParamsBeet$1: beet.BeetArgsStruct<InitConfigParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionArgs$1 = {
    params: InitConfigParams$1;
};
/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare const initConfigStruct$1: beet.BeetArgsStruct<InitConfigInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initConfig_ instruction
 *
 * @property [**signer**] endpoint
 * @property [_writable_, **signer**] payer
 * @property [] messageLib
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionAccounts$1 = {
    endpoint: web3.PublicKey;
    payer: web3.PublicKey;
    messageLib: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initConfigInstructionDiscriminator$1: number[];
/**
 * Creates a _InitConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstruction$1(accounts: InitConfigInstructionAccounts$1, args: InitConfigInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstructionAccounts$1(accounts: InitConfigInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitDefaultConfigParams$1 = {
    eid: number;
    sendConfig: beet.COption<Uint8Array>;
    receiveConfig: beet.COption<Uint8Array>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initDefaultConfigParamsBeet$1: beet.FixableBeetArgsStruct<InitDefaultConfigParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
type InitDefaultConfigInstructionArgs$1 = {
    params: InitDefaultConfigParams$1;
};
/**
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare const initDefaultConfigStruct$1: beet.FixableBeetArgsStruct<InitDefaultConfigInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initDefaultConfig_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [] messageLib
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
type InitDefaultConfigInstructionAccounts$1 = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initDefaultConfigInstructionDiscriminator$1: number[];
/**
 * Creates a _InitDefaultConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare function createInitDefaultConfigInstruction$1(accounts: InitDefaultConfigInstructionAccounts$1, args: InitDefaultConfigInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitDefaultConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare function createInitDefaultConfigInstructionAccounts$1(accounts: InitDefaultConfigInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitMessageLibParams = {
    eid: number;
    endpoint: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    admin: web3.PublicKey;
    fee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initMessageLibParamsBeet: beet.BeetArgsStruct<InitMessageLibParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitMessageLib
 * @category generated
 */
type InitMessageLibInstructionArgs = {
    params: InitMessageLibParams;
};
/**
 * @category Instructions
 * @category InitMessageLib
 * @category generated
 */
declare const initMessageLibStruct: beet.BeetArgsStruct<InitMessageLibInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initMessageLib_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] messageLib
 * @category Instructions
 * @category InitMessageLib
 * @category generated
 */
type InitMessageLibInstructionAccounts = {
    payer: web3.PublicKey;
    messageLib: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initMessageLibInstructionDiscriminator: number[];
/**
 * Creates a _InitMessageLib_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitMessageLib
 * @category generated
 */
declare function createInitMessageLibInstruction(accounts: InitMessageLibInstructionAccounts, args: InitMessageLibInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitMessageLib_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitMessageLib
 * @category generated
 */
declare function createInitMessageLibInstructionAccounts(accounts: InitMessageLibInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Packet$1 = {
    nonce: beet.bignum;
    srcEid: number;
    sender: web3.PublicKey;
    dstEid: number;
    receiver: number[];
    guid: number[];
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetBeet$1: beet.FixableBeetArgsStruct<Packet$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteParams$2 = {
    packet: Packet$1;
    options: Uint8Array;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteParamsBeet$2: beet.FixableBeetArgsStruct<QuoteParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionArgs$2 = {
    params: QuoteParams$2;
};
/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare const quoteStruct$2: beet.FixableBeetArgsStruct<QuoteInstructionArgs$2 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quote_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] messageLib
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionAccounts$2 = {
    endpoint: web3.PublicKey;
    messageLib: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteInstructionDiscriminator$2: number[];
/**
 * Creates a _Quote_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstruction$2(accounts: QuoteInstructionAccounts$2, args: QuoteInstructionArgs$2, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Quote_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstructionAccounts$2(accounts: QuoteInstructionAccounts$2, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category RevertCall
 * @category generated
 */
declare const revertCallStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number[];
}>;
declare const revertCallInstructionDiscriminator: number[];
/**
 * Creates a _RevertCall_ instruction.
 *
 * @category Instructions
 * @category RevertCall
 * @category generated
 */
declare function createRevertCallInstruction(programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _RevertCall_ instructionAccounts.
 *
 * @category Instructions
 * @category RevertCall
 * @category generated
 */
declare function createRevertCallInstructionAccounts(programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendParams$2 = {
    packet: Packet$1;
    options: Uint8Array;
    nativeFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendParamsBeet$2: beet.FixableBeetArgsStruct<SendParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionArgs$2 = {
    params: SendParams$2;
};
/**
 * @category Instructions
 * @category Send
 * @category generated
 */
declare const sendStruct$2: beet.FixableBeetArgsStruct<SendInstructionArgs$2 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _send_ instruction
 *
 * @property [**signer**] endpoint
 * @property [_writable_] messageLib
 * @property [_writable_, **signer**] payer
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionAccounts$2 = {
    endpoint: web3.PublicKey;
    messageLib: web3.PublicKey;
    payer: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendInstructionDiscriminator$2: number[];
/**
 * Creates a _Send_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstruction$2(accounts: SendInstructionAccounts$2, args: SendInstructionArgs$2, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Send_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstructionAccounts$2(accounts: SendInstructionAccounts$2, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendWithLzTokenParams$1 = {
    packet: Packet$1;
    options: Uint8Array;
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
    lzTokenMint: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendWithLzTokenParamsBeet$1: beet.FixableBeetArgsStruct<SendWithLzTokenParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
type SendWithLzTokenInstructionArgs$1 = {
    params: SendWithLzTokenParams$1;
};
/**
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare const sendWithLzTokenStruct$1: beet.FixableBeetArgsStruct<SendWithLzTokenInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _sendWithLzToken_ instruction
 *
 * @property [**signer**] endpoint
 * @property [_writable_] messageLib
 * @property [_writable_] messageLibLzToken
 * @property [_writable_, **signer**] payer
 * @property [_writable_] lzTokenSource
 * @property [] lzTokenMint
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
type SendWithLzTokenInstructionAccounts$1 = {
    endpoint: web3.PublicKey;
    messageLib: web3.PublicKey;
    messageLibLzToken: web3.PublicKey;
    payer: web3.PublicKey;
    lzTokenSource: web3.PublicKey;
    lzTokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendWithLzTokenInstructionDiscriminator$1: number[];
/**
 * Creates a _SendWithLzToken_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare function createSendWithLzTokenInstruction$1(accounts: SendWithLzTokenInstructionAccounts$1, args: SendWithLzTokenInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SendWithLzToken_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare function createSendWithLzTokenInstructionAccounts$1(accounts: SendWithLzTokenInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetConfigParams$2 = {
    oapp: web3.PublicKey;
    eid: number;
    configType: number;
    config: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setConfigParamsBeet$2: beet.FixableBeetArgsStruct<SetConfigParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionArgs$2 = {
    params: SetConfigParams$2;
};
/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare const setConfigStruct$2: beet.FixableBeetArgsStruct<SetConfigInstructionArgs$2 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setConfig_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] messageLib
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionAccounts$2 = {
    endpoint: web3.PublicKey;
    messageLib: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setConfigInstructionDiscriminator$2: number[];
/**
 * Creates a _SetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstruction$2(accounts: SetConfigInstructionAccounts$2, args: SetConfigInstructionArgs$2, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstructionAccounts$2(accounts: SetConfigInstructionAccounts$2, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDefaultConfigParams$1 = {
    eid: number;
    sendConfig: beet.COption<Uint8Array>;
    receiveConfig: beet.COption<Uint8Array>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDefaultConfigParamsBeet$1: beet.FixableBeetArgsStruct<SetDefaultConfigParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
type SetDefaultConfigInstructionArgs$1 = {
    params: SetDefaultConfigParams$1;
};
/**
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare const setDefaultConfigStruct$1: beet.FixableBeetArgsStruct<SetDefaultConfigInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDefaultConfig_ instruction
 *
 * @property [**signer**] admin
 * @property [] messageLib
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
type SetDefaultConfigInstructionAccounts$1 = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDefaultConfigInstructionDiscriminator$1: number[];
/**
 * Creates a _SetDefaultConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare function createSetDefaultConfigInstruction$1(accounts: SetDefaultConfigInstructionAccounts$1, args: SetDefaultConfigInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDefaultConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare function createSetDefaultConfigInstructionAccounts$1(accounts: SetDefaultConfigInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetFeeParams = {
    fee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setFeeParamsBeet: beet.BeetArgsStruct<SetFeeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetFee
 * @category generated
 */
type SetFeeInstructionArgs = {
    params: SetFeeParams;
};
/**
 * @category Instructions
 * @category SetFee
 * @category generated
 */
declare const setFeeStruct: beet.BeetArgsStruct<SetFeeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setFee_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] messageLib
 * @category Instructions
 * @category SetFee
 * @category generated
 */
type SetFeeInstructionAccounts = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setFeeInstructionDiscriminator: number[];
/**
 * Creates a _SetFee_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetFee
 * @category generated
 */
declare function createSetFeeInstruction(accounts: SetFeeInstructionAccounts, args: SetFeeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetFee_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetFee
 * @category generated
 */
declare function createSetFeeInstructionAccounts(accounts: SetFeeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetWlCallerParams = {
    newCaller: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setWlCallerParamsBeet: beet.BeetArgsStruct<SetWlCallerParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetWlCaller
 * @category generated
 */
type SetWlCallerInstructionArgs = {
    params: SetWlCallerParams;
};
/**
 * @category Instructions
 * @category SetWlCaller
 * @category generated
 */
declare const setWlCallerStruct: beet.BeetArgsStruct<SetWlCallerInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setWlCaller_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] messageLib
 * @category Instructions
 * @category SetWlCaller
 * @category generated
 */
type SetWlCallerInstructionAccounts = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setWlCallerInstructionDiscriminator: number[];
/**
 * Creates a _SetWlCaller_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetWlCaller
 * @category generated
 */
declare function createSetWlCallerInstruction(accounts: SetWlCallerInstructionAccounts, args: SetWlCallerInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetWlCaller_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetWlCaller
 * @category generated
 */
declare function createSetWlCallerInstructionAccounts(accounts: SetWlCallerInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransferAdminParams$3 = {
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transferAdminParamsBeet$3: beet.BeetArgsStruct<TransferAdminParams$3>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionArgs$3 = {
    params: TransferAdminParams$3;
};
/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare const transferAdminStruct$3: beet.BeetArgsStruct<TransferAdminInstructionArgs$3 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _transferAdmin_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] messageLib
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionAccounts$3 = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const transferAdminInstructionDiscriminator$3: number[];
/**
 * Creates a _TransferAdmin_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstruction$3(accounts: TransferAdminInstructionAccounts$3, args: TransferAdminInstructionArgs$3, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _TransferAdmin_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstructionAccounts$3(accounts: TransferAdminInstructionAccounts$3, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ValidatePacketParams = {
    packet: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const validatePacketParamsBeet: beet.FixableBeetArgsStruct<ValidatePacketParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ValidatePacket
 * @category generated
 */
type ValidatePacketInstructionArgs = {
    params: ValidatePacketParams;
};
/**
 * @category Instructions
 * @category ValidatePacket
 * @category generated
 */
declare const validatePacketStruct: beet.FixableBeetArgsStruct<ValidatePacketInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _validatePacket_ instruction
 *
 * @property [**signer**] payer
 * @property [] receiveLibrary
 * @category Instructions
 * @category ValidatePacket
 * @category generated
 */
type ValidatePacketInstructionAccounts = {
    payer: web3.PublicKey;
    receiveLibrary: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const validatePacketInstructionDiscriminator: number[];
/**
 * Creates a _ValidatePacket_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ValidatePacket
 * @category generated
 */
declare function createValidatePacketInstruction(accounts: ValidatePacketInstructionAccounts, args: ValidatePacketInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _ValidatePacket_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category ValidatePacket
 * @category generated
 */
declare function createValidatePacketInstructionAccounts(accounts: ValidatePacketInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Version
 * @category generated
 */
declare const versionStruct$3: beet.BeetArgsStruct<{
    instructionDiscriminator: number[];
}>;
declare const versionInstructionDiscriminator$3: number[];
/**
 * Creates a _Version_ instruction.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstruction$3(programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Version_ instructionAccounts.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstructionAccounts$3(programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawFeesParams = {
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawFeesParamsBeet: beet.BeetArgsStruct<WithdrawFeesParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawFees
 * @category generated
 */
type WithdrawFeesInstructionArgs = {
    params: WithdrawFeesParams;
};
/**
 * @category Instructions
 * @category WithdrawFees
 * @category generated
 */
declare const withdrawFeesStruct: beet.BeetArgsStruct<WithdrawFeesInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _withdrawFees_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] messageLib
 * @property [_writable_] receiver
 * @category Instructions
 * @category WithdrawFees
 * @category generated
 */
type WithdrawFeesInstructionAccounts = {
    admin: web3.PublicKey;
    messageLib: web3.PublicKey;
    receiver: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const withdrawFeesInstructionDiscriminator: number[];
/**
 * Creates a _WithdrawFees_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawFees
 * @category generated
 */
declare function createWithdrawFeesInstruction(accounts: WithdrawFeesInstructionAccounts, args: WithdrawFeesInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _WithdrawFees_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category WithdrawFees
 * @category generated
 */
declare function createWithdrawFeesInstructionAccounts(accounts: WithdrawFeesInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

type index$l_InitMessageLibInstructionAccounts = InitMessageLibInstructionAccounts;
type index$l_InitMessageLibInstructionArgs = InitMessageLibInstructionArgs;
type index$l_SetFeeInstructionAccounts = SetFeeInstructionAccounts;
type index$l_SetFeeInstructionArgs = SetFeeInstructionArgs;
type index$l_SetWlCallerInstructionAccounts = SetWlCallerInstructionAccounts;
type index$l_SetWlCallerInstructionArgs = SetWlCallerInstructionArgs;
type index$l_ValidatePacketInstructionAccounts = ValidatePacketInstructionAccounts;
type index$l_ValidatePacketInstructionArgs = ValidatePacketInstructionArgs;
type index$l_WithdrawFeesInstructionAccounts = WithdrawFeesInstructionAccounts;
type index$l_WithdrawFeesInstructionArgs = WithdrawFeesInstructionArgs;
declare const index$l_createInitMessageLibInstruction: typeof createInitMessageLibInstruction;
declare const index$l_createInitMessageLibInstructionAccounts: typeof createInitMessageLibInstructionAccounts;
declare const index$l_createRevertCallInstruction: typeof createRevertCallInstruction;
declare const index$l_createRevertCallInstructionAccounts: typeof createRevertCallInstructionAccounts;
declare const index$l_createSetFeeInstruction: typeof createSetFeeInstruction;
declare const index$l_createSetFeeInstructionAccounts: typeof createSetFeeInstructionAccounts;
declare const index$l_createSetWlCallerInstruction: typeof createSetWlCallerInstruction;
declare const index$l_createSetWlCallerInstructionAccounts: typeof createSetWlCallerInstructionAccounts;
declare const index$l_createValidatePacketInstruction: typeof createValidatePacketInstruction;
declare const index$l_createValidatePacketInstructionAccounts: typeof createValidatePacketInstructionAccounts;
declare const index$l_createWithdrawFeesInstruction: typeof createWithdrawFeesInstruction;
declare const index$l_createWithdrawFeesInstructionAccounts: typeof createWithdrawFeesInstructionAccounts;
declare const index$l_initMessageLibInstructionDiscriminator: typeof initMessageLibInstructionDiscriminator;
declare const index$l_initMessageLibStruct: typeof initMessageLibStruct;
declare const index$l_revertCallInstructionDiscriminator: typeof revertCallInstructionDiscriminator;
declare const index$l_revertCallStruct: typeof revertCallStruct;
declare const index$l_setFeeInstructionDiscriminator: typeof setFeeInstructionDiscriminator;
declare const index$l_setFeeStruct: typeof setFeeStruct;
declare const index$l_setWlCallerInstructionDiscriminator: typeof setWlCallerInstructionDiscriminator;
declare const index$l_setWlCallerStruct: typeof setWlCallerStruct;
declare const index$l_validatePacketInstructionDiscriminator: typeof validatePacketInstructionDiscriminator;
declare const index$l_validatePacketStruct: typeof validatePacketStruct;
declare const index$l_withdrawFeesInstructionDiscriminator: typeof withdrawFeesInstructionDiscriminator;
declare const index$l_withdrawFeesStruct: typeof withdrawFeesStruct;
declare namespace index$l {
  export { type InitConfigInstructionAccounts$1 as InitConfigInstructionAccounts, type InitConfigInstructionArgs$1 as InitConfigInstructionArgs, type InitDefaultConfigInstructionAccounts$1 as InitDefaultConfigInstructionAccounts, type InitDefaultConfigInstructionArgs$1 as InitDefaultConfigInstructionArgs, type index$l_InitMessageLibInstructionAccounts as InitMessageLibInstructionAccounts, type index$l_InitMessageLibInstructionArgs as InitMessageLibInstructionArgs, type QuoteInstructionAccounts$2 as QuoteInstructionAccounts, type QuoteInstructionArgs$2 as QuoteInstructionArgs, type SendInstructionAccounts$2 as SendInstructionAccounts, type SendInstructionArgs$2 as SendInstructionArgs, type SendWithLzTokenInstructionAccounts$1 as SendWithLzTokenInstructionAccounts, type SendWithLzTokenInstructionArgs$1 as SendWithLzTokenInstructionArgs, type SetConfigInstructionAccounts$2 as SetConfigInstructionAccounts, type SetConfigInstructionArgs$2 as SetConfigInstructionArgs, type SetDefaultConfigInstructionAccounts$1 as SetDefaultConfigInstructionAccounts, type SetDefaultConfigInstructionArgs$1 as SetDefaultConfigInstructionArgs, type index$l_SetFeeInstructionAccounts as SetFeeInstructionAccounts, type index$l_SetFeeInstructionArgs as SetFeeInstructionArgs, type index$l_SetWlCallerInstructionAccounts as SetWlCallerInstructionAccounts, type index$l_SetWlCallerInstructionArgs as SetWlCallerInstructionArgs, type TransferAdminInstructionAccounts$3 as TransferAdminInstructionAccounts, type TransferAdminInstructionArgs$3 as TransferAdminInstructionArgs, type index$l_ValidatePacketInstructionAccounts as ValidatePacketInstructionAccounts, type index$l_ValidatePacketInstructionArgs as ValidatePacketInstructionArgs, type index$l_WithdrawFeesInstructionAccounts as WithdrawFeesInstructionAccounts, type index$l_WithdrawFeesInstructionArgs as WithdrawFeesInstructionArgs, createInitConfigInstruction$1 as createInitConfigInstruction, createInitConfigInstructionAccounts$1 as createInitConfigInstructionAccounts, createInitDefaultConfigInstruction$1 as createInitDefaultConfigInstruction, createInitDefaultConfigInstructionAccounts$1 as createInitDefaultConfigInstructionAccounts, index$l_createInitMessageLibInstruction as createInitMessageLibInstruction, index$l_createInitMessageLibInstructionAccounts as createInitMessageLibInstructionAccounts, createQuoteInstruction$2 as createQuoteInstruction, createQuoteInstructionAccounts$2 as createQuoteInstructionAccounts, index$l_createRevertCallInstruction as createRevertCallInstruction, index$l_createRevertCallInstructionAccounts as createRevertCallInstructionAccounts, createSendInstruction$2 as createSendInstruction, createSendInstructionAccounts$2 as createSendInstructionAccounts, createSendWithLzTokenInstruction$1 as createSendWithLzTokenInstruction, createSendWithLzTokenInstructionAccounts$1 as createSendWithLzTokenInstructionAccounts, createSetConfigInstruction$2 as createSetConfigInstruction, createSetConfigInstructionAccounts$2 as createSetConfigInstructionAccounts, createSetDefaultConfigInstruction$1 as createSetDefaultConfigInstruction, createSetDefaultConfigInstructionAccounts$1 as createSetDefaultConfigInstructionAccounts, index$l_createSetFeeInstruction as createSetFeeInstruction, index$l_createSetFeeInstructionAccounts as createSetFeeInstructionAccounts, index$l_createSetWlCallerInstruction as createSetWlCallerInstruction, index$l_createSetWlCallerInstructionAccounts as createSetWlCallerInstructionAccounts, createTransferAdminInstruction$3 as createTransferAdminInstruction, createTransferAdminInstructionAccounts$3 as createTransferAdminInstructionAccounts, index$l_createValidatePacketInstruction as createValidatePacketInstruction, index$l_createValidatePacketInstructionAccounts as createValidatePacketInstructionAccounts, createVersionInstruction$3 as createVersionInstruction, createVersionInstructionAccounts$3 as createVersionInstructionAccounts, index$l_createWithdrawFeesInstruction as createWithdrawFeesInstruction, index$l_createWithdrawFeesInstructionAccounts as createWithdrawFeesInstructionAccounts, initConfigInstructionDiscriminator$1 as initConfigInstructionDiscriminator, initConfigStruct$1 as initConfigStruct, initDefaultConfigInstructionDiscriminator$1 as initDefaultConfigInstructionDiscriminator, initDefaultConfigStruct$1 as initDefaultConfigStruct, index$l_initMessageLibInstructionDiscriminator as initMessageLibInstructionDiscriminator, index$l_initMessageLibStruct as initMessageLibStruct, quoteInstructionDiscriminator$2 as quoteInstructionDiscriminator, quoteStruct$2 as quoteStruct, index$l_revertCallInstructionDiscriminator as revertCallInstructionDiscriminator, index$l_revertCallStruct as revertCallStruct, sendInstructionDiscriminator$2 as sendInstructionDiscriminator, sendStruct$2 as sendStruct, sendWithLzTokenInstructionDiscriminator$1 as sendWithLzTokenInstructionDiscriminator, sendWithLzTokenStruct$1 as sendWithLzTokenStruct, setConfigInstructionDiscriminator$2 as setConfigInstructionDiscriminator, setConfigStruct$2 as setConfigStruct, setDefaultConfigInstructionDiscriminator$1 as setDefaultConfigInstructionDiscriminator, setDefaultConfigStruct$1 as setDefaultConfigStruct, index$l_setFeeInstructionDiscriminator as setFeeInstructionDiscriminator, index$l_setFeeStruct as setFeeStruct, index$l_setWlCallerInstructionDiscriminator as setWlCallerInstructionDiscriminator, index$l_setWlCallerStruct as setWlCallerStruct, transferAdminInstructionDiscriminator$3 as transferAdminInstructionDiscriminator, transferAdminStruct$3 as transferAdminStruct, index$l_validatePacketInstructionDiscriminator as validatePacketInstructionDiscriminator, index$l_validatePacketStruct as validatePacketStruct, versionInstructionDiscriminator$3 as versionInstructionDiscriminator, versionStruct$3 as versionStruct, index$l_withdrawFeesInstructionDiscriminator as withdrawFeesInstructionDiscriminator, index$l_withdrawFeesStruct as withdrawFeesStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingFee$2 = {
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingFeeBeet$2: beet.BeetArgsStruct<MessagingFee$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Version$2 = {
    major: beet.bignum;
    minor: number;
    endpointVersion: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const versionBeet$2: beet.BeetArgsStruct<Version$2>;

type index$k_InitMessageLibParams = InitMessageLibParams;
type index$k_SetFeeParams = SetFeeParams;
type index$k_SetWlCallerParams = SetWlCallerParams;
type index$k_ValidatePacketParams = ValidatePacketParams;
type index$k_WithdrawFeesParams = WithdrawFeesParams;
declare const index$k_initMessageLibParamsBeet: typeof initMessageLibParamsBeet;
declare const index$k_setFeeParamsBeet: typeof setFeeParamsBeet;
declare const index$k_setWlCallerParamsBeet: typeof setWlCallerParamsBeet;
declare const index$k_validatePacketParamsBeet: typeof validatePacketParamsBeet;
declare const index$k_withdrawFeesParamsBeet: typeof withdrawFeesParamsBeet;
declare namespace index$k {
  export { type InitConfigParams$1 as InitConfigParams, type InitDefaultConfigParams$1 as InitDefaultConfigParams, type index$k_InitMessageLibParams as InitMessageLibParams, type MessagingFee$2 as MessagingFee, type Packet$1 as Packet, type QuoteParams$2 as QuoteParams, type SendParams$2 as SendParams, type SendWithLzTokenParams$1 as SendWithLzTokenParams, type SetConfigParams$2 as SetConfigParams, type SetDefaultConfigParams$1 as SetDefaultConfigParams, type index$k_SetFeeParams as SetFeeParams, type index$k_SetWlCallerParams as SetWlCallerParams, type TransferAdminParams$3 as TransferAdminParams, type index$k_ValidatePacketParams as ValidatePacketParams, type Version$2 as Version, type index$k_WithdrawFeesParams as WithdrawFeesParams, initConfigParamsBeet$1 as initConfigParamsBeet, initDefaultConfigParamsBeet$1 as initDefaultConfigParamsBeet, index$k_initMessageLibParamsBeet as initMessageLibParamsBeet, messagingFeeBeet$2 as messagingFeeBeet, packetBeet$1 as packetBeet, quoteParamsBeet$2 as quoteParamsBeet, sendParamsBeet$2 as sendParamsBeet, sendWithLzTokenParamsBeet$1 as sendWithLzTokenParamsBeet, setConfigParamsBeet$2 as setConfigParamsBeet, setDefaultConfigParamsBeet$1 as setDefaultConfigParamsBeet, index$k_setFeeParamsBeet as setFeeParamsBeet, index$k_setWlCallerParamsBeet as setWlCallerParamsBeet, transferAdminParamsBeet$3 as transferAdminParamsBeet, index$k_validatePacketParamsBeet as validatePacketParamsBeet, versionBeet$2 as versionBeet, index$k_withdrawFeesParamsBeet as withdrawFeesParamsBeet };
}

/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$6: PublicKey;

declare const EventEmitDiscriminator = "e445a52e51cb9a1d";
declare const DefaultMessageLib: PublicKey;
declare class Endpoint {
    program: PublicKey;
    endpointDeriver: EndpointPDADeriver;
    eventAuthorityPDA: PublicKey;
    constructor(program: PublicKey);
    /**
     * init endpoint settings, including eid, admin, it also registers the blocked message lib
     */
    initEndpoint(connection: Connection, endpointId: number, payer: PublicKey, admin: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    /***
     * call this function after endpoint initialized. Only admin can call this function.
     */
    registerLibrary(connection: Connection, admin: PublicKey, messageLibProgram: PublicKey, libType?: MessageLibType, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    setDefaultSendLibrary(connection: Connection, admin: PublicKey, messageLibProgram: PublicKey, dstEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    setDefaultReceiveLibrary(connection: Connection, admin: PublicKey, messageLibProgram: PublicKey, srcEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    initOappConfig(delegate: PublicKey, msgLibSDK: MessageLibInterface, payer: PublicKey, oappID: PublicKey, eid: number): Promise<TransactionInstruction>;
    initOAppNonce(connection: Connection, delegate: PublicKey, // payer
    dstEid: number, oappIDPDA: PublicKey, remoteOappAddr: Uint8Array): Promise<TransactionInstruction | null>;
    initSendLibrary(connection: Connection, delegate: PublicKey, sender: PublicKey, dstEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    setSendLibrary(_connection: Connection, oappAdmin: PublicKey, oappIDPDA: PublicKey, newSendLibProgram: PublicKey, dstEid: number): Promise<TransactionInstruction | null>;
    initReceiveLibrary(connection: Connection, delegate: PublicKey, receiver: PublicKey, srcEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    setReceiveLibrary(_connection: Connection, oappAdmin: PublicKey, oappIDPDA: PublicKey, newReceiveLibProgram: PublicKey, srcEid: number, gracePeriod?: number): Promise<TransactionInstruction | null>;
    setOappConfig(connection: Connection, oappDelegate: PublicKey, oappID: PublicKey, msgLibProgram: PublicKey, eid: number, config: {
        configType: SetConfigType;
        value: ExecutorConfig$1 | UlnConfig$1;
    }, commitment?: Commitment): Promise<TransactionInstruction>;
    /***
     *
     * caculate the fee for sending a message with ULN:
     *  1. executorFee: feeForGas + feeForOptionType
     *      * feeForGas: ((gas + gasForCalldata) * gasPriceInUnit * priceRatio / priceRatioDenominator) * multiplier_bps / 10000
     *      * feeForOptionType: nativeDrop/lzReceive/lzCompose
     *  2. oracleFee: feeForGas
     *      * feeForGas: same above
     *
     *  The priceRatioDenominator is 10^20
     *  totalFee = executorFee + oracleFee * numOracles(requiredOracles + optionalOracles)
     */
    getQuoteIXAccountMetaForCPI(connection: Connection, payer: PublicKey, path: PacketPath, msgLibProgram: MessageLibInterface): Promise<AccountMeta[]>;
    /***
     * Get the account meta of the send instruction for CPI(Cross-Program Invocation )
     */
    getSendIXAccountMetaForCPI(connection: Connection, payer: PublicKey, path: PacketPath, msgLibProgram: MessageLibInterface, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<AccountMeta[]>;
    skip(payer: PublicKey, sender: PublicKey, receiver: PublicKey, srcEid: number, nonce: string): Promise<TransactionInstruction | null>;
    initVerify(connection: Connection, payer: PublicKey, sender: PublicKey, receiver: PublicKey, srcEid: number, nonce: string, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    getVerifyIXAccountMetaForCPI(packet: PacketV1Codec, receiveLibrary: PublicKey): AccountMeta[];
    /***
     * setConfig is only supported by ULN
     */
    getSetConfigIXAccountMetaForCPI(_connection: Connection, msgLibProgram: PublicKey, oappID: PublicKey, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): AccountMeta[];
    /***
     * resetConfig is only supported by ULN
     */
    /**
     * snapshotConfig is only supported by ULN
     */
    /**
     * @param composer. The composer is usually the PDA of the app's ID. It depends on the oapp's implementation.
     */
    /**
     * @param composer. The composer is usually the PDA of the app's ID. It depends on the oapp's implementation.
     */
    getSkipIxAccountMetaForCPI(receiver: PublicKey, sender: Uint8Array, srcEid: number, nonce: number): AccountMeta[];
    isDefaultSendLibrary(connection: Connection, messageLibProgram: PublicKey, dstEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
    isDefaultReceiveLibrary(connection: Connection, messageLibProgram: PublicKey, srcEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
    getSetting(connection: Connection, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<EndpointSettings | null>;
    /**
     *
     * @param messageLib  It is a PDA of the message library program
     */
    getMessageLibInfo(connection: Connection, messageLibProgram: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<MessageLibInfo | null>;
    getDefaultReceiveLibrary(connection: Connection, srcEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<{
        msgLib: PublicKey;
        owner?: PublicKey;
    } | null>;
    getDefaultSendLibrary(connection: Connection, dstEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<{
        msgLib: PublicKey;
        owner?: PublicKey;
    } | null>;
    /**
     * get app configured send library
     */
    getSendLibrary(connection: Connection, oappPda: PublicKey, dstEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<{
        msgLib: PublicKey;
        programId?: PublicKey;
        isDefault: boolean;
    } | null>;
    /**
     * get app configured receive library
     */
    getReceiveLibrary(connection: Connection, oappPda: PublicKey, srcEid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<{
        msgLib: PublicKey;
        programId?: PublicKey;
        isDefault: boolean;
        timeout: {
            msgLib: PublicKey;
            isValid: boolean;
        } | null;
    } | null>;
    getInboundPayloadHash(connection: Connection, receiver: PublicKey, srcEid: number, sender: Uint8Array, nonce: number, _payloadHash: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<PayloadHash | null>;
    getComposedMessageState(connection: Connection, from: PublicKey, params: SendComposeParams, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<ComposeMessageState | null>;
    getNonce(connection: Connection, oappIDPDA: PublicKey, remoteEid: number, remoteOappAddr: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<Nonce$1 | null>;
    getPendingInboundNonce(connection: Connection, oappIDPDA: PublicKey, remoteEid: number, remoteOappAddr: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<PendingInboundNonce | null>;
    getMessageLibVersion(connection: Connection, payer: PublicKey, messageLibProgram: PublicKey, commitment?: Commitment): Promise<Version$2 | null>;
    transferAdmin(connection: Connection, admin: PublicKey, newAdmin: PublicKey, commitment?: Commitment): Promise<TransactionInstruction | null>;
}

declare const endpoint_DefaultMessageLib: typeof DefaultMessageLib;
type endpoint_Endpoint = Endpoint;
declare const endpoint_Endpoint: typeof Endpoint;
declare const endpoint_EventEmitDiscriminator: typeof EventEmitDiscriminator;
declare namespace endpoint {
  export { endpoint_DefaultMessageLib as DefaultMessageLib, endpoint_Endpoint as Endpoint, endpoint_EventEmitDiscriminator as EventEmitDiscriminator, PROGRAM_ID$7 as PROGRAM_ID, index$s as accounts, index$r as errors, index$o as events, index$q as instructions, index$p as types };
}

declare class SimpleMessageLib implements MessageLibInterface {
    program: PublicKey;
    deriver: MessageLibPDADeriver;
    constructor(program: PublicKey);
    initSimpleMessageLib(connection: Connection, endpointProgram: PublicKey, payer: PublicKey, admin: PublicKey, eid: number, nativeFee: number, lzTokenFee?: number): Promise<TransactionInstruction | null>;
    setWhitelistCaller(admin: PublicKey, newCaller: PublicKey): TransactionInstruction;
    isWhiteListed(connection: Connection, caller: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
    getWhiteListCaller(connection: Connection, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<PublicKey>;
    validatePacket(_connection: Connection, endpointProgram: PublicKey, payer: PublicKey, encodedPacket: Uint8Array): TransactionInstruction;
    /***
     * Get the account meta of the send instruction for CPI(Cross-Program Invocation )
     */
    getSendIXAccountMetaForCPI(_connection: Connection, payer: PublicKey, _path: PacketPath): Promise<AccountMeta[]>;
    getQuoteIXAccountMetaForCPI(_connection: Connection, _payer: PublicKey, _path: PacketPath, _commitment?: Commitment): Promise<AccountMeta[]>;
    /***
     * Get the account meta of the send instruction for CPI(Cross-Program Invocation )
     */
    getInitConfigIXAccountMetaForCPI(payer: PublicKey, oappID: PublicKey, eid: number): Promise<AccountMeta[]>;
    getSetConfigIXAccountMetaForCPI(_endpointProgram: PublicKey, _oappID: PublicKey, _eid: number): Promise<AccountMeta[]>;
}

type simpleMessageLib_SimpleMessageLib = SimpleMessageLib;
declare const simpleMessageLib_SimpleMessageLib: typeof SimpleMessageLib;
declare namespace simpleMessageLib {
  export { PROGRAM_ID$6 as PROGRAM_ID, simpleMessageLib_SimpleMessageLib as SimpleMessageLib, index$n as accounts, index$m as errors, index$l as instructions, index$k as types };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link Confirmations}
 * @category Accounts
 * @category generated
 */
type ConfirmationsArgs = {
    value: beet.COption<beet.bignum>;
    bump: number;
};
declare const confirmationsDiscriminator: number[];
/**
 * Holds the data for the {@link Confirmations} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class Confirmations implements ConfirmationsArgs {
    readonly value: beet.COption<beet.bignum>;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link Confirmations} instance from the provided args.
     */
    static fromArgs(args: ConfirmationsArgs): Confirmations;
    /**
     * Deserializes the {@link Confirmations} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [Confirmations, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link Confirmations} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<Confirmations>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ConfirmationsArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link Confirmations} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [Confirmations, number];
    /**
     * Serializes the {@link Confirmations} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link Confirmations} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ConfirmationsArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link Confirmations} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ConfirmationsArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link Confirmations} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        value: beet.COption<beet.bignum>;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const confirmationsBeet: beet.FixableBeetStruct<Confirmations, ConfirmationsArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type UlnConfig$1 = {
    confirmations: beet.bignum;
    requiredDvnCount: number;
    optionalDvnCount: number;
    optionalDvnThreshold: number;
    requiredDvns: web3.PublicKey[];
    optionalDvns: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const ulnConfigBeet$1: beet.FixableBeetArgsStruct<UlnConfig$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ReceiveConfig}
 * @category Accounts
 * @category generated
 */
type ReceiveConfigArgs$1 = {
    bump: number;
    uln: UlnConfig$1;
};
declare const receiveConfigDiscriminator$1: number[];
/**
 * Holds the data for the {@link ReceiveConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ReceiveConfig$1 implements ReceiveConfigArgs$1 {
    readonly bump: number;
    readonly uln: UlnConfig$1;
    private constructor();
    /**
     * Creates a {@link ReceiveConfig} instance from the provided args.
     */
    static fromArgs(args: ReceiveConfigArgs$1): ReceiveConfig$1;
    /**
     * Deserializes the {@link ReceiveConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ReceiveConfig$1, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ReceiveConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ReceiveConfig$1>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ReceiveConfigArgs$1 & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link ReceiveConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ReceiveConfig$1, number];
    /**
     * Serializes the {@link ReceiveConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ReceiveConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ReceiveConfigArgs$1): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ReceiveConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ReceiveConfigArgs$1, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link ReceiveConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        uln: UlnConfig$1;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const receiveConfigBeet$1: beet.FixableBeetStruct<ReceiveConfig$1, ReceiveConfigArgs$1 & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ExecutorConfig$1 = {
    maxMessageSize: number;
    executor: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const executorConfigBeet$1: beet.BeetArgsStruct<ExecutorConfig$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link SendConfig}
 * @category Accounts
 * @category generated
 */
type SendConfigArgs = {
    bump: number;
    uln: UlnConfig$1;
    executor: ExecutorConfig$1;
};
declare const sendConfigDiscriminator: number[];
/**
 * Holds the data for the {@link SendConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class SendConfig implements SendConfigArgs {
    readonly bump: number;
    readonly uln: UlnConfig$1;
    readonly executor: ExecutorConfig$1;
    private constructor();
    /**
     * Creates a {@link SendConfig} instance from the provided args.
     */
    static fromArgs(args: SendConfigArgs): SendConfig;
    /**
     * Deserializes the {@link SendConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [SendConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link SendConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<SendConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<SendConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link SendConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [SendConfig, number];
    /**
     * Serializes the {@link SendConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link SendConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: SendConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link SendConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: SendConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link SendConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        uln: UlnConfig$1;
        executor: ExecutorConfig$1;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const sendConfigBeet: beet.FixableBeetStruct<SendConfig, SendConfigArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzTokenTreasury = {
    receiver: web3.PublicKey;
    fee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzTokenTreasuryBeet: beet.BeetArgsStruct<LzTokenTreasury>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Treasury = {
    admin: beet.COption<web3.PublicKey>;
    nativeReceiver: web3.PublicKey;
    nativeFeeBps: beet.bignum;
    lzToken: beet.COption<LzTokenTreasury>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const treasuryBeet: beet.FixableBeetArgsStruct<Treasury>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link UlnSettings}
 * @category Accounts
 * @category generated
 */
type UlnSettingsArgs = {
    eid: number;
    endpoint: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    bump: number;
    admin: web3.PublicKey;
    treasury: beet.COption<Treasury>;
};
declare const ulnSettingsDiscriminator: number[];
/**
 * Holds the data for the {@link UlnSettings} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class UlnSettings implements UlnSettingsArgs {
    readonly eid: number;
    readonly endpoint: web3.PublicKey;
    readonly endpointProgram: web3.PublicKey;
    readonly bump: number;
    readonly admin: web3.PublicKey;
    readonly treasury: beet.COption<Treasury>;
    private constructor();
    /**
     * Creates a {@link UlnSettings} instance from the provided args.
     */
    static fromArgs(args: UlnSettingsArgs): UlnSettings;
    /**
     * Deserializes the {@link UlnSettings} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [UlnSettings, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link UlnSettings} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<UlnSettings>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<UlnSettingsArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link UlnSettings} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [UlnSettings, number];
    /**
     * Serializes the {@link UlnSettings} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link UlnSettings} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: UlnSettingsArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link UlnSettings} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: UlnSettingsArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link UlnSettings} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        eid: number;
        endpoint: string;
        endpointProgram: string;
        bump: number;
        admin: string;
        treasury: beet.COption<Treasury>;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const ulnSettingsBeet: beet.FixableBeetStruct<UlnSettings, UlnSettingsArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$4: {
    Confirmations: typeof Confirmations;
    ReceiveConfig: typeof ReceiveConfig$1;
    SendConfig: typeof SendConfig;
    UlnSettings: typeof UlnSettings;
};

type index$j_Confirmations = Confirmations;
declare const index$j_Confirmations: typeof Confirmations;
type index$j_ConfirmationsArgs = ConfirmationsArgs;
type index$j_SendConfig = SendConfig;
declare const index$j_SendConfig: typeof SendConfig;
type index$j_SendConfigArgs = SendConfigArgs;
type index$j_UlnSettings = UlnSettings;
declare const index$j_UlnSettings: typeof UlnSettings;
type index$j_UlnSettingsArgs = UlnSettingsArgs;
declare const index$j_confirmationsBeet: typeof confirmationsBeet;
declare const index$j_confirmationsDiscriminator: typeof confirmationsDiscriminator;
declare const index$j_sendConfigBeet: typeof sendConfigBeet;
declare const index$j_sendConfigDiscriminator: typeof sendConfigDiscriminator;
declare const index$j_ulnSettingsBeet: typeof ulnSettingsBeet;
declare const index$j_ulnSettingsDiscriminator: typeof ulnSettingsDiscriminator;
declare namespace index$j {
  export { index$j_Confirmations as Confirmations, type index$j_ConfirmationsArgs as ConfirmationsArgs, ReceiveConfig$1 as ReceiveConfig, type ReceiveConfigArgs$1 as ReceiveConfigArgs, index$j_SendConfig as SendConfig, type index$j_SendConfigArgs as SendConfigArgs, index$j_UlnSettings as UlnSettings, type index$j_UlnSettingsArgs as UlnSettingsArgs, accountProviders$4 as accountProviders, index$j_confirmationsBeet as confirmationsBeet, index$j_confirmationsDiscriminator as confirmationsDiscriminator, receiveConfigBeet$1 as receiveConfigBeet, receiveConfigDiscriminator$1 as receiveConfigDiscriminator, index$j_sendConfigBeet as sendConfigBeet, index$j_sendConfigDiscriminator as sendConfigDiscriminator, index$j_ulnSettingsBeet as ulnSettingsBeet, index$j_ulnSettingsDiscriminator as ulnSettingsDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode$3 = Error & {
    code: number;
};
type MaybeErrorWithCode$3 = ErrorWithCode$3 | null | undefined;
/**
 * Unauthorized: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnauthorizedError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidAmount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidAmountError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidExecutor: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidExecutorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ZeroMessageSize: ''
 *
 * @category Errors
 * @category generated
 */
declare class ZeroMessageSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidRequiredDVNCount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidRequiredDVNCountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidOptionalDVNCount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidOptionalDVNCountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidOptionalDVNThreshold: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidOptionalDVNThresholdError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidConfirmations: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidConfirmationsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * AtLeastOneDVN: ''
 *
 * @category Errors
 * @category generated
 */
declare class AtLeastOneDVNError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Unsorted: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnsortedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTreasuryFeeCap: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTreasuryFeeCapError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidPacketVersion: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidPacketVersionError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidEid: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidEidError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Verifying: ''
 *
 * @category Errors
 * @category generated
 */
declare class VerifyingError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidWorkerId: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidWorkerIdError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidOptionType: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidOptionTypeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidBps: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidBpsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ExceededMaxMessageSize: ''
 *
 * @category Errors
 * @category generated
 */
declare class ExceededMaxMessageSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidExecutorProgram: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidExecutorProgramError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidAccountLength: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidAccountLengthError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidDvnProgram: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidDvnProgramError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidDvn: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidDvnError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * LzTokenUnavailable: ''
 *
 * @category Errors
 * @category generated
 */
declare class LzTokenUnavailableError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InsufficientFee: ''
 *
 * @category Errors
 * @category generated
 */
declare class InsufficientFeeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTreasury: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTreasuryError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidLzTokenMint: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidLzTokenMintError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidConfigType: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidConfigTypeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidConfirmation: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidConfirmationError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidType1Size: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidType1SizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidType2Size: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidType2SizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ExceededU128: ''
 *
 * @category Errors
 * @category generated
 */
declare class ExceededU128Error extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NonSigner: ''
 *
 * @category Errors
 * @category generated
 */
declare class NonSignerError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidPayer: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidPayerError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode$3(code: number): MaybeErrorWithCode$3;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName$3(name: string): MaybeErrorWithCode$3;

type index$i_AtLeastOneDVNError = AtLeastOneDVNError;
declare const index$i_AtLeastOneDVNError: typeof AtLeastOneDVNError;
type index$i_ExceededMaxMessageSizeError = ExceededMaxMessageSizeError;
declare const index$i_ExceededMaxMessageSizeError: typeof ExceededMaxMessageSizeError;
type index$i_ExceededU128Error = ExceededU128Error;
declare const index$i_ExceededU128Error: typeof ExceededU128Error;
type index$i_InsufficientFeeError = InsufficientFeeError;
declare const index$i_InsufficientFeeError: typeof InsufficientFeeError;
type index$i_InvalidAccountLengthError = InvalidAccountLengthError;
declare const index$i_InvalidAccountLengthError: typeof InvalidAccountLengthError;
type index$i_InvalidBpsError = InvalidBpsError;
declare const index$i_InvalidBpsError: typeof InvalidBpsError;
type index$i_InvalidConfigTypeError = InvalidConfigTypeError;
declare const index$i_InvalidConfigTypeError: typeof InvalidConfigTypeError;
type index$i_InvalidConfirmationError = InvalidConfirmationError;
declare const index$i_InvalidConfirmationError: typeof InvalidConfirmationError;
type index$i_InvalidConfirmationsError = InvalidConfirmationsError;
declare const index$i_InvalidConfirmationsError: typeof InvalidConfirmationsError;
type index$i_InvalidDvnError = InvalidDvnError;
declare const index$i_InvalidDvnError: typeof InvalidDvnError;
type index$i_InvalidDvnProgramError = InvalidDvnProgramError;
declare const index$i_InvalidDvnProgramError: typeof InvalidDvnProgramError;
type index$i_InvalidEidError = InvalidEidError;
declare const index$i_InvalidEidError: typeof InvalidEidError;
type index$i_InvalidExecutorError = InvalidExecutorError;
declare const index$i_InvalidExecutorError: typeof InvalidExecutorError;
type index$i_InvalidExecutorProgramError = InvalidExecutorProgramError;
declare const index$i_InvalidExecutorProgramError: typeof InvalidExecutorProgramError;
type index$i_InvalidLzTokenMintError = InvalidLzTokenMintError;
declare const index$i_InvalidLzTokenMintError: typeof InvalidLzTokenMintError;
type index$i_InvalidOptionTypeError = InvalidOptionTypeError;
declare const index$i_InvalidOptionTypeError: typeof InvalidOptionTypeError;
type index$i_InvalidOptionalDVNCountError = InvalidOptionalDVNCountError;
declare const index$i_InvalidOptionalDVNCountError: typeof InvalidOptionalDVNCountError;
type index$i_InvalidOptionalDVNThresholdError = InvalidOptionalDVNThresholdError;
declare const index$i_InvalidOptionalDVNThresholdError: typeof InvalidOptionalDVNThresholdError;
type index$i_InvalidPacketVersionError = InvalidPacketVersionError;
declare const index$i_InvalidPacketVersionError: typeof InvalidPacketVersionError;
type index$i_InvalidPayerError = InvalidPayerError;
declare const index$i_InvalidPayerError: typeof InvalidPayerError;
type index$i_InvalidRequiredDVNCountError = InvalidRequiredDVNCountError;
declare const index$i_InvalidRequiredDVNCountError: typeof InvalidRequiredDVNCountError;
type index$i_InvalidTreasuryError = InvalidTreasuryError;
declare const index$i_InvalidTreasuryError: typeof InvalidTreasuryError;
type index$i_InvalidTreasuryFeeCapError = InvalidTreasuryFeeCapError;
declare const index$i_InvalidTreasuryFeeCapError: typeof InvalidTreasuryFeeCapError;
type index$i_InvalidType1SizeError = InvalidType1SizeError;
declare const index$i_InvalidType1SizeError: typeof InvalidType1SizeError;
type index$i_InvalidType2SizeError = InvalidType2SizeError;
declare const index$i_InvalidType2SizeError: typeof InvalidType2SizeError;
type index$i_InvalidWorkerIdError = InvalidWorkerIdError;
declare const index$i_InvalidWorkerIdError: typeof InvalidWorkerIdError;
type index$i_LzTokenUnavailableError = LzTokenUnavailableError;
declare const index$i_LzTokenUnavailableError: typeof LzTokenUnavailableError;
type index$i_NonSignerError = NonSignerError;
declare const index$i_NonSignerError: typeof NonSignerError;
type index$i_UnsortedError = UnsortedError;
declare const index$i_UnsortedError: typeof UnsortedError;
type index$i_VerifyingError = VerifyingError;
declare const index$i_VerifyingError: typeof VerifyingError;
type index$i_ZeroMessageSizeError = ZeroMessageSizeError;
declare const index$i_ZeroMessageSizeError: typeof ZeroMessageSizeError;
declare namespace index$i {
  export { index$i_AtLeastOneDVNError as AtLeastOneDVNError, index$i_ExceededMaxMessageSizeError as ExceededMaxMessageSizeError, index$i_ExceededU128Error as ExceededU128Error, index$i_InsufficientFeeError as InsufficientFeeError, index$i_InvalidAccountLengthError as InvalidAccountLengthError, InvalidAmountError$1 as InvalidAmountError, index$i_InvalidBpsError as InvalidBpsError, index$i_InvalidConfigTypeError as InvalidConfigTypeError, index$i_InvalidConfirmationError as InvalidConfirmationError, index$i_InvalidConfirmationsError as InvalidConfirmationsError, index$i_InvalidDvnError as InvalidDvnError, index$i_InvalidDvnProgramError as InvalidDvnProgramError, index$i_InvalidEidError as InvalidEidError, index$i_InvalidExecutorError as InvalidExecutorError, index$i_InvalidExecutorProgramError as InvalidExecutorProgramError, index$i_InvalidLzTokenMintError as InvalidLzTokenMintError, index$i_InvalidOptionTypeError as InvalidOptionTypeError, index$i_InvalidOptionalDVNCountError as InvalidOptionalDVNCountError, index$i_InvalidOptionalDVNThresholdError as InvalidOptionalDVNThresholdError, index$i_InvalidPacketVersionError as InvalidPacketVersionError, index$i_InvalidPayerError as InvalidPayerError, index$i_InvalidRequiredDVNCountError as InvalidRequiredDVNCountError, index$i_InvalidTreasuryError as InvalidTreasuryError, index$i_InvalidTreasuryFeeCapError as InvalidTreasuryFeeCapError, index$i_InvalidType1SizeError as InvalidType1SizeError, index$i_InvalidType2SizeError as InvalidType2SizeError, index$i_InvalidWorkerIdError as InvalidWorkerIdError, index$i_LzTokenUnavailableError as LzTokenUnavailableError, index$i_NonSignerError as NonSignerError, UnauthorizedError$1 as UnauthorizedError, index$i_UnsortedError as UnsortedError, index$i_VerifyingError as VerifyingError, index$i_ZeroMessageSizeError as ZeroMessageSizeError, errorFromCode$3 as errorFromCode, errorFromName$3 as errorFromName };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type AdminTransferredEvent = {
    newAdmin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const adminTransferredEventBeet: beet.BeetArgsStruct<AdminTransferredEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link Config} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link Config} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type ConfigRecord = {
    SendUln: {
        fields: [UlnConfig$1];
    };
    ReceiveUln: {
        fields: [UlnConfig$1];
    };
    Executor: {
        fields: [ExecutorConfig$1];
    };
};
/**
 * Union type respresenting the Config data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isConfig*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type Config = beet.DataEnumKeyAsKind<ConfigRecord>;
declare const isConfigSendUln: (x: Config) => x is {
    __kind: "SendUln";
} & Omit<{
    fields: [UlnConfig$1];
}, "void"> & {
    __kind: 'SendUln';
};
declare const isConfigReceiveUln: (x: Config) => x is {
    __kind: "ReceiveUln";
} & Omit<{
    fields: [UlnConfig$1];
}, "void"> & {
    __kind: 'ReceiveUln';
};
declare const isConfigExecutor: (x: Config) => x is {
    __kind: "Executor";
} & Omit<{
    fields: [ExecutorConfig$1];
}, "void"> & {
    __kind: 'Executor';
};
/**
 * @category userTypes
 * @category generated
 */
declare const configBeet: beet.FixableBeet<Config, Config>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ConfigSetEvent = {
    oapp: web3.PublicKey;
    eid: number;
    config: Config;
};
/**
 * @category userTypes
 * @category generated
 */
declare const configSetEventBeet: beet.FixableBeetArgsStruct<ConfigSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DefaultConfigSetEvent = {
    eid: number;
    sendUlnConfig: beet.COption<UlnConfig$1>;
    receiveUlnConfig: beet.COption<UlnConfig$1>;
    executorConfig: beet.COption<ExecutorConfig$1>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const defaultConfigSetEventBeet: beet.FixableBeetArgsStruct<DefaultConfigSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WorkerFee = {
    worker: web3.PublicKey;
    fee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const workerFeeBeet: beet.BeetArgsStruct<WorkerFee>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TreasuryFee = {
    treasury: web3.PublicKey;
    fee: beet.bignum;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const treasuryFeeBeet: beet.BeetArgsStruct<TreasuryFee>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FeesPaidEvent = {
    executor: WorkerFee;
    dvns: WorkerFee[];
    treasury: beet.COption<TreasuryFee>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const feesPaidEventBeet: beet.FixableBeetArgsStruct<FeesPaidEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PayloadVerifiedEvent = {
    dvn: web3.PublicKey;
    header: number[];
    confirmations: beet.bignum;
    proofHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const payloadVerifiedEventBeet: beet.BeetArgsStruct<PayloadVerifiedEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type RentWithdrawnEvent = {
    receiver: web3.PublicKey;
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const rentWithdrawnEventBeet: beet.BeetArgsStruct<RentWithdrawnEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TreasurySetEvent = {
    treasury: beet.COption<Treasury>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const treasurySetEventBeet: beet.FixableBeetArgsStruct<TreasurySetEvent>;

type index$h_AdminTransferredEvent = AdminTransferredEvent;
type index$h_ConfigSetEvent = ConfigSetEvent;
type index$h_DefaultConfigSetEvent = DefaultConfigSetEvent;
type index$h_FeesPaidEvent = FeesPaidEvent;
type index$h_PayloadVerifiedEvent = PayloadVerifiedEvent;
type index$h_RentWithdrawnEvent = RentWithdrawnEvent;
type index$h_TreasurySetEvent = TreasurySetEvent;
declare const index$h_adminTransferredEventBeet: typeof adminTransferredEventBeet;
declare const index$h_configSetEventBeet: typeof configSetEventBeet;
declare const index$h_defaultConfigSetEventBeet: typeof defaultConfigSetEventBeet;
declare const index$h_feesPaidEventBeet: typeof feesPaidEventBeet;
declare const index$h_payloadVerifiedEventBeet: typeof payloadVerifiedEventBeet;
declare const index$h_rentWithdrawnEventBeet: typeof rentWithdrawnEventBeet;
declare const index$h_treasurySetEventBeet: typeof treasurySetEventBeet;
declare namespace index$h {
  export { type index$h_AdminTransferredEvent as AdminTransferredEvent, type index$h_ConfigSetEvent as ConfigSetEvent, type index$h_DefaultConfigSetEvent as DefaultConfigSetEvent, type index$h_FeesPaidEvent as FeesPaidEvent, type index$h_PayloadVerifiedEvent as PayloadVerifiedEvent, type index$h_RentWithdrawnEvent as RentWithdrawnEvent, type index$h_TreasurySetEvent as TreasurySetEvent, index$h_adminTransferredEventBeet as adminTransferredEventBeet, index$h_configSetEventBeet as configSetEventBeet, index$h_defaultConfigSetEventBeet as defaultConfigSetEventBeet, index$h_feesPaidEventBeet as feesPaidEventBeet, index$h_payloadVerifiedEventBeet as payloadVerifiedEventBeet, index$h_rentWithdrawnEventBeet as rentWithdrawnEventBeet, index$h_treasurySetEventBeet as treasurySetEventBeet };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CommitVerificationParams = {
    packetHeader: number[];
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const commitVerificationParamsBeet: beet.BeetArgsStruct<CommitVerificationParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CommitVerification
 * @category generated
 */
type CommitVerificationInstructionArgs = {
    params: CommitVerificationParams;
};
/**
 * @category Instructions
 * @category CommitVerification
 * @category generated
 */
declare const commitVerificationStruct: beet.BeetArgsStruct<CommitVerificationInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _commitVerification_ instruction
 *
 * @property [] receiveConfig
 * @property [] defaultReceiveConfig
 * @property [_writable_] uln
 * @category Instructions
 * @category CommitVerification
 * @category generated
 */
type CommitVerificationInstructionAccounts = {
    receiveConfig: web3.PublicKey;
    defaultReceiveConfig: web3.PublicKey;
    uln: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const commitVerificationInstructionDiscriminator: number[];
/**
 * Creates a _CommitVerification_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CommitVerification
 * @category generated
 */
declare function createCommitVerificationInstruction(accounts: CommitVerificationInstructionAccounts, args: CommitVerificationInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _CommitVerification_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CommitVerification
 * @category generated
 */
declare function createCommitVerificationInstructionAccounts(accounts: CommitVerificationInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitConfigParams = {
    oapp: web3.PublicKey;
    eid: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initConfigParamsBeet: beet.BeetArgsStruct<InitConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionArgs = {
    params: InitConfigParams;
};
/**
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare const initConfigStruct: beet.BeetArgsStruct<InitConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initConfig_ instruction
 *
 * @property [**signer**] endpoint
 * @property [_writable_, **signer**] payer
 * @property [] uln
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
type InitConfigInstructionAccounts = {
    endpoint: web3.PublicKey;
    payer: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initConfigInstructionDiscriminator: number[];
/**
 * Creates a _InitConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstruction(accounts: InitConfigInstructionAccounts, args: InitConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitConfig
 * @category generated
 */
declare function createInitConfigInstructionAccounts(accounts: InitConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitDefaultConfigParams = {
    eid: number;
    sendUlnConfig: UlnConfig$1;
    receiveUlnConfig: UlnConfig$1;
    executorConfig: ExecutorConfig$1;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initDefaultConfigParamsBeet: beet.FixableBeetArgsStruct<InitDefaultConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
type InitDefaultConfigInstructionArgs = {
    params: InitDefaultConfigParams;
};
/**
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare const initDefaultConfigStruct: beet.FixableBeetArgsStruct<InitDefaultConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initDefaultConfig_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [] uln
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
type InitDefaultConfigInstructionAccounts = {
    admin: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initDefaultConfigInstructionDiscriminator: number[];
/**
 * Creates a _InitDefaultConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare function createInitDefaultConfigInstruction(accounts: InitDefaultConfigInstructionAccounts, args: InitDefaultConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitDefaultConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitDefaultConfig
 * @category generated
 */
declare function createInitDefaultConfigInstructionAccounts(accounts: InitDefaultConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitUlnParams = {
    eid: number;
    endpoint: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initUlnParamsBeet: beet.BeetArgsStruct<InitUlnParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitUln
 * @category generated
 */
type InitUlnInstructionArgs = {
    params: InitUlnParams;
};
/**
 * @category Instructions
 * @category InitUln
 * @category generated
 */
declare const initUlnStruct: beet.BeetArgsStruct<InitUlnInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initUln_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] uln
 * @category Instructions
 * @category InitUln
 * @category generated
 */
type InitUlnInstructionAccounts = {
    payer: web3.PublicKey;
    uln: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initUlnInstructionDiscriminator: number[];
/**
 * Creates a _InitUln_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitUln
 * @category generated
 */
declare function createInitUlnInstruction(accounts: InitUlnInstructionAccounts, args: InitUlnInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitUln_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitUln
 * @category generated
 */
declare function createInitUlnInstructionAccounts(accounts: InitUlnInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitVerifyParams = {
    packetHeader: number[];
    payloadHash: number[];
    dvn: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initVerifyParamsBeet: beet.BeetArgsStruct<InitVerifyParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
type InitVerifyInstructionArgs = {
    params: InitVerifyParams;
};
/**
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare const initVerifyStruct: beet.BeetArgsStruct<InitVerifyInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initVerify_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] confirmations
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
type InitVerifyInstructionAccounts = {
    payer: web3.PublicKey;
    confirmations: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initVerifyInstructionDiscriminator: number[];
/**
 * Creates a _InitVerify_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare function createInitVerifyInstruction(accounts: InitVerifyInstructionAccounts, args: InitVerifyInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitVerify_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitVerify
 * @category generated
 */
declare function createInitVerifyInstructionAccounts(accounts: InitVerifyInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Packet = {
    nonce: beet.bignum;
    srcEid: number;
    sender: web3.PublicKey;
    dstEid: number;
    receiver: number[];
    guid: number[];
    message: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const packetBeet: beet.FixableBeetArgsStruct<Packet>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteParams$1 = {
    packet: Packet;
    options: Uint8Array;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteParamsBeet$1: beet.FixableBeetArgsStruct<QuoteParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionArgs$1 = {
    params: QuoteParams$1;
};
/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare const quoteStruct$1: beet.FixableBeetArgsStruct<QuoteInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quote_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] uln
 * @property [] sendConfig
 * @property [] defaultSendConfig
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionAccounts$1 = {
    endpoint: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    defaultSendConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteInstructionDiscriminator$1: number[];
/**
 * Creates a _Quote_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstruction$1(accounts: QuoteInstructionAccounts$1, args: QuoteInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Quote_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstructionAccounts$1(accounts: QuoteInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendParams$1 = {
    packet: Packet;
    options: Uint8Array;
    nativeFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendParamsBeet$1: beet.FixableBeetArgsStruct<SendParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionArgs$1 = {
    params: SendParams$1;
};
/**
 * @category Instructions
 * @category Send
 * @category generated
 */
declare const sendStruct$1: beet.FixableBeetArgsStruct<SendInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _send_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] uln
 * @property [] sendConfig
 * @property [] defaultSendConfig
 * @property [_writable_, **signer**] payer
 * @property [_writable_] treasury (optional)
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionAccounts$1 = {
    endpoint: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    defaultSendConfig: web3.PublicKey;
    payer: web3.PublicKey;
    treasury?: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendInstructionDiscriminator$1: number[];
/**
 * Creates a _Send_ instruction.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstruction$1(accounts: SendInstructionAccounts$1, args: SendInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Send_ instructionAccounts.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstructionAccounts$1(accounts: SendInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendWithLzTokenParams = {
    packet: Packet;
    options: Uint8Array;
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
    lzTokenMint: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendWithLzTokenParamsBeet: beet.FixableBeetArgsStruct<SendWithLzTokenParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
type SendWithLzTokenInstructionArgs = {
    params: SendWithLzTokenParams;
};
/**
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare const sendWithLzTokenStruct: beet.FixableBeetArgsStruct<SendWithLzTokenInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _sendWithLzToken_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] uln
 * @property [] sendConfig
 * @property [] defaultSendConfig
 * @property [_writable_, **signer**] payer
 * @property [_writable_] lzTokenSource
 * @property [_writable_] lzTokenTreasury
 * @property [] lzTokenMint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
type SendWithLzTokenInstructionAccounts = {
    endpoint: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    defaultSendConfig: web3.PublicKey;
    payer: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    lzTokenSource: web3.PublicKey;
    lzTokenTreasury: web3.PublicKey;
    lzTokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendWithLzTokenInstructionDiscriminator: number[];
/**
 * Creates a _SendWithLzToken_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare function createSendWithLzTokenInstruction(accounts: SendWithLzTokenInstructionAccounts, args: SendWithLzTokenInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SendWithLzToken_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SendWithLzToken
 * @category generated
 */
declare function createSendWithLzTokenInstructionAccounts(accounts: SendWithLzTokenInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetConfigParams$1 = {
    oapp: web3.PublicKey;
    eid: number;
    configType: number;
    config: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setConfigParamsBeet$1: beet.FixableBeetArgsStruct<SetConfigParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionArgs$1 = {
    params: SetConfigParams$1;
};
/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare const setConfigStruct$1: beet.FixableBeetArgsStruct<SetConfigInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setConfig_ instruction
 *
 * @property [**signer**] endpoint
 * @property [] uln
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @property [] defaultSendConfig
 * @property [] defaultReceiveConfig
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionAccounts$1 = {
    endpoint: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    defaultSendConfig: web3.PublicKey;
    defaultReceiveConfig: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setConfigInstructionDiscriminator$1: number[];
/**
 * Creates a _SetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstruction$1(accounts: SetConfigInstructionAccounts$1, args: SetConfigInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstructionAccounts$1(accounts: SetConfigInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDefaultConfigParams = {
    eid: number;
    sendUlnConfig: beet.COption<UlnConfig$1>;
    receiveUlnConfig: beet.COption<UlnConfig$1>;
    executorConfig: beet.COption<ExecutorConfig$1>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDefaultConfigParamsBeet: beet.FixableBeetArgsStruct<SetDefaultConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
type SetDefaultConfigInstructionArgs = {
    params: SetDefaultConfigParams;
};
/**
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare const setDefaultConfigStruct: beet.FixableBeetArgsStruct<SetDefaultConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDefaultConfig_ instruction
 *
 * @property [**signer**] admin
 * @property [] uln
 * @property [_writable_] sendConfig
 * @property [_writable_] receiveConfig
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
type SetDefaultConfigInstructionAccounts = {
    admin: web3.PublicKey;
    uln: web3.PublicKey;
    sendConfig: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDefaultConfigInstructionDiscriminator: number[];
/**
 * Creates a _SetDefaultConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare function createSetDefaultConfigInstruction(accounts: SetDefaultConfigInstructionAccounts, args: SetDefaultConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDefaultConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDefaultConfig
 * @category generated
 */
declare function createSetDefaultConfigInstructionAccounts(accounts: SetDefaultConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetTreasuryParams = {
    treasury: beet.COption<Treasury>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setTreasuryParamsBeet: beet.FixableBeetArgsStruct<SetTreasuryParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetTreasury
 * @category generated
 */
type SetTreasuryInstructionArgs = {
    params: SetTreasuryParams;
};
/**
 * @category Instructions
 * @category SetTreasury
 * @category generated
 */
declare const setTreasuryStruct: beet.FixableBeetArgsStruct<SetTreasuryInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setTreasury_ instruction
 *
 * @property [**signer**] signer
 * @property [_writable_] uln
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetTreasury
 * @category generated
 */
type SetTreasuryInstructionAccounts = {
    signer: web3.PublicKey;
    uln: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setTreasuryInstructionDiscriminator: number[];
/**
 * Creates a _SetTreasury_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetTreasury
 * @category generated
 */
declare function createSetTreasuryInstruction(accounts: SetTreasuryInstructionAccounts, args: SetTreasuryInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetTreasury_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetTreasury
 * @category generated
 */
declare function createSetTreasuryInstructionAccounts(accounts: SetTreasuryInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransferAdminParams$2 = {
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transferAdminParamsBeet$2: beet.BeetArgsStruct<TransferAdminParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionArgs$2 = {
    params: TransferAdminParams$2;
};
/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare const transferAdminStruct$2: beet.BeetArgsStruct<TransferAdminInstructionArgs$2 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _transferAdmin_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] uln
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionAccounts$2 = {
    admin: web3.PublicKey;
    uln: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const transferAdminInstructionDiscriminator$2: number[];
/**
 * Creates a _TransferAdmin_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstruction$2(accounts: TransferAdminInstructionAccounts$2, args: TransferAdminInstructionArgs$2, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _TransferAdmin_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstructionAccounts$2(accounts: TransferAdminInstructionAccounts$2, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type VerifyParams = {
    packetHeader: number[];
    payloadHash: number[];
    confirmations: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const verifyParamsBeet: beet.BeetArgsStruct<VerifyParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Verify
 * @category generated
 */
type VerifyInstructionArgs = {
    params: VerifyParams;
};
/**
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare const verifyStruct: beet.BeetArgsStruct<VerifyInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _verify_ instruction
 *
 * @property [**signer**] dvn
 * @property [_writable_] confirmations
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Verify
 * @category generated
 */
type VerifyInstructionAccounts = {
    dvn: web3.PublicKey;
    confirmations: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const verifyInstructionDiscriminator: number[];
/**
 * Creates a _Verify_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare function createVerifyInstruction(accounts: VerifyInstructionAccounts, args: VerifyInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Verify_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Verify
 * @category generated
 */
declare function createVerifyInstructionAccounts(accounts: VerifyInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Version
 * @category generated
 */
declare const versionStruct$2: beet.BeetArgsStruct<{
    instructionDiscriminator: number[];
}>;
declare const versionInstructionDiscriminator$2: number[];
/**
 * Creates a _Version_ instruction.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstruction$2(programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Version_ instructionAccounts.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstructionAccounts$2(programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawRentParams = {
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawRentParamsBeet: beet.BeetArgsStruct<WithdrawRentParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
type WithdrawRentInstructionArgs = {
    params: WithdrawRentParams;
};
/**
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare const withdrawRentStruct: beet.BeetArgsStruct<WithdrawRentInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _withdrawRent_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] uln
 * @property [_writable_] receiver
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
type WithdrawRentInstructionAccounts = {
    admin: web3.PublicKey;
    uln: web3.PublicKey;
    receiver: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const withdrawRentInstructionDiscriminator: number[];
/**
 * Creates a _WithdrawRent_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare function createWithdrawRentInstruction(accounts: WithdrawRentInstructionAccounts, args: WithdrawRentInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _WithdrawRent_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category WithdrawRent
 * @category generated
 */
declare function createWithdrawRentInstructionAccounts(accounts: WithdrawRentInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

type index$g_CommitVerificationInstructionAccounts = CommitVerificationInstructionAccounts;
type index$g_CommitVerificationInstructionArgs = CommitVerificationInstructionArgs;
type index$g_InitConfigInstructionAccounts = InitConfigInstructionAccounts;
type index$g_InitConfigInstructionArgs = InitConfigInstructionArgs;
type index$g_InitDefaultConfigInstructionAccounts = InitDefaultConfigInstructionAccounts;
type index$g_InitDefaultConfigInstructionArgs = InitDefaultConfigInstructionArgs;
type index$g_InitUlnInstructionAccounts = InitUlnInstructionAccounts;
type index$g_InitUlnInstructionArgs = InitUlnInstructionArgs;
type index$g_InitVerifyInstructionAccounts = InitVerifyInstructionAccounts;
type index$g_InitVerifyInstructionArgs = InitVerifyInstructionArgs;
type index$g_SendWithLzTokenInstructionAccounts = SendWithLzTokenInstructionAccounts;
type index$g_SendWithLzTokenInstructionArgs = SendWithLzTokenInstructionArgs;
type index$g_SetDefaultConfigInstructionAccounts = SetDefaultConfigInstructionAccounts;
type index$g_SetDefaultConfigInstructionArgs = SetDefaultConfigInstructionArgs;
type index$g_SetTreasuryInstructionAccounts = SetTreasuryInstructionAccounts;
type index$g_SetTreasuryInstructionArgs = SetTreasuryInstructionArgs;
type index$g_VerifyInstructionAccounts = VerifyInstructionAccounts;
type index$g_VerifyInstructionArgs = VerifyInstructionArgs;
type index$g_WithdrawRentInstructionAccounts = WithdrawRentInstructionAccounts;
type index$g_WithdrawRentInstructionArgs = WithdrawRentInstructionArgs;
declare const index$g_commitVerificationInstructionDiscriminator: typeof commitVerificationInstructionDiscriminator;
declare const index$g_commitVerificationStruct: typeof commitVerificationStruct;
declare const index$g_createCommitVerificationInstruction: typeof createCommitVerificationInstruction;
declare const index$g_createCommitVerificationInstructionAccounts: typeof createCommitVerificationInstructionAccounts;
declare const index$g_createInitConfigInstruction: typeof createInitConfigInstruction;
declare const index$g_createInitConfigInstructionAccounts: typeof createInitConfigInstructionAccounts;
declare const index$g_createInitDefaultConfigInstruction: typeof createInitDefaultConfigInstruction;
declare const index$g_createInitDefaultConfigInstructionAccounts: typeof createInitDefaultConfigInstructionAccounts;
declare const index$g_createInitUlnInstruction: typeof createInitUlnInstruction;
declare const index$g_createInitUlnInstructionAccounts: typeof createInitUlnInstructionAccounts;
declare const index$g_createInitVerifyInstruction: typeof createInitVerifyInstruction;
declare const index$g_createInitVerifyInstructionAccounts: typeof createInitVerifyInstructionAccounts;
declare const index$g_createSendWithLzTokenInstruction: typeof createSendWithLzTokenInstruction;
declare const index$g_createSendWithLzTokenInstructionAccounts: typeof createSendWithLzTokenInstructionAccounts;
declare const index$g_createSetDefaultConfigInstruction: typeof createSetDefaultConfigInstruction;
declare const index$g_createSetDefaultConfigInstructionAccounts: typeof createSetDefaultConfigInstructionAccounts;
declare const index$g_createSetTreasuryInstruction: typeof createSetTreasuryInstruction;
declare const index$g_createSetTreasuryInstructionAccounts: typeof createSetTreasuryInstructionAccounts;
declare const index$g_createVerifyInstruction: typeof createVerifyInstruction;
declare const index$g_createVerifyInstructionAccounts: typeof createVerifyInstructionAccounts;
declare const index$g_createWithdrawRentInstruction: typeof createWithdrawRentInstruction;
declare const index$g_createWithdrawRentInstructionAccounts: typeof createWithdrawRentInstructionAccounts;
declare const index$g_initConfigInstructionDiscriminator: typeof initConfigInstructionDiscriminator;
declare const index$g_initConfigStruct: typeof initConfigStruct;
declare const index$g_initDefaultConfigInstructionDiscriminator: typeof initDefaultConfigInstructionDiscriminator;
declare const index$g_initDefaultConfigStruct: typeof initDefaultConfigStruct;
declare const index$g_initUlnInstructionDiscriminator: typeof initUlnInstructionDiscriminator;
declare const index$g_initUlnStruct: typeof initUlnStruct;
declare const index$g_initVerifyInstructionDiscriminator: typeof initVerifyInstructionDiscriminator;
declare const index$g_initVerifyStruct: typeof initVerifyStruct;
declare const index$g_sendWithLzTokenInstructionDiscriminator: typeof sendWithLzTokenInstructionDiscriminator;
declare const index$g_sendWithLzTokenStruct: typeof sendWithLzTokenStruct;
declare const index$g_setDefaultConfigInstructionDiscriminator: typeof setDefaultConfigInstructionDiscriminator;
declare const index$g_setDefaultConfigStruct: typeof setDefaultConfigStruct;
declare const index$g_setTreasuryInstructionDiscriminator: typeof setTreasuryInstructionDiscriminator;
declare const index$g_setTreasuryStruct: typeof setTreasuryStruct;
declare const index$g_verifyInstructionDiscriminator: typeof verifyInstructionDiscriminator;
declare const index$g_verifyStruct: typeof verifyStruct;
declare const index$g_withdrawRentInstructionDiscriminator: typeof withdrawRentInstructionDiscriminator;
declare const index$g_withdrawRentStruct: typeof withdrawRentStruct;
declare namespace index$g {
  export { type index$g_CommitVerificationInstructionAccounts as CommitVerificationInstructionAccounts, type index$g_CommitVerificationInstructionArgs as CommitVerificationInstructionArgs, type index$g_InitConfigInstructionAccounts as InitConfigInstructionAccounts, type index$g_InitConfigInstructionArgs as InitConfigInstructionArgs, type index$g_InitDefaultConfigInstructionAccounts as InitDefaultConfigInstructionAccounts, type index$g_InitDefaultConfigInstructionArgs as InitDefaultConfigInstructionArgs, type index$g_InitUlnInstructionAccounts as InitUlnInstructionAccounts, type index$g_InitUlnInstructionArgs as InitUlnInstructionArgs, type index$g_InitVerifyInstructionAccounts as InitVerifyInstructionAccounts, type index$g_InitVerifyInstructionArgs as InitVerifyInstructionArgs, type QuoteInstructionAccounts$1 as QuoteInstructionAccounts, type QuoteInstructionArgs$1 as QuoteInstructionArgs, type SendInstructionAccounts$1 as SendInstructionAccounts, type SendInstructionArgs$1 as SendInstructionArgs, type index$g_SendWithLzTokenInstructionAccounts as SendWithLzTokenInstructionAccounts, type index$g_SendWithLzTokenInstructionArgs as SendWithLzTokenInstructionArgs, type SetConfigInstructionAccounts$1 as SetConfigInstructionAccounts, type SetConfigInstructionArgs$1 as SetConfigInstructionArgs, type index$g_SetDefaultConfigInstructionAccounts as SetDefaultConfigInstructionAccounts, type index$g_SetDefaultConfigInstructionArgs as SetDefaultConfigInstructionArgs, type index$g_SetTreasuryInstructionAccounts as SetTreasuryInstructionAccounts, type index$g_SetTreasuryInstructionArgs as SetTreasuryInstructionArgs, type TransferAdminInstructionAccounts$2 as TransferAdminInstructionAccounts, type TransferAdminInstructionArgs$2 as TransferAdminInstructionArgs, type index$g_VerifyInstructionAccounts as VerifyInstructionAccounts, type index$g_VerifyInstructionArgs as VerifyInstructionArgs, type index$g_WithdrawRentInstructionAccounts as WithdrawRentInstructionAccounts, type index$g_WithdrawRentInstructionArgs as WithdrawRentInstructionArgs, index$g_commitVerificationInstructionDiscriminator as commitVerificationInstructionDiscriminator, index$g_commitVerificationStruct as commitVerificationStruct, index$g_createCommitVerificationInstruction as createCommitVerificationInstruction, index$g_createCommitVerificationInstructionAccounts as createCommitVerificationInstructionAccounts, index$g_createInitConfigInstruction as createInitConfigInstruction, index$g_createInitConfigInstructionAccounts as createInitConfigInstructionAccounts, index$g_createInitDefaultConfigInstruction as createInitDefaultConfigInstruction, index$g_createInitDefaultConfigInstructionAccounts as createInitDefaultConfigInstructionAccounts, index$g_createInitUlnInstruction as createInitUlnInstruction, index$g_createInitUlnInstructionAccounts as createInitUlnInstructionAccounts, index$g_createInitVerifyInstruction as createInitVerifyInstruction, index$g_createInitVerifyInstructionAccounts as createInitVerifyInstructionAccounts, createQuoteInstruction$1 as createQuoteInstruction, createQuoteInstructionAccounts$1 as createQuoteInstructionAccounts, createSendInstruction$1 as createSendInstruction, createSendInstructionAccounts$1 as createSendInstructionAccounts, index$g_createSendWithLzTokenInstruction as createSendWithLzTokenInstruction, index$g_createSendWithLzTokenInstructionAccounts as createSendWithLzTokenInstructionAccounts, createSetConfigInstruction$1 as createSetConfigInstruction, createSetConfigInstructionAccounts$1 as createSetConfigInstructionAccounts, index$g_createSetDefaultConfigInstruction as createSetDefaultConfigInstruction, index$g_createSetDefaultConfigInstructionAccounts as createSetDefaultConfigInstructionAccounts, index$g_createSetTreasuryInstruction as createSetTreasuryInstruction, index$g_createSetTreasuryInstructionAccounts as createSetTreasuryInstructionAccounts, createTransferAdminInstruction$2 as createTransferAdminInstruction, createTransferAdminInstructionAccounts$2 as createTransferAdminInstructionAccounts, index$g_createVerifyInstruction as createVerifyInstruction, index$g_createVerifyInstructionAccounts as createVerifyInstructionAccounts, createVersionInstruction$2 as createVersionInstruction, createVersionInstructionAccounts$2 as createVersionInstructionAccounts, index$g_createWithdrawRentInstruction as createWithdrawRentInstruction, index$g_createWithdrawRentInstructionAccounts as createWithdrawRentInstructionAccounts, index$g_initConfigInstructionDiscriminator as initConfigInstructionDiscriminator, index$g_initConfigStruct as initConfigStruct, index$g_initDefaultConfigInstructionDiscriminator as initDefaultConfigInstructionDiscriminator, index$g_initDefaultConfigStruct as initDefaultConfigStruct, index$g_initUlnInstructionDiscriminator as initUlnInstructionDiscriminator, index$g_initUlnStruct as initUlnStruct, index$g_initVerifyInstructionDiscriminator as initVerifyInstructionDiscriminator, index$g_initVerifyStruct as initVerifyStruct, quoteInstructionDiscriminator$1 as quoteInstructionDiscriminator, quoteStruct$1 as quoteStruct, sendInstructionDiscriminator$1 as sendInstructionDiscriminator, sendStruct$1 as sendStruct, index$g_sendWithLzTokenInstructionDiscriminator as sendWithLzTokenInstructionDiscriminator, index$g_sendWithLzTokenStruct as sendWithLzTokenStruct, setConfigInstructionDiscriminator$1 as setConfigInstructionDiscriminator, setConfigStruct$1 as setConfigStruct, index$g_setDefaultConfigInstructionDiscriminator as setDefaultConfigInstructionDiscriminator, index$g_setDefaultConfigStruct as setDefaultConfigStruct, index$g_setTreasuryInstructionDiscriminator as setTreasuryInstructionDiscriminator, index$g_setTreasuryStruct as setTreasuryStruct, transferAdminInstructionDiscriminator$2 as transferAdminInstructionDiscriminator, transferAdminStruct$2 as transferAdminStruct, index$g_verifyInstructionDiscriminator as verifyInstructionDiscriminator, index$g_verifyStruct as verifyStruct, versionInstructionDiscriminator$2 as versionInstructionDiscriminator, versionStruct$2 as versionStruct, index$g_withdrawRentInstructionDiscriminator as withdrawRentInstructionDiscriminator, index$g_withdrawRentStruct as withdrawRentStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingFee$1 = {
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingFeeBeet$1: beet.BeetArgsStruct<MessagingFee$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Version$1 = {
    major: beet.bignum;
    minor: number;
    endpointVersion: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const versionBeet$1: beet.BeetArgsStruct<Version$1>;

type index$f_CommitVerificationParams = CommitVerificationParams;
type index$f_Config = Config;
type index$f_ConfigRecord = ConfigRecord;
type index$f_InitConfigParams = InitConfigParams;
type index$f_InitDefaultConfigParams = InitDefaultConfigParams;
type index$f_InitUlnParams = InitUlnParams;
type index$f_InitVerifyParams = InitVerifyParams;
type index$f_LzTokenTreasury = LzTokenTreasury;
type index$f_Packet = Packet;
type index$f_SendWithLzTokenParams = SendWithLzTokenParams;
type index$f_SetDefaultConfigParams = SetDefaultConfigParams;
type index$f_SetTreasuryParams = SetTreasuryParams;
type index$f_Treasury = Treasury;
type index$f_TreasuryFee = TreasuryFee;
type index$f_VerifyParams = VerifyParams;
type index$f_WithdrawRentParams = WithdrawRentParams;
type index$f_WorkerFee = WorkerFee;
declare const index$f_commitVerificationParamsBeet: typeof commitVerificationParamsBeet;
declare const index$f_configBeet: typeof configBeet;
declare const index$f_initConfigParamsBeet: typeof initConfigParamsBeet;
declare const index$f_initDefaultConfigParamsBeet: typeof initDefaultConfigParamsBeet;
declare const index$f_initUlnParamsBeet: typeof initUlnParamsBeet;
declare const index$f_initVerifyParamsBeet: typeof initVerifyParamsBeet;
declare const index$f_isConfigExecutor: typeof isConfigExecutor;
declare const index$f_isConfigReceiveUln: typeof isConfigReceiveUln;
declare const index$f_isConfigSendUln: typeof isConfigSendUln;
declare const index$f_lzTokenTreasuryBeet: typeof lzTokenTreasuryBeet;
declare const index$f_packetBeet: typeof packetBeet;
declare const index$f_sendWithLzTokenParamsBeet: typeof sendWithLzTokenParamsBeet;
declare const index$f_setDefaultConfigParamsBeet: typeof setDefaultConfigParamsBeet;
declare const index$f_setTreasuryParamsBeet: typeof setTreasuryParamsBeet;
declare const index$f_treasuryBeet: typeof treasuryBeet;
declare const index$f_treasuryFeeBeet: typeof treasuryFeeBeet;
declare const index$f_verifyParamsBeet: typeof verifyParamsBeet;
declare const index$f_withdrawRentParamsBeet: typeof withdrawRentParamsBeet;
declare const index$f_workerFeeBeet: typeof workerFeeBeet;
declare namespace index$f {
  export { type index$f_CommitVerificationParams as CommitVerificationParams, type index$f_Config as Config, type index$f_ConfigRecord as ConfigRecord, type ExecutorConfig$1 as ExecutorConfig, type index$f_InitConfigParams as InitConfigParams, type index$f_InitDefaultConfigParams as InitDefaultConfigParams, type index$f_InitUlnParams as InitUlnParams, type index$f_InitVerifyParams as InitVerifyParams, type index$f_LzTokenTreasury as LzTokenTreasury, type MessagingFee$1 as MessagingFee, type index$f_Packet as Packet, type QuoteParams$1 as QuoteParams, type SendParams$1 as SendParams, type index$f_SendWithLzTokenParams as SendWithLzTokenParams, type SetConfigParams$1 as SetConfigParams, type index$f_SetDefaultConfigParams as SetDefaultConfigParams, type index$f_SetTreasuryParams as SetTreasuryParams, type TransferAdminParams$2 as TransferAdminParams, type index$f_Treasury as Treasury, type index$f_TreasuryFee as TreasuryFee, type UlnConfig$1 as UlnConfig, type index$f_VerifyParams as VerifyParams, type Version$1 as Version, type index$f_WithdrawRentParams as WithdrawRentParams, type index$f_WorkerFee as WorkerFee, index$f_commitVerificationParamsBeet as commitVerificationParamsBeet, index$f_configBeet as configBeet, executorConfigBeet$1 as executorConfigBeet, index$f_initConfigParamsBeet as initConfigParamsBeet, index$f_initDefaultConfigParamsBeet as initDefaultConfigParamsBeet, index$f_initUlnParamsBeet as initUlnParamsBeet, index$f_initVerifyParamsBeet as initVerifyParamsBeet, index$f_isConfigExecutor as isConfigExecutor, index$f_isConfigReceiveUln as isConfigReceiveUln, index$f_isConfigSendUln as isConfigSendUln, index$f_lzTokenTreasuryBeet as lzTokenTreasuryBeet, messagingFeeBeet$1 as messagingFeeBeet, index$f_packetBeet as packetBeet, quoteParamsBeet$1 as quoteParamsBeet, sendParamsBeet$1 as sendParamsBeet, index$f_sendWithLzTokenParamsBeet as sendWithLzTokenParamsBeet, setConfigParamsBeet$1 as setConfigParamsBeet, index$f_setDefaultConfigParamsBeet as setDefaultConfigParamsBeet, index$f_setTreasuryParamsBeet as setTreasuryParamsBeet, transferAdminParamsBeet$2 as transferAdminParamsBeet, index$f_treasuryBeet as treasuryBeet, index$f_treasuryFeeBeet as treasuryFeeBeet, ulnConfigBeet$1 as ulnConfigBeet, index$f_verifyParamsBeet as verifyParamsBeet, versionBeet$1 as versionBeet, index$f_withdrawRentParamsBeet as withdrawRentParamsBeet, index$f_workerFeeBeet as workerFeeBeet };
}

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS$4 = "7a4WjyR8VZ7yZz5XJAKm39BUGn5iT9CKcv2pmG9tdXVH";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$5: PublicKey;

interface MaxMessageSize {
    size: number;
    __kind: 'MaxMessageSize';
}
interface OutboundConfirmations {
    confirmations: number;
    __kind: 'OutboundConfirmations';
}
interface Executor$1 {
    executor: PublicKey;
    __kind: 'Executor';
}
interface InboundConfirmations {
    confirmations: number;
    __kind: 'InboundConfirmations';
}
interface Oracles {
    useCustomOracles: boolean;
    oracles: PublicKey[];
    __kind: 'Oracles';
}
interface OptionalOracles {
    useCustomOptionalOracles: boolean;
    optionalOracles: PublicKey[];
    threshold: number;
    __kind: 'OptionalOracles';
}
declare class Uln implements MessageLibInterface {
    program: PublicKey;
    deriver: UlnPDADeriver;
    eventAuthorityPDA: PublicKey;
    constructor(program: PublicKey);
    initUln(connection: Connection, payer: PublicKey, admin: PublicKey, endpointProgram: PublicKey, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    /**
     * before calling this function, you should call initUln to initialize the uln
     */
    initOrUpdateDefaultConfig(connection: Connection, admin: PublicKey, eid: number, sendUlnConfig: UlnConfig$1, receiveUlnConfig: UlnConfig$1, executorConfig: ExecutorConfig$1, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
    /**
     * before calling this function, you should call initUln to initialize the uln
     */
    setTreasury(admin: PublicKey, treasury: {
        admin: PublicKey;
        nativeReceiver: PublicKey;
        nativeFeeBps: number;
        lzToken: {
            receiver: PublicKey;
            fee: number;
        } | null;
    } | null): Promise<TransactionInstruction>;
    transferAdmin(connection: Connection, admin: PublicKey, newAdmin: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
    /**
     *
     * @param connection
     *
     * @param sender the oApp PDA
     * @param sendLibraryAuthority
     * @param dstEid
     * @param payInLzToken
     * @param commitment
     * @returns
     */
    getQuoteIXAccountMetaForCPI(connection: Connection, _payer: PublicKey, path: PacketPath, commitment?: Commitment): Promise<AccountMeta[]>;
    /***
     * Get the account meta of the send instruction for CPI(Cross-Program Invocation )
     */
    getSendIXAccountMetaForCPI(connection: Connection, payer: PublicKey, path: PacketPath, commitment?: Commitment): Promise<AccountMeta[]>;
    /***
     * Get all workers(executor&DVN)
     */
    getWorkerPrograms(connection: Connection, sender: PublicKey, eid: number, commitment?: Commitment | GetAccountInfoConfig): Promise<{
        executorProgram: PublicKey;
        dvnPrograms: PublicKey[];
    }>;
    initVerify(connection: Connection, payer: PublicKey, dvn: PublicKey, packetBytes: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction | null>;
    verify(dvn: PublicKey, packetBytes: Uint8Array, confirmations: number | string): TransactionInstruction;
    isDvnVerified(connection: Connection, endpointProgram: PublicKey, dvn: PublicKey, packetBytes: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
    commitVerification(connection: Connection, endpointProgram: PublicKey, packetBytes: Uint8Array): Promise<TransactionInstruction>;
    /***
     * Get the account meta of the send instruction for CPI(Cross-Program Invocation )
     */
    getInitConfigIXAccountMetaForCPI(payer: PublicKey, oappID: PublicKey, eid: number): Promise<AccountMeta[]>;
    static constructSetConfigData(configType: SetConfigType, configData: ExecutorConfig$1 | UlnConfig$1): Uint8Array;
    /**
     * @param oappID the oApp PDA
     *
     */
    getSetConfigIXAccountMetaForCPI(endpointProgram: PublicKey, oappID: PublicKey, eid: number): Promise<AccountMeta[]>;
    getSetting(connection: Connection, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<UlnSettings | null>;
    getDefaultSendConfigState(connection: Connection, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<SendConfig | null>;
    getSendConfigState(connection: Connection, sender: PublicKey, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<SendConfig | null>;
    getDefaultReceiveConfigState(connection: Connection, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<ReceiveConfig$1 | null>;
    getReceiveConfigState(connection: Connection, receiver: PublicKey, eid: number, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<ReceiveConfig$1 | null>;
}

type uln_AtLeastOneDVNError = AtLeastOneDVNError;
declare const uln_AtLeastOneDVNError: typeof AtLeastOneDVNError;
type uln_CommitVerificationInstructionAccounts = CommitVerificationInstructionAccounts;
type uln_CommitVerificationInstructionArgs = CommitVerificationInstructionArgs;
type uln_CommitVerificationParams = CommitVerificationParams;
type uln_Config = Config;
type uln_ConfigRecord = ConfigRecord;
type uln_Confirmations = Confirmations;
declare const uln_Confirmations: typeof Confirmations;
type uln_ConfirmationsArgs = ConfirmationsArgs;
type uln_ExceededMaxMessageSizeError = ExceededMaxMessageSizeError;
declare const uln_ExceededMaxMessageSizeError: typeof ExceededMaxMessageSizeError;
type uln_ExceededU128Error = ExceededU128Error;
declare const uln_ExceededU128Error: typeof ExceededU128Error;
type uln_InboundConfirmations = InboundConfirmations;
type uln_InitConfigInstructionAccounts = InitConfigInstructionAccounts;
type uln_InitConfigInstructionArgs = InitConfigInstructionArgs;
type uln_InitConfigParams = InitConfigParams;
type uln_InitDefaultConfigInstructionAccounts = InitDefaultConfigInstructionAccounts;
type uln_InitDefaultConfigInstructionArgs = InitDefaultConfigInstructionArgs;
type uln_InitDefaultConfigParams = InitDefaultConfigParams;
type uln_InitUlnInstructionAccounts = InitUlnInstructionAccounts;
type uln_InitUlnInstructionArgs = InitUlnInstructionArgs;
type uln_InitUlnParams = InitUlnParams;
type uln_InitVerifyInstructionAccounts = InitVerifyInstructionAccounts;
type uln_InitVerifyInstructionArgs = InitVerifyInstructionArgs;
type uln_InitVerifyParams = InitVerifyParams;
type uln_InsufficientFeeError = InsufficientFeeError;
declare const uln_InsufficientFeeError: typeof InsufficientFeeError;
type uln_InvalidAccountLengthError = InvalidAccountLengthError;
declare const uln_InvalidAccountLengthError: typeof InvalidAccountLengthError;
type uln_InvalidBpsError = InvalidBpsError;
declare const uln_InvalidBpsError: typeof InvalidBpsError;
type uln_InvalidConfigTypeError = InvalidConfigTypeError;
declare const uln_InvalidConfigTypeError: typeof InvalidConfigTypeError;
type uln_InvalidConfirmationError = InvalidConfirmationError;
declare const uln_InvalidConfirmationError: typeof InvalidConfirmationError;
type uln_InvalidConfirmationsError = InvalidConfirmationsError;
declare const uln_InvalidConfirmationsError: typeof InvalidConfirmationsError;
type uln_InvalidDvnError = InvalidDvnError;
declare const uln_InvalidDvnError: typeof InvalidDvnError;
type uln_InvalidDvnProgramError = InvalidDvnProgramError;
declare const uln_InvalidDvnProgramError: typeof InvalidDvnProgramError;
type uln_InvalidEidError = InvalidEidError;
declare const uln_InvalidEidError: typeof InvalidEidError;
type uln_InvalidExecutorError = InvalidExecutorError;
declare const uln_InvalidExecutorError: typeof InvalidExecutorError;
type uln_InvalidExecutorProgramError = InvalidExecutorProgramError;
declare const uln_InvalidExecutorProgramError: typeof InvalidExecutorProgramError;
type uln_InvalidLzTokenMintError = InvalidLzTokenMintError;
declare const uln_InvalidLzTokenMintError: typeof InvalidLzTokenMintError;
type uln_InvalidOptionTypeError = InvalidOptionTypeError;
declare const uln_InvalidOptionTypeError: typeof InvalidOptionTypeError;
type uln_InvalidOptionalDVNCountError = InvalidOptionalDVNCountError;
declare const uln_InvalidOptionalDVNCountError: typeof InvalidOptionalDVNCountError;
type uln_InvalidOptionalDVNThresholdError = InvalidOptionalDVNThresholdError;
declare const uln_InvalidOptionalDVNThresholdError: typeof InvalidOptionalDVNThresholdError;
type uln_InvalidPacketVersionError = InvalidPacketVersionError;
declare const uln_InvalidPacketVersionError: typeof InvalidPacketVersionError;
type uln_InvalidPayerError = InvalidPayerError;
declare const uln_InvalidPayerError: typeof InvalidPayerError;
type uln_InvalidRequiredDVNCountError = InvalidRequiredDVNCountError;
declare const uln_InvalidRequiredDVNCountError: typeof InvalidRequiredDVNCountError;
type uln_InvalidTreasuryError = InvalidTreasuryError;
declare const uln_InvalidTreasuryError: typeof InvalidTreasuryError;
type uln_InvalidTreasuryFeeCapError = InvalidTreasuryFeeCapError;
declare const uln_InvalidTreasuryFeeCapError: typeof InvalidTreasuryFeeCapError;
type uln_InvalidType1SizeError = InvalidType1SizeError;
declare const uln_InvalidType1SizeError: typeof InvalidType1SizeError;
type uln_InvalidType2SizeError = InvalidType2SizeError;
declare const uln_InvalidType2SizeError: typeof InvalidType2SizeError;
type uln_InvalidWorkerIdError = InvalidWorkerIdError;
declare const uln_InvalidWorkerIdError: typeof InvalidWorkerIdError;
type uln_LzTokenTreasury = LzTokenTreasury;
type uln_LzTokenUnavailableError = LzTokenUnavailableError;
declare const uln_LzTokenUnavailableError: typeof LzTokenUnavailableError;
type uln_MaxMessageSize = MaxMessageSize;
type uln_NonSignerError = NonSignerError;
declare const uln_NonSignerError: typeof NonSignerError;
type uln_OptionalOracles = OptionalOracles;
type uln_Oracles = Oracles;
type uln_OutboundConfirmations = OutboundConfirmations;
type uln_Packet = Packet;
type uln_SendConfig = SendConfig;
declare const uln_SendConfig: typeof SendConfig;
type uln_SendConfigArgs = SendConfigArgs;
type uln_SendWithLzTokenInstructionAccounts = SendWithLzTokenInstructionAccounts;
type uln_SendWithLzTokenInstructionArgs = SendWithLzTokenInstructionArgs;
type uln_SendWithLzTokenParams = SendWithLzTokenParams;
type uln_SetDefaultConfigInstructionAccounts = SetDefaultConfigInstructionAccounts;
type uln_SetDefaultConfigInstructionArgs = SetDefaultConfigInstructionArgs;
type uln_SetDefaultConfigParams = SetDefaultConfigParams;
type uln_SetTreasuryInstructionAccounts = SetTreasuryInstructionAccounts;
type uln_SetTreasuryInstructionArgs = SetTreasuryInstructionArgs;
type uln_SetTreasuryParams = SetTreasuryParams;
type uln_Treasury = Treasury;
type uln_TreasuryFee = TreasuryFee;
type uln_Uln = Uln;
declare const uln_Uln: typeof Uln;
type uln_UlnSettings = UlnSettings;
declare const uln_UlnSettings: typeof UlnSettings;
type uln_UlnSettingsArgs = UlnSettingsArgs;
type uln_UnsortedError = UnsortedError;
declare const uln_UnsortedError: typeof UnsortedError;
type uln_VerifyInstructionAccounts = VerifyInstructionAccounts;
type uln_VerifyInstructionArgs = VerifyInstructionArgs;
type uln_VerifyParams = VerifyParams;
type uln_VerifyingError = VerifyingError;
declare const uln_VerifyingError: typeof VerifyingError;
type uln_WithdrawRentInstructionAccounts = WithdrawRentInstructionAccounts;
type uln_WithdrawRentInstructionArgs = WithdrawRentInstructionArgs;
type uln_WithdrawRentParams = WithdrawRentParams;
type uln_WorkerFee = WorkerFee;
type uln_ZeroMessageSizeError = ZeroMessageSizeError;
declare const uln_ZeroMessageSizeError: typeof ZeroMessageSizeError;
declare const uln_commitVerificationInstructionDiscriminator: typeof commitVerificationInstructionDiscriminator;
declare const uln_commitVerificationParamsBeet: typeof commitVerificationParamsBeet;
declare const uln_commitVerificationStruct: typeof commitVerificationStruct;
declare const uln_configBeet: typeof configBeet;
declare const uln_confirmationsBeet: typeof confirmationsBeet;
declare const uln_confirmationsDiscriminator: typeof confirmationsDiscriminator;
declare const uln_createCommitVerificationInstruction: typeof createCommitVerificationInstruction;
declare const uln_createCommitVerificationInstructionAccounts: typeof createCommitVerificationInstructionAccounts;
declare const uln_createInitConfigInstruction: typeof createInitConfigInstruction;
declare const uln_createInitConfigInstructionAccounts: typeof createInitConfigInstructionAccounts;
declare const uln_createInitDefaultConfigInstruction: typeof createInitDefaultConfigInstruction;
declare const uln_createInitDefaultConfigInstructionAccounts: typeof createInitDefaultConfigInstructionAccounts;
declare const uln_createInitUlnInstruction: typeof createInitUlnInstruction;
declare const uln_createInitUlnInstructionAccounts: typeof createInitUlnInstructionAccounts;
declare const uln_createInitVerifyInstruction: typeof createInitVerifyInstruction;
declare const uln_createInitVerifyInstructionAccounts: typeof createInitVerifyInstructionAccounts;
declare const uln_createSendWithLzTokenInstruction: typeof createSendWithLzTokenInstruction;
declare const uln_createSendWithLzTokenInstructionAccounts: typeof createSendWithLzTokenInstructionAccounts;
declare const uln_createSetDefaultConfigInstruction: typeof createSetDefaultConfigInstruction;
declare const uln_createSetDefaultConfigInstructionAccounts: typeof createSetDefaultConfigInstructionAccounts;
declare const uln_createSetTreasuryInstruction: typeof createSetTreasuryInstruction;
declare const uln_createSetTreasuryInstructionAccounts: typeof createSetTreasuryInstructionAccounts;
declare const uln_createVerifyInstruction: typeof createVerifyInstruction;
declare const uln_createVerifyInstructionAccounts: typeof createVerifyInstructionAccounts;
declare const uln_createWithdrawRentInstruction: typeof createWithdrawRentInstruction;
declare const uln_createWithdrawRentInstructionAccounts: typeof createWithdrawRentInstructionAccounts;
declare const uln_initConfigInstructionDiscriminator: typeof initConfigInstructionDiscriminator;
declare const uln_initConfigParamsBeet: typeof initConfigParamsBeet;
declare const uln_initConfigStruct: typeof initConfigStruct;
declare const uln_initDefaultConfigInstructionDiscriminator: typeof initDefaultConfigInstructionDiscriminator;
declare const uln_initDefaultConfigParamsBeet: typeof initDefaultConfigParamsBeet;
declare const uln_initDefaultConfigStruct: typeof initDefaultConfigStruct;
declare const uln_initUlnInstructionDiscriminator: typeof initUlnInstructionDiscriminator;
declare const uln_initUlnParamsBeet: typeof initUlnParamsBeet;
declare const uln_initUlnStruct: typeof initUlnStruct;
declare const uln_initVerifyInstructionDiscriminator: typeof initVerifyInstructionDiscriminator;
declare const uln_initVerifyParamsBeet: typeof initVerifyParamsBeet;
declare const uln_initVerifyStruct: typeof initVerifyStruct;
declare const uln_isConfigExecutor: typeof isConfigExecutor;
declare const uln_isConfigReceiveUln: typeof isConfigReceiveUln;
declare const uln_isConfigSendUln: typeof isConfigSendUln;
declare const uln_lzTokenTreasuryBeet: typeof lzTokenTreasuryBeet;
declare const uln_packetBeet: typeof packetBeet;
declare const uln_sendConfigBeet: typeof sendConfigBeet;
declare const uln_sendConfigDiscriminator: typeof sendConfigDiscriminator;
declare const uln_sendWithLzTokenInstructionDiscriminator: typeof sendWithLzTokenInstructionDiscriminator;
declare const uln_sendWithLzTokenParamsBeet: typeof sendWithLzTokenParamsBeet;
declare const uln_sendWithLzTokenStruct: typeof sendWithLzTokenStruct;
declare const uln_setDefaultConfigInstructionDiscriminator: typeof setDefaultConfigInstructionDiscriminator;
declare const uln_setDefaultConfigParamsBeet: typeof setDefaultConfigParamsBeet;
declare const uln_setDefaultConfigStruct: typeof setDefaultConfigStruct;
declare const uln_setTreasuryInstructionDiscriminator: typeof setTreasuryInstructionDiscriminator;
declare const uln_setTreasuryParamsBeet: typeof setTreasuryParamsBeet;
declare const uln_setTreasuryStruct: typeof setTreasuryStruct;
declare const uln_treasuryBeet: typeof treasuryBeet;
declare const uln_treasuryFeeBeet: typeof treasuryFeeBeet;
declare const uln_ulnSettingsBeet: typeof ulnSettingsBeet;
declare const uln_ulnSettingsDiscriminator: typeof ulnSettingsDiscriminator;
declare const uln_verifyInstructionDiscriminator: typeof verifyInstructionDiscriminator;
declare const uln_verifyParamsBeet: typeof verifyParamsBeet;
declare const uln_verifyStruct: typeof verifyStruct;
declare const uln_withdrawRentInstructionDiscriminator: typeof withdrawRentInstructionDiscriminator;
declare const uln_withdrawRentParamsBeet: typeof withdrawRentParamsBeet;
declare const uln_withdrawRentStruct: typeof withdrawRentStruct;
declare const uln_workerFeeBeet: typeof workerFeeBeet;
declare namespace uln {
  export { uln_AtLeastOneDVNError as AtLeastOneDVNError, type uln_CommitVerificationInstructionAccounts as CommitVerificationInstructionAccounts, type uln_CommitVerificationInstructionArgs as CommitVerificationInstructionArgs, type uln_CommitVerificationParams as CommitVerificationParams, type uln_Config as Config, type uln_ConfigRecord as ConfigRecord, uln_Confirmations as Confirmations, type uln_ConfirmationsArgs as ConfirmationsArgs, uln_ExceededMaxMessageSizeError as ExceededMaxMessageSizeError, uln_ExceededU128Error as ExceededU128Error, type Executor$1 as Executor, type ExecutorConfig$1 as ExecutorConfig, type uln_InboundConfirmations as InboundConfirmations, type uln_InitConfigInstructionAccounts as InitConfigInstructionAccounts, type uln_InitConfigInstructionArgs as InitConfigInstructionArgs, type uln_InitConfigParams as InitConfigParams, type uln_InitDefaultConfigInstructionAccounts as InitDefaultConfigInstructionAccounts, type uln_InitDefaultConfigInstructionArgs as InitDefaultConfigInstructionArgs, type uln_InitDefaultConfigParams as InitDefaultConfigParams, type uln_InitUlnInstructionAccounts as InitUlnInstructionAccounts, type uln_InitUlnInstructionArgs as InitUlnInstructionArgs, type uln_InitUlnParams as InitUlnParams, type uln_InitVerifyInstructionAccounts as InitVerifyInstructionAccounts, type uln_InitVerifyInstructionArgs as InitVerifyInstructionArgs, type uln_InitVerifyParams as InitVerifyParams, uln_InsufficientFeeError as InsufficientFeeError, uln_InvalidAccountLengthError as InvalidAccountLengthError, InvalidAmountError$1 as InvalidAmountError, uln_InvalidBpsError as InvalidBpsError, uln_InvalidConfigTypeError as InvalidConfigTypeError, uln_InvalidConfirmationError as InvalidConfirmationError, uln_InvalidConfirmationsError as InvalidConfirmationsError, uln_InvalidDvnError as InvalidDvnError, uln_InvalidDvnProgramError as InvalidDvnProgramError, uln_InvalidEidError as InvalidEidError, uln_InvalidExecutorError as InvalidExecutorError, uln_InvalidExecutorProgramError as InvalidExecutorProgramError, uln_InvalidLzTokenMintError as InvalidLzTokenMintError, uln_InvalidOptionTypeError as InvalidOptionTypeError, uln_InvalidOptionalDVNCountError as InvalidOptionalDVNCountError, uln_InvalidOptionalDVNThresholdError as InvalidOptionalDVNThresholdError, uln_InvalidPacketVersionError as InvalidPacketVersionError, uln_InvalidPayerError as InvalidPayerError, uln_InvalidRequiredDVNCountError as InvalidRequiredDVNCountError, uln_InvalidTreasuryError as InvalidTreasuryError, uln_InvalidTreasuryFeeCapError as InvalidTreasuryFeeCapError, uln_InvalidType1SizeError as InvalidType1SizeError, uln_InvalidType2SizeError as InvalidType2SizeError, uln_InvalidWorkerIdError as InvalidWorkerIdError, type uln_LzTokenTreasury as LzTokenTreasury, uln_LzTokenUnavailableError as LzTokenUnavailableError, type uln_MaxMessageSize as MaxMessageSize, type MessagingFee$1 as MessagingFee, uln_NonSignerError as NonSignerError, type uln_OptionalOracles as OptionalOracles, type uln_Oracles as Oracles, type uln_OutboundConfirmations as OutboundConfirmations, PROGRAM_ADDRESS$4 as PROGRAM_ADDRESS, PROGRAM_ID$5 as PROGRAM_ID, type uln_Packet as Packet, type QuoteInstructionAccounts$1 as QuoteInstructionAccounts, type QuoteInstructionArgs$1 as QuoteInstructionArgs, type QuoteParams$1 as QuoteParams, ReceiveConfig$1 as ReceiveConfig, type ReceiveConfigArgs$1 as ReceiveConfigArgs, uln_SendConfig as SendConfig, type uln_SendConfigArgs as SendConfigArgs, type SendInstructionAccounts$1 as SendInstructionAccounts, type SendInstructionArgs$1 as SendInstructionArgs, type SendParams$1 as SendParams, type uln_SendWithLzTokenInstructionAccounts as SendWithLzTokenInstructionAccounts, type uln_SendWithLzTokenInstructionArgs as SendWithLzTokenInstructionArgs, type uln_SendWithLzTokenParams as SendWithLzTokenParams, type SetConfigInstructionAccounts$1 as SetConfigInstructionAccounts, type SetConfigInstructionArgs$1 as SetConfigInstructionArgs, type SetConfigParams$1 as SetConfigParams, type uln_SetDefaultConfigInstructionAccounts as SetDefaultConfigInstructionAccounts, type uln_SetDefaultConfigInstructionArgs as SetDefaultConfigInstructionArgs, type uln_SetDefaultConfigParams as SetDefaultConfigParams, type uln_SetTreasuryInstructionAccounts as SetTreasuryInstructionAccounts, type uln_SetTreasuryInstructionArgs as SetTreasuryInstructionArgs, type uln_SetTreasuryParams as SetTreasuryParams, type TransferAdminInstructionAccounts$2 as TransferAdminInstructionAccounts, type TransferAdminInstructionArgs$2 as TransferAdminInstructionArgs, type TransferAdminParams$2 as TransferAdminParams, type uln_Treasury as Treasury, type uln_TreasuryFee as TreasuryFee, uln_Uln as Uln, type UlnConfig$1 as UlnConfig, uln_UlnSettings as UlnSettings, type uln_UlnSettingsArgs as UlnSettingsArgs, UnauthorizedError$1 as UnauthorizedError, uln_UnsortedError as UnsortedError, type uln_VerifyInstructionAccounts as VerifyInstructionAccounts, type uln_VerifyInstructionArgs as VerifyInstructionArgs, type uln_VerifyParams as VerifyParams, uln_VerifyingError as VerifyingError, type Version$1 as Version, type uln_WithdrawRentInstructionAccounts as WithdrawRentInstructionAccounts, type uln_WithdrawRentInstructionArgs as WithdrawRentInstructionArgs, type uln_WithdrawRentParams as WithdrawRentParams, type uln_WorkerFee as WorkerFee, uln_ZeroMessageSizeError as ZeroMessageSizeError, accountProviders$4 as accountProviders, index$j as accounts, uln_commitVerificationInstructionDiscriminator as commitVerificationInstructionDiscriminator, uln_commitVerificationParamsBeet as commitVerificationParamsBeet, uln_commitVerificationStruct as commitVerificationStruct, uln_configBeet as configBeet, uln_confirmationsBeet as confirmationsBeet, uln_confirmationsDiscriminator as confirmationsDiscriminator, uln_createCommitVerificationInstruction as createCommitVerificationInstruction, uln_createCommitVerificationInstructionAccounts as createCommitVerificationInstructionAccounts, uln_createInitConfigInstruction as createInitConfigInstruction, uln_createInitConfigInstructionAccounts as createInitConfigInstructionAccounts, uln_createInitDefaultConfigInstruction as createInitDefaultConfigInstruction, uln_createInitDefaultConfigInstructionAccounts as createInitDefaultConfigInstructionAccounts, uln_createInitUlnInstruction as createInitUlnInstruction, uln_createInitUlnInstructionAccounts as createInitUlnInstructionAccounts, uln_createInitVerifyInstruction as createInitVerifyInstruction, uln_createInitVerifyInstructionAccounts as createInitVerifyInstructionAccounts, createQuoteInstruction$1 as createQuoteInstruction, createQuoteInstructionAccounts$1 as createQuoteInstructionAccounts, createSendInstruction$1 as createSendInstruction, createSendInstructionAccounts$1 as createSendInstructionAccounts, uln_createSendWithLzTokenInstruction as createSendWithLzTokenInstruction, uln_createSendWithLzTokenInstructionAccounts as createSendWithLzTokenInstructionAccounts, createSetConfigInstruction$1 as createSetConfigInstruction, createSetConfigInstructionAccounts$1 as createSetConfigInstructionAccounts, uln_createSetDefaultConfigInstruction as createSetDefaultConfigInstruction, uln_createSetDefaultConfigInstructionAccounts as createSetDefaultConfigInstructionAccounts, uln_createSetTreasuryInstruction as createSetTreasuryInstruction, uln_createSetTreasuryInstructionAccounts as createSetTreasuryInstructionAccounts, createTransferAdminInstruction$2 as createTransferAdminInstruction, createTransferAdminInstructionAccounts$2 as createTransferAdminInstructionAccounts, uln_createVerifyInstruction as createVerifyInstruction, uln_createVerifyInstructionAccounts as createVerifyInstructionAccounts, createVersionInstruction$2 as createVersionInstruction, createVersionInstructionAccounts$2 as createVersionInstructionAccounts, uln_createWithdrawRentInstruction as createWithdrawRentInstruction, uln_createWithdrawRentInstructionAccounts as createWithdrawRentInstructionAccounts, errorFromCode$3 as errorFromCode, errorFromName$3 as errorFromName, index$i as errors, index$h as events, executorConfigBeet$1 as executorConfigBeet, uln_initConfigInstructionDiscriminator as initConfigInstructionDiscriminator, uln_initConfigParamsBeet as initConfigParamsBeet, uln_initConfigStruct as initConfigStruct, uln_initDefaultConfigInstructionDiscriminator as initDefaultConfigInstructionDiscriminator, uln_initDefaultConfigParamsBeet as initDefaultConfigParamsBeet, uln_initDefaultConfigStruct as initDefaultConfigStruct, uln_initUlnInstructionDiscriminator as initUlnInstructionDiscriminator, uln_initUlnParamsBeet as initUlnParamsBeet, uln_initUlnStruct as initUlnStruct, uln_initVerifyInstructionDiscriminator as initVerifyInstructionDiscriminator, uln_initVerifyParamsBeet as initVerifyParamsBeet, uln_initVerifyStruct as initVerifyStruct, index$g as instructions, uln_isConfigExecutor as isConfigExecutor, uln_isConfigReceiveUln as isConfigReceiveUln, uln_isConfigSendUln as isConfigSendUln, uln_lzTokenTreasuryBeet as lzTokenTreasuryBeet, messagingFeeBeet$1 as messagingFeeBeet, uln_packetBeet as packetBeet, quoteInstructionDiscriminator$1 as quoteInstructionDiscriminator, quoteParamsBeet$1 as quoteParamsBeet, quoteStruct$1 as quoteStruct, receiveConfigBeet$1 as receiveConfigBeet, receiveConfigDiscriminator$1 as receiveConfigDiscriminator, uln_sendConfigBeet as sendConfigBeet, uln_sendConfigDiscriminator as sendConfigDiscriminator, sendInstructionDiscriminator$1 as sendInstructionDiscriminator, sendParamsBeet$1 as sendParamsBeet, sendStruct$1 as sendStruct, uln_sendWithLzTokenInstructionDiscriminator as sendWithLzTokenInstructionDiscriminator, uln_sendWithLzTokenParamsBeet as sendWithLzTokenParamsBeet, uln_sendWithLzTokenStruct as sendWithLzTokenStruct, setConfigInstructionDiscriminator$1 as setConfigInstructionDiscriminator, setConfigParamsBeet$1 as setConfigParamsBeet, setConfigStruct$1 as setConfigStruct, uln_setDefaultConfigInstructionDiscriminator as setDefaultConfigInstructionDiscriminator, uln_setDefaultConfigParamsBeet as setDefaultConfigParamsBeet, uln_setDefaultConfigStruct as setDefaultConfigStruct, uln_setTreasuryInstructionDiscriminator as setTreasuryInstructionDiscriminator, uln_setTreasuryParamsBeet as setTreasuryParamsBeet, uln_setTreasuryStruct as setTreasuryStruct, transferAdminInstructionDiscriminator$2 as transferAdminInstructionDiscriminator, transferAdminParamsBeet$2 as transferAdminParamsBeet, transferAdminStruct$2 as transferAdminStruct, uln_treasuryBeet as treasuryBeet, uln_treasuryFeeBeet as treasuryFeeBeet, index$f as types, ulnConfigBeet$1 as ulnConfigBeet, uln_ulnSettingsBeet as ulnSettingsBeet, uln_ulnSettingsDiscriminator as ulnSettingsDiscriminator, uln_verifyInstructionDiscriminator as verifyInstructionDiscriminator, uln_verifyParamsBeet as verifyParamsBeet, uln_verifyStruct as verifyStruct, versionBeet$1 as versionBeet, versionInstructionDiscriminator$2 as versionInstructionDiscriminator, versionStruct$2 as versionStruct, uln_withdrawRentInstructionDiscriminator as withdrawRentInstructionDiscriminator, uln_withdrawRentParamsBeet as withdrawRentParamsBeet, uln_withdrawRentStruct as withdrawRentStruct, uln_workerFeeBeet as workerFeeBeet };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Acl$1 = {
    allowList: web3.PublicKey[];
    denyList: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const aclBeet$1: beet.FixableBeetArgsStruct<Acl$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DstConfig$1 = {
    eid: number;
    lzReceiveBaseGas: number;
    lzComposeBaseGas: number;
    multiplierBps: beet.COption<number>;
    floorMarginUsd: beet.COption<beet.bignum>;
    nativeDropCap: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const dstConfigBeet$1: beet.FixableBeetArgsStruct<DstConfig$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ExecutorConfig}
 * @category Accounts
 * @category generated
 */
type ExecutorConfigArgs = {
    bump: number;
    owner: web3.PublicKey;
    acl: Acl$1;
    admins: web3.PublicKey[];
    executors: web3.PublicKey[];
    msglibs: web3.PublicKey[];
    paused: boolean;
    defaultMultiplierBps: number;
    priceFeed: web3.PublicKey;
    dstConfigs: DstConfig$1[];
};
declare const executorConfigDiscriminator: number[];
/**
 * Holds the data for the {@link ExecutorConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ExecutorConfig implements ExecutorConfigArgs {
    readonly bump: number;
    readonly owner: web3.PublicKey;
    readonly acl: Acl$1;
    readonly admins: web3.PublicKey[];
    readonly executors: web3.PublicKey[];
    readonly msglibs: web3.PublicKey[];
    readonly paused: boolean;
    readonly defaultMultiplierBps: number;
    readonly priceFeed: web3.PublicKey;
    readonly dstConfigs: DstConfig$1[];
    private constructor();
    /**
     * Creates a {@link ExecutorConfig} instance from the provided args.
     */
    static fromArgs(args: ExecutorConfigArgs): ExecutorConfig;
    /**
     * Deserializes the {@link ExecutorConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ExecutorConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ExecutorConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ExecutorConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ExecutorConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link ExecutorConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ExecutorConfig, number];
    /**
     * Serializes the {@link ExecutorConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ExecutorConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ExecutorConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ExecutorConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ExecutorConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link ExecutorConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        owner: string;
        acl: Acl$1;
        admins: web3.PublicKey[];
        executors: web3.PublicKey[];
        msglibs: web3.PublicKey[];
        paused: boolean;
        defaultMultiplierBps: number;
        priceFeed: string;
        dstConfigs: DstConfig$1[];
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const executorConfigBeet: beet.FixableBeetStruct<ExecutorConfig, ExecutorConfigArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link Nonce}
 * @category Accounts
 * @category generated
 */
type NonceArgs = {
    bump: number;
    outboundNonce: beet.bignum;
    inboundNonce: beet.bignum;
};
declare const nonceDiscriminator: number[];
/**
 * Holds the data for the {@link Nonce} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class Nonce implements NonceArgs {
    readonly bump: number;
    readonly outboundNonce: beet.bignum;
    readonly inboundNonce: beet.bignum;
    private constructor();
    /**
     * Creates a {@link Nonce} instance from the provided args.
     */
    static fromArgs(args: NonceArgs): Nonce;
    /**
     * Deserializes the {@link Nonce} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [Nonce, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link Nonce} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<Nonce>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        bump: any;
        outboundNonce: any;
        inboundNonce: any;
        accountDiscriminator: any;
    }>;
    /**
     * Deserializes the {@link Nonce} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [Nonce, number];
    /**
     * Serializes the {@link Nonce} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link Nonce}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link Nonce} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link Nonce} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link Nonce} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        outboundNonce: number | {
            toNumber: () => number;
        };
        inboundNonce: number | {
            toNumber: () => number;
        };
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const nonceBeet: beet.BeetStruct<Nonce, NonceArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$3: {
    Nonce: typeof Nonce;
    ExecutorConfig: typeof ExecutorConfig;
};

type index$e_ExecutorConfig = ExecutorConfig;
declare const index$e_ExecutorConfig: typeof ExecutorConfig;
type index$e_ExecutorConfigArgs = ExecutorConfigArgs;
type index$e_Nonce = Nonce;
declare const index$e_Nonce: typeof Nonce;
type index$e_NonceArgs = NonceArgs;
declare const index$e_executorConfigBeet: typeof executorConfigBeet;
declare const index$e_executorConfigDiscriminator: typeof executorConfigDiscriminator;
declare const index$e_nonceBeet: typeof nonceBeet;
declare const index$e_nonceDiscriminator: typeof nonceDiscriminator;
declare namespace index$e {
  export { index$e_ExecutorConfig as ExecutorConfig, type index$e_ExecutorConfigArgs as ExecutorConfigArgs, index$e_Nonce as Nonce, type index$e_NonceArgs as NonceArgs, accountProviders$3 as accountProviders, index$e_executorConfigBeet as executorConfigBeet, index$e_executorConfigDiscriminator as executorConfigDiscriminator, index$e_nonceBeet as nonceBeet, index$e_nonceDiscriminator as nonceDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type NativeDropRequest = {
    receiver: web3.PublicKey;
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const nativeDropRequestBeet: beet.BeetArgsStruct<NativeDropRequest>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type NativeDropAppliedEvent = {
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    dstEid: number;
    oapp: web3.PublicKey;
    nativeDropRequests: NativeDropRequest[];
    successes: boolean[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const nativeDropAppliedEventBeet: beet.FixableBeetArgsStruct<NativeDropAppliedEvent>;

type index$d_NativeDropAppliedEvent = NativeDropAppliedEvent;
declare const index$d_nativeDropAppliedEventBeet: typeof nativeDropAppliedEventBeet;
declare namespace index$d {
  export { type index$d_NativeDropAppliedEvent as NativeDropAppliedEvent, index$d_nativeDropAppliedEventBeet as nativeDropAppliedEventBeet };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link AdminSetConfigParams} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link AdminSetConfigParams} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type AdminSetConfigParamsRecord = {
    PriceFeed: {
        fields: [web3.PublicKey];
    };
    DefaultMultiplierBps: {
        fields: [number];
    };
    DstConfigs: {
        fields: [DstConfig$1[]];
    };
};
/**
 * Union type respresenting the AdminSetConfigParams data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isAdminSetConfigParams*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type AdminSetConfigParams = beet.DataEnumKeyAsKind<AdminSetConfigParamsRecord>;
declare const isAdminSetConfigParamsPriceFeed: (x: AdminSetConfigParams) => x is {
    __kind: "PriceFeed";
} & Omit<{
    fields: [web3.PublicKey];
}, "void"> & {
    __kind: 'PriceFeed';
};
declare const isAdminSetConfigParamsDefaultMultiplierBps: (x: AdminSetConfigParams) => x is {
    __kind: "DefaultMultiplierBps";
} & Omit<{
    fields: [number];
}, "void"> & {
    __kind: 'DefaultMultiplierBps';
};
declare const isAdminSetConfigParamsDstConfigs: (x: AdminSetConfigParams) => x is {
    __kind: "DstConfigs";
} & Omit<{
    fields: [DstConfig$1[]];
}, "void"> & {
    __kind: 'DstConfigs';
};
/**
 * @category userTypes
 * @category generated
 */
declare const adminSetConfigParamsBeet: beet.FixableBeet<AdminSetConfigParams, AdminSetConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category AdminSetConfig
 * @category generated
 */
type AdminSetConfigInstructionArgs = {
    params: AdminSetConfigParams;
};
/**
 * @category Instructions
 * @category AdminSetConfig
 * @category generated
 */
declare const adminSetConfigStruct: beet.FixableBeetArgsStruct<AdminSetConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _adminSetConfig_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] config
 * @category Instructions
 * @category AdminSetConfig
 * @category generated
 */
type AdminSetConfigInstructionAccounts = {
    admin: web3.PublicKey;
    config: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const adminSetConfigInstructionDiscriminator: number[];
/**
 * Creates a _AdminSetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category AdminSetConfig
 * @category generated
 */
declare function createAdminSetConfigInstruction(accounts: AdminSetConfigInstructionAccounts, args: AdminSetConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _AdminSetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category AdminSetConfig
 * @category generated
 */
declare function createAdminSetConfigInstructionAccounts(accounts: AdminSetConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzComposeParams$1 = {
    from: web3.PublicKey;
    to: web3.PublicKey;
    guid: number[];
    index: number;
    message: Uint8Array;
    extraData: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzComposeParamsBeet: beet.FixableBeetArgsStruct<LzComposeParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ComposeParams = {
    lzCompose: LzComposeParams$1;
    computeUnits: beet.bignum;
    value: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const composeParamsBeet: beet.FixableBeetArgsStruct<ComposeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Compose
 * @category generated
 */
type ComposeInstructionArgs = {
    params: ComposeParams;
};
/**
 * @category Instructions
 * @category Compose
 * @category generated
 */
declare const composeStruct: beet.FixableBeetArgsStruct<ComposeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _compose_ instruction
 *
 * @property [_writable_, **signer**] executor
 * @property [] config
 * @property [] endpointProgram
 * @property [] endpointEventAuthority
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Compose
 * @category generated
 */
type ComposeInstructionAccounts = {
    executor: web3.PublicKey;
    config: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    endpointEventAuthority: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const composeInstructionDiscriminator: number[];
/**
 * Creates a _Compose_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Compose
 * @category generated
 */
declare function createComposeInstruction(accounts: ComposeInstructionAccounts, args: ComposeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Compose_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Compose
 * @category generated
 */
declare function createComposeInstructionAccounts(accounts: ComposeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ExecutableParams = {
    receiver: web3.PublicKey;
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const executableParamsBeet: beet.BeetArgsStruct<ExecutableParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Executable
 * @category generated
 */
type ExecutableInstructionArgs = {
    params: ExecutableParams;
};
/**
 * @category Instructions
 * @category Executable
 * @category generated
 */
declare const executableStruct: beet.BeetArgsStruct<ExecutableInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _executable_ instruction
 *
 * @property [] nonce
 * @property [] payloadHash
 * @category Instructions
 * @category Executable
 * @category generated
 */
type ExecutableInstructionAccounts = {
    nonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const executableInstructionDiscriminator: number[];
/**
 * Creates a _Executable_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Executable
 * @category generated
 */
declare function createExecutableInstruction(accounts: ExecutableInstructionAccounts, args: ExecutableInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Executable_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Executable
 * @category generated
 */
declare function createExecutableInstructionAccounts(accounts: ExecutableInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzReceiveParams$2 = {
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    guid: number[];
    message: Uint8Array;
    extraData: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzReceiveParamsBeet$1: beet.FixableBeetArgsStruct<LzReceiveParams$2>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ExecuteParams = {
    receiver: web3.PublicKey;
    lzReceive: LzReceiveParams$2;
    value: beet.bignum;
    computeUnits: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const executeParamsBeet: beet.FixableBeetArgsStruct<ExecuteParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Execute
 * @category generated
 */
type ExecuteInstructionArgs = {
    params: ExecuteParams;
};
/**
 * @category Instructions
 * @category Execute
 * @category generated
 */
declare const executeStruct: beet.FixableBeetArgsStruct<ExecuteInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _execute_ instruction
 *
 * @property [_writable_, **signer**] executor
 * @property [] config
 * @property [] endpointProgram
 * @property [] endpointEventAuthority
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Execute
 * @category generated
 */
type ExecuteInstructionAccounts = {
    executor: web3.PublicKey;
    config: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    endpointEventAuthority: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const executeInstructionDiscriminator: number[];
/**
 * Creates a _Execute_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Execute
 * @category generated
 */
declare function createExecuteInstruction(accounts: ExecuteInstructionAccounts, args: ExecuteInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Execute_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Execute
 * @category generated
 */
declare function createExecuteInstructionAccounts(accounts: ExecuteInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitExecutorParams = {
    owner: web3.PublicKey;
    admins: web3.PublicKey[];
    executors: web3.PublicKey[];
    msglibs: web3.PublicKey[];
    priceFeed: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initExecutorParamsBeet: beet.FixableBeetArgsStruct<InitExecutorParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitExecutor
 * @category generated
 */
type InitExecutorInstructionArgs = {
    params: InitExecutorParams;
};
/**
 * @category Instructions
 * @category InitExecutor
 * @category generated
 */
declare const initExecutorStruct: beet.FixableBeetArgsStruct<InitExecutorInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initExecutor_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] config
 * @category Instructions
 * @category InitExecutor
 * @category generated
 */
type InitExecutorInstructionAccounts = {
    payer: web3.PublicKey;
    config: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initExecutorInstructionDiscriminator: number[];
/**
 * Creates a _InitExecutor_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitExecutor
 * @category generated
 */
declare function createInitExecutorInstruction(accounts: InitExecutorInstructionAccounts, args: InitExecutorInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitExecutor_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitExecutor
 * @category generated
 */
declare function createInitExecutorInstructionAccounts(accounts: InitExecutorInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type NativeDropParams = {
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    dstEid: number;
    oapp: web3.PublicKey;
    nativeDropRequests: NativeDropRequest[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const nativeDropParamsBeet: beet.FixableBeetArgsStruct<NativeDropParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category NativeDrop
 * @category generated
 */
type NativeDropInstructionArgs = {
    params: NativeDropParams;
};
/**
 * @category Instructions
 * @category NativeDrop
 * @category generated
 */
declare const nativeDropStruct: beet.FixableBeetArgsStruct<NativeDropInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _nativeDrop_ instruction
 *
 * @property [_writable_, **signer**] executor
 * @property [_writable_] config
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category NativeDrop
 * @category generated
 */
type NativeDropInstructionAccounts = {
    executor: web3.PublicKey;
    config: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const nativeDropInstructionDiscriminator: number[];
/**
 * Creates a _NativeDrop_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category NativeDrop
 * @category generated
 */
declare function createNativeDropInstruction(accounts: NativeDropInstructionAccounts, args: NativeDropInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _NativeDrop_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category NativeDrop
 * @category generated
 */
declare function createNativeDropInstructionAccounts(accounts: NativeDropInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link OwnerSetConfigParams} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link OwnerSetConfigParams} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type OwnerSetConfigParamsRecord = {
    Admins: {
        fields: [web3.PublicKey[]];
    };
    Executors: {
        fields: [web3.PublicKey[]];
    };
    Msglibs: {
        fields: [web3.PublicKey[]];
    };
    Owner: {
        fields: [web3.PublicKey];
    };
    Paused: {
        fields: [boolean];
    };
    Allowlist: {
        fields: [web3.PublicKey[]];
    };
    Denylist: {
        fields: [web3.PublicKey[]];
    };
};
/**
 * Union type respresenting the OwnerSetConfigParams data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isOwnerSetConfigParams*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type OwnerSetConfigParams = beet.DataEnumKeyAsKind<OwnerSetConfigParamsRecord>;
declare const isOwnerSetConfigParamsAdmins: (x: OwnerSetConfigParams) => x is {
    __kind: "Admins";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Admins';
};
declare const isOwnerSetConfigParamsExecutors: (x: OwnerSetConfigParams) => x is {
    __kind: "Executors";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Executors';
};
declare const isOwnerSetConfigParamsMsglibs: (x: OwnerSetConfigParams) => x is {
    __kind: "Msglibs";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Msglibs';
};
declare const isOwnerSetConfigParamsOwner: (x: OwnerSetConfigParams) => x is {
    __kind: "Owner";
} & Omit<{
    fields: [web3.PublicKey];
}, "void"> & {
    __kind: 'Owner';
};
declare const isOwnerSetConfigParamsPaused: (x: OwnerSetConfigParams) => x is {
    __kind: "Paused";
} & Omit<{
    fields: [boolean];
}, "void"> & {
    __kind: 'Paused';
};
declare const isOwnerSetConfigParamsAllowlist: (x: OwnerSetConfigParams) => x is {
    __kind: "Allowlist";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Allowlist';
};
declare const isOwnerSetConfigParamsDenylist: (x: OwnerSetConfigParams) => x is {
    __kind: "Denylist";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Denylist';
};
/**
 * @category userTypes
 * @category generated
 */
declare const ownerSetConfigParamsBeet: beet.FixableBeet<OwnerSetConfigParams, OwnerSetConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category OwnerSetConfig
 * @category generated
 */
type OwnerSetConfigInstructionArgs = {
    params: OwnerSetConfigParams;
};
/**
 * @category Instructions
 * @category OwnerSetConfig
 * @category generated
 */
declare const ownerSetConfigStruct: beet.FixableBeetArgsStruct<OwnerSetConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _ownerSetConfig_ instruction
 *
 * @property [**signer**] owner
 * @property [_writable_] config
 * @category Instructions
 * @category OwnerSetConfig
 * @category generated
 */
type OwnerSetConfigInstructionAccounts = {
    owner: web3.PublicKey;
    config: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const ownerSetConfigInstructionDiscriminator: number[];
/**
 * Creates a _OwnerSetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category OwnerSetConfig
 * @category generated
 */
declare function createOwnerSetConfigInstruction(accounts: OwnerSetConfigInstructionAccounts, args: OwnerSetConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _OwnerSetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category OwnerSetConfig
 * @category generated
 */
declare function createOwnerSetConfigInstructionAccounts(accounts: OwnerSetConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzOption$1 = {
    optionType: number;
    params: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzOptionBeet$1: beet.FixableBeetArgsStruct<LzOption$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteExecutorParams = {
    msglib: web3.PublicKey;
    dstEid: number;
    sender: web3.PublicKey;
    calldataSize: beet.bignum;
    options: LzOption$1[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteExecutorParamsBeet: beet.FixableBeetArgsStruct<QuoteExecutorParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category QuoteExecutor
 * @category generated
 */
type QuoteExecutorInstructionArgs = {
    params: QuoteExecutorParams;
};
/**
 * @category Instructions
 * @category QuoteExecutor
 * @category generated
 */
declare const quoteExecutorStruct: beet.FixableBeetArgsStruct<QuoteExecutorInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quoteExecutor_ instruction
 *
 * @property [] executorConfig
 * @property [] priceFeedProgram
 * @property [] priceFeedConfig
 * @category Instructions
 * @category QuoteExecutor
 * @category generated
 */
type QuoteExecutorInstructionAccounts = {
    executorConfig: web3.PublicKey;
    priceFeedProgram: web3.PublicKey;
    priceFeedConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteExecutorInstructionDiscriminator: number[];
/**
 * Creates a _QuoteExecutor_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category QuoteExecutor
 * @category generated
 */
declare function createQuoteExecutorInstruction(accounts: QuoteExecutorInstructionAccounts, args: QuoteExecutorInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _QuoteExecutor_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category QuoteExecutor
 * @category generated
 */
declare function createQuoteExecutorInstructionAccounts(accounts: QuoteExecutorInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

type index$c_AdminSetConfigInstructionAccounts = AdminSetConfigInstructionAccounts;
type index$c_AdminSetConfigInstructionArgs = AdminSetConfigInstructionArgs;
type index$c_ComposeInstructionAccounts = ComposeInstructionAccounts;
type index$c_ComposeInstructionArgs = ComposeInstructionArgs;
type index$c_ExecutableInstructionAccounts = ExecutableInstructionAccounts;
type index$c_ExecutableInstructionArgs = ExecutableInstructionArgs;
type index$c_ExecuteInstructionAccounts = ExecuteInstructionAccounts;
type index$c_ExecuteInstructionArgs = ExecuteInstructionArgs;
type index$c_InitExecutorInstructionAccounts = InitExecutorInstructionAccounts;
type index$c_InitExecutorInstructionArgs = InitExecutorInstructionArgs;
type index$c_NativeDropInstructionAccounts = NativeDropInstructionAccounts;
type index$c_NativeDropInstructionArgs = NativeDropInstructionArgs;
type index$c_OwnerSetConfigInstructionAccounts = OwnerSetConfigInstructionAccounts;
type index$c_OwnerSetConfigInstructionArgs = OwnerSetConfigInstructionArgs;
type index$c_QuoteExecutorInstructionAccounts = QuoteExecutorInstructionAccounts;
type index$c_QuoteExecutorInstructionArgs = QuoteExecutorInstructionArgs;
declare const index$c_adminSetConfigInstructionDiscriminator: typeof adminSetConfigInstructionDiscriminator;
declare const index$c_adminSetConfigStruct: typeof adminSetConfigStruct;
declare const index$c_composeInstructionDiscriminator: typeof composeInstructionDiscriminator;
declare const index$c_composeStruct: typeof composeStruct;
declare const index$c_createAdminSetConfigInstruction: typeof createAdminSetConfigInstruction;
declare const index$c_createAdminSetConfigInstructionAccounts: typeof createAdminSetConfigInstructionAccounts;
declare const index$c_createComposeInstruction: typeof createComposeInstruction;
declare const index$c_createComposeInstructionAccounts: typeof createComposeInstructionAccounts;
declare const index$c_createExecutableInstruction: typeof createExecutableInstruction;
declare const index$c_createExecutableInstructionAccounts: typeof createExecutableInstructionAccounts;
declare const index$c_createExecuteInstruction: typeof createExecuteInstruction;
declare const index$c_createExecuteInstructionAccounts: typeof createExecuteInstructionAccounts;
declare const index$c_createInitExecutorInstruction: typeof createInitExecutorInstruction;
declare const index$c_createInitExecutorInstructionAccounts: typeof createInitExecutorInstructionAccounts;
declare const index$c_createNativeDropInstruction: typeof createNativeDropInstruction;
declare const index$c_createNativeDropInstructionAccounts: typeof createNativeDropInstructionAccounts;
declare const index$c_createOwnerSetConfigInstruction: typeof createOwnerSetConfigInstruction;
declare const index$c_createOwnerSetConfigInstructionAccounts: typeof createOwnerSetConfigInstructionAccounts;
declare const index$c_createQuoteExecutorInstruction: typeof createQuoteExecutorInstruction;
declare const index$c_createQuoteExecutorInstructionAccounts: typeof createQuoteExecutorInstructionAccounts;
declare const index$c_executableInstructionDiscriminator: typeof executableInstructionDiscriminator;
declare const index$c_executableStruct: typeof executableStruct;
declare const index$c_executeInstructionDiscriminator: typeof executeInstructionDiscriminator;
declare const index$c_executeStruct: typeof executeStruct;
declare const index$c_initExecutorInstructionDiscriminator: typeof initExecutorInstructionDiscriminator;
declare const index$c_initExecutorStruct: typeof initExecutorStruct;
declare const index$c_nativeDropInstructionDiscriminator: typeof nativeDropInstructionDiscriminator;
declare const index$c_nativeDropStruct: typeof nativeDropStruct;
declare const index$c_ownerSetConfigInstructionDiscriminator: typeof ownerSetConfigInstructionDiscriminator;
declare const index$c_ownerSetConfigStruct: typeof ownerSetConfigStruct;
declare const index$c_quoteExecutorInstructionDiscriminator: typeof quoteExecutorInstructionDiscriminator;
declare const index$c_quoteExecutorStruct: typeof quoteExecutorStruct;
declare namespace index$c {
  export { type index$c_AdminSetConfigInstructionAccounts as AdminSetConfigInstructionAccounts, type index$c_AdminSetConfigInstructionArgs as AdminSetConfigInstructionArgs, type index$c_ComposeInstructionAccounts as ComposeInstructionAccounts, type index$c_ComposeInstructionArgs as ComposeInstructionArgs, type index$c_ExecutableInstructionAccounts as ExecutableInstructionAccounts, type index$c_ExecutableInstructionArgs as ExecutableInstructionArgs, type index$c_ExecuteInstructionAccounts as ExecuteInstructionAccounts, type index$c_ExecuteInstructionArgs as ExecuteInstructionArgs, type index$c_InitExecutorInstructionAccounts as InitExecutorInstructionAccounts, type index$c_InitExecutorInstructionArgs as InitExecutorInstructionArgs, type index$c_NativeDropInstructionAccounts as NativeDropInstructionAccounts, type index$c_NativeDropInstructionArgs as NativeDropInstructionArgs, type index$c_OwnerSetConfigInstructionAccounts as OwnerSetConfigInstructionAccounts, type index$c_OwnerSetConfigInstructionArgs as OwnerSetConfigInstructionArgs, type index$c_QuoteExecutorInstructionAccounts as QuoteExecutorInstructionAccounts, type index$c_QuoteExecutorInstructionArgs as QuoteExecutorInstructionArgs, index$c_adminSetConfigInstructionDiscriminator as adminSetConfigInstructionDiscriminator, index$c_adminSetConfigStruct as adminSetConfigStruct, index$c_composeInstructionDiscriminator as composeInstructionDiscriminator, index$c_composeStruct as composeStruct, index$c_createAdminSetConfigInstruction as createAdminSetConfigInstruction, index$c_createAdminSetConfigInstructionAccounts as createAdminSetConfigInstructionAccounts, index$c_createComposeInstruction as createComposeInstruction, index$c_createComposeInstructionAccounts as createComposeInstructionAccounts, index$c_createExecutableInstruction as createExecutableInstruction, index$c_createExecutableInstructionAccounts as createExecutableInstructionAccounts, index$c_createExecuteInstruction as createExecuteInstruction, index$c_createExecuteInstructionAccounts as createExecuteInstructionAccounts, index$c_createInitExecutorInstruction as createInitExecutorInstruction, index$c_createInitExecutorInstructionAccounts as createInitExecutorInstructionAccounts, index$c_createNativeDropInstruction as createNativeDropInstruction, index$c_createNativeDropInstructionAccounts as createNativeDropInstructionAccounts, index$c_createOwnerSetConfigInstruction as createOwnerSetConfigInstruction, index$c_createOwnerSetConfigInstructionAccounts as createOwnerSetConfigInstructionAccounts, index$c_createQuoteExecutorInstruction as createQuoteExecutorInstruction, index$c_createQuoteExecutorInstructionAccounts as createQuoteExecutorInstructionAccounts, index$c_executableInstructionDiscriminator as executableInstructionDiscriminator, index$c_executableStruct as executableStruct, index$c_executeInstructionDiscriminator as executeInstructionDiscriminator, index$c_executeStruct as executeStruct, index$c_initExecutorInstructionDiscriminator as initExecutorInstructionDiscriminator, index$c_initExecutorStruct as initExecutorStruct, index$c_nativeDropInstructionDiscriminator as nativeDropInstructionDiscriminator, index$c_nativeDropStruct as nativeDropStruct, index$c_ownerSetConfigInstructionDiscriminator as ownerSetConfigInstructionDiscriminator, index$c_ownerSetConfigStruct as ownerSetConfigStruct, index$c_quoteExecutorInstructionDiscriminator as quoteExecutorInstructionDiscriminator, index$c_quoteExecutorStruct as quoteExecutorStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum ExecutionState {
    NotExecutable = 0,
    VerifiedButNotExecutable = 1,
    Executable = 2,
    Executed = 3
}
/**
 * @category userTypes
 * @category generated
 */
declare const executionStateBeet: beet.FixedSizeBeet<ExecutionState, ExecutionState>;

type index$b_AdminSetConfigParams = AdminSetConfigParams;
type index$b_AdminSetConfigParamsRecord = AdminSetConfigParamsRecord;
type index$b_ComposeParams = ComposeParams;
type index$b_ExecutableParams = ExecutableParams;
type index$b_ExecuteParams = ExecuteParams;
type index$b_ExecutionState = ExecutionState;
declare const index$b_ExecutionState: typeof ExecutionState;
type index$b_InitExecutorParams = InitExecutorParams;
type index$b_NativeDropParams = NativeDropParams;
type index$b_NativeDropRequest = NativeDropRequest;
type index$b_OwnerSetConfigParams = OwnerSetConfigParams;
type index$b_OwnerSetConfigParamsRecord = OwnerSetConfigParamsRecord;
type index$b_QuoteExecutorParams = QuoteExecutorParams;
declare const index$b_adminSetConfigParamsBeet: typeof adminSetConfigParamsBeet;
declare const index$b_composeParamsBeet: typeof composeParamsBeet;
declare const index$b_executableParamsBeet: typeof executableParamsBeet;
declare const index$b_executeParamsBeet: typeof executeParamsBeet;
declare const index$b_executionStateBeet: typeof executionStateBeet;
declare const index$b_initExecutorParamsBeet: typeof initExecutorParamsBeet;
declare const index$b_isAdminSetConfigParamsDefaultMultiplierBps: typeof isAdminSetConfigParamsDefaultMultiplierBps;
declare const index$b_isAdminSetConfigParamsDstConfigs: typeof isAdminSetConfigParamsDstConfigs;
declare const index$b_isAdminSetConfigParamsPriceFeed: typeof isAdminSetConfigParamsPriceFeed;
declare const index$b_isOwnerSetConfigParamsAdmins: typeof isOwnerSetConfigParamsAdmins;
declare const index$b_isOwnerSetConfigParamsAllowlist: typeof isOwnerSetConfigParamsAllowlist;
declare const index$b_isOwnerSetConfigParamsDenylist: typeof isOwnerSetConfigParamsDenylist;
declare const index$b_isOwnerSetConfigParamsExecutors: typeof isOwnerSetConfigParamsExecutors;
declare const index$b_isOwnerSetConfigParamsMsglibs: typeof isOwnerSetConfigParamsMsglibs;
declare const index$b_isOwnerSetConfigParamsOwner: typeof isOwnerSetConfigParamsOwner;
declare const index$b_isOwnerSetConfigParamsPaused: typeof isOwnerSetConfigParamsPaused;
declare const index$b_lzComposeParamsBeet: typeof lzComposeParamsBeet;
declare const index$b_nativeDropParamsBeet: typeof nativeDropParamsBeet;
declare const index$b_nativeDropRequestBeet: typeof nativeDropRequestBeet;
declare const index$b_ownerSetConfigParamsBeet: typeof ownerSetConfigParamsBeet;
declare const index$b_quoteExecutorParamsBeet: typeof quoteExecutorParamsBeet;
declare namespace index$b {
  export { type Acl$1 as Acl, type index$b_AdminSetConfigParams as AdminSetConfigParams, type index$b_AdminSetConfigParamsRecord as AdminSetConfigParamsRecord, type index$b_ComposeParams as ComposeParams, type DstConfig$1 as DstConfig, type index$b_ExecutableParams as ExecutableParams, type index$b_ExecuteParams as ExecuteParams, index$b_ExecutionState as ExecutionState, type index$b_InitExecutorParams as InitExecutorParams, type LzComposeParams$1 as LzComposeParams, type LzOption$1 as LzOption, type LzReceiveParams$2 as LzReceiveParams, type index$b_NativeDropParams as NativeDropParams, type index$b_NativeDropRequest as NativeDropRequest, type index$b_OwnerSetConfigParams as OwnerSetConfigParams, type index$b_OwnerSetConfigParamsRecord as OwnerSetConfigParamsRecord, type index$b_QuoteExecutorParams as QuoteExecutorParams, aclBeet$1 as aclBeet, index$b_adminSetConfigParamsBeet as adminSetConfigParamsBeet, index$b_composeParamsBeet as composeParamsBeet, dstConfigBeet$1 as dstConfigBeet, index$b_executableParamsBeet as executableParamsBeet, index$b_executeParamsBeet as executeParamsBeet, index$b_executionStateBeet as executionStateBeet, index$b_initExecutorParamsBeet as initExecutorParamsBeet, index$b_isAdminSetConfigParamsDefaultMultiplierBps as isAdminSetConfigParamsDefaultMultiplierBps, index$b_isAdminSetConfigParamsDstConfigs as isAdminSetConfigParamsDstConfigs, index$b_isAdminSetConfigParamsPriceFeed as isAdminSetConfigParamsPriceFeed, index$b_isOwnerSetConfigParamsAdmins as isOwnerSetConfigParamsAdmins, index$b_isOwnerSetConfigParamsAllowlist as isOwnerSetConfigParamsAllowlist, index$b_isOwnerSetConfigParamsDenylist as isOwnerSetConfigParamsDenylist, index$b_isOwnerSetConfigParamsExecutors as isOwnerSetConfigParamsExecutors, index$b_isOwnerSetConfigParamsMsglibs as isOwnerSetConfigParamsMsglibs, index$b_isOwnerSetConfigParamsOwner as isOwnerSetConfigParamsOwner, index$b_isOwnerSetConfigParamsPaused as isOwnerSetConfigParamsPaused, index$b_lzComposeParamsBeet as lzComposeParamsBeet, lzOptionBeet$1 as lzOptionBeet, lzReceiveParamsBeet$1 as lzReceiveParamsBeet, index$b_nativeDropParamsBeet as nativeDropParamsBeet, index$b_nativeDropRequestBeet as nativeDropRequestBeet, index$b_ownerSetConfigParamsBeet as ownerSetConfigParamsBeet, index$b_quoteExecutorParamsBeet as quoteExecutorParamsBeet };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode$2 = Error & {
    code: number;
};
type MaybeErrorWithCode$2 = ErrorWithCode$2 | null | undefined;
/**
 * InvalidSize: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Paused: ''
 *
 * @category Errors
 * @category generated
 */
declare class PausedError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * UnsupportedOptionType: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnsupportedOptionTypeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ZeroLzComposeGasProvided: ''
 *
 * @category Errors
 * @category generated
 */
declare class ZeroLzComposeGasProvidedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ZeroLzReceiveGasProvided: ''
 *
 * @category Errors
 * @category generated
 */
declare class ZeroLzReceiveGasProvidedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NativeAmountExceedsCap: ''
 *
 * @category Errors
 * @category generated
 */
declare class NativeAmountExceedsCapError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NotAdmin: ''
 *
 * @category Errors
 * @category generated
 */
declare class NotAdminError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NotExecutor: ''
 *
 * @category Errors
 * @category generated
 */
declare class NotExecutorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MsgLibNotAllowed: ''
 *
 * @category Errors
 * @category generated
 */
declare class MsgLibNotAllowedError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyAdmins: ''
 *
 * @category Errors
 * @category generated
 */
declare class TooManyAdminsError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyExecutors: ''
 *
 * @category Errors
 * @category generated
 */
declare class TooManyExecutorsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyOptionTypes: ''
 *
 * @category Errors
 * @category generated
 */
declare class TooManyOptionTypesError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidNativeDropRequestsLength: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidNativeDropRequestsLengthError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidNativeDropReceiver: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidNativeDropReceiverError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InsufficientBalance: ''
 *
 * @category Errors
 * @category generated
 */
declare class InsufficientBalanceError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * EidNotSupported: ''
 *
 * @category Errors
 * @category generated
 */
declare class EidNotSupportedError$1 extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ExecutorIsAdmin: ''
 *
 * @category Errors
 * @category generated
 */
declare class ExecutorIsAdminError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode$2(code: number): MaybeErrorWithCode$2;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName$2(name: string): MaybeErrorWithCode$2;

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS$3 = "6doghB248px58JSSwG4qejQ46kFMW4AMj7vzJnWZHNZn";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$4: PublicKey;

declare class Executor {
    program: PublicKey;
    deriver: ExecutorPDADeriver;
    constructor(program: PublicKey);
    initExecutor(connection: Connection, payer: PublicKey, owner: PublicKey, admins: PublicKey[], executors: PublicKey[], msglibs: PublicKey[], priceFeed: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
    setOwner(owner: PublicKey, newOwner: PublicKey): TransactionInstruction;
    setAdmins(owner: PublicKey, admins: PublicKey[]): TransactionInstruction;
    setAllowList(owner: PublicKey, allowlist: PublicKey[]): TransactionInstruction;
    setDenyList(owner: PublicKey, denylist: PublicKey[]): TransactionInstruction;
    setPaused(owner: PublicKey, paused: boolean): TransactionInstruction;
    setExecutors(owner: PublicKey, executors: PublicKey[]): TransactionInstruction;
    setMsglibs(owner: PublicKey, msglibPrograms: PublicKey[]): TransactionInstruction;
    setDefaultMultiplierBps(admin: PublicKey, defaultMultiplierBps: number): TransactionInstruction;
    setDstConfig(admin: PublicKey, dstConfigs: DstConfig$1[]): TransactionInstruction;
    setPriceFeed(admin: PublicKey, priceFeedProgram: PublicKey): TransactionInstruction;
    getExecutorConfig(connection: Connection, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<ExecutorConfig | null>;
    getQuoteIXAccountMetaForCPI(connection: Connection, payment: boolean, commitment?: Commitment): Promise<AccountMeta[]>;
    execute(connection: Connection, executor: PublicKey, endpointProgram: PublicKey, packet: Packet$2, extraData: Uint8Array, value?: BN, computeUnits?: number, commitmentOrConfig?: Commitment): Promise<TransactionInstruction>;
    compose(connection: Connection, executor: PublicKey, endpointProgram: PublicKey, event: ComposeSentEvent, extraData: Uint8Array, value?: BN, computeUnits?: number, commitmentOrConfig?: Commitment): Promise<TransactionInstruction>;
}

type executor_AdminSetConfigInstructionAccounts = AdminSetConfigInstructionAccounts;
type executor_AdminSetConfigInstructionArgs = AdminSetConfigInstructionArgs;
type executor_AdminSetConfigParams = AdminSetConfigParams;
type executor_AdminSetConfigParamsRecord = AdminSetConfigParamsRecord;
type executor_ComposeInstructionAccounts = ComposeInstructionAccounts;
type executor_ComposeInstructionArgs = ComposeInstructionArgs;
type executor_ComposeParams = ComposeParams;
type executor_ExecutableInstructionAccounts = ExecutableInstructionAccounts;
type executor_ExecutableInstructionArgs = ExecutableInstructionArgs;
type executor_ExecutableParams = ExecutableParams;
type executor_ExecuteInstructionAccounts = ExecuteInstructionAccounts;
type executor_ExecuteInstructionArgs = ExecuteInstructionArgs;
type executor_ExecuteParams = ExecuteParams;
type executor_ExecutionState = ExecutionState;
declare const executor_ExecutionState: typeof ExecutionState;
type executor_Executor = Executor;
declare const executor_Executor: typeof Executor;
type executor_ExecutorConfig = ExecutorConfig;
declare const executor_ExecutorConfig: typeof ExecutorConfig;
type executor_ExecutorConfigArgs = ExecutorConfigArgs;
type executor_ExecutorIsAdminError = ExecutorIsAdminError;
declare const executor_ExecutorIsAdminError: typeof ExecutorIsAdminError;
type executor_InitExecutorInstructionAccounts = InitExecutorInstructionAccounts;
type executor_InitExecutorInstructionArgs = InitExecutorInstructionArgs;
type executor_InitExecutorParams = InitExecutorParams;
type executor_InsufficientBalanceError = InsufficientBalanceError;
declare const executor_InsufficientBalanceError: typeof InsufficientBalanceError;
type executor_InvalidNativeDropReceiverError = InvalidNativeDropReceiverError;
declare const executor_InvalidNativeDropReceiverError: typeof InvalidNativeDropReceiverError;
type executor_InvalidNativeDropRequestsLengthError = InvalidNativeDropRequestsLengthError;
declare const executor_InvalidNativeDropRequestsLengthError: typeof InvalidNativeDropRequestsLengthError;
type executor_InvalidSizeError = InvalidSizeError;
declare const executor_InvalidSizeError: typeof InvalidSizeError;
type executor_NativeAmountExceedsCapError = NativeAmountExceedsCapError;
declare const executor_NativeAmountExceedsCapError: typeof NativeAmountExceedsCapError;
type executor_NativeDropInstructionAccounts = NativeDropInstructionAccounts;
type executor_NativeDropInstructionArgs = NativeDropInstructionArgs;
type executor_NativeDropParams = NativeDropParams;
type executor_NativeDropRequest = NativeDropRequest;
type executor_Nonce = Nonce;
declare const executor_Nonce: typeof Nonce;
type executor_NonceArgs = NonceArgs;
type executor_NotExecutorError = NotExecutorError;
declare const executor_NotExecutorError: typeof NotExecutorError;
type executor_OwnerSetConfigInstructionAccounts = OwnerSetConfigInstructionAccounts;
type executor_OwnerSetConfigInstructionArgs = OwnerSetConfigInstructionArgs;
type executor_OwnerSetConfigParams = OwnerSetConfigParams;
type executor_OwnerSetConfigParamsRecord = OwnerSetConfigParamsRecord;
type executor_QuoteExecutorInstructionAccounts = QuoteExecutorInstructionAccounts;
type executor_QuoteExecutorInstructionArgs = QuoteExecutorInstructionArgs;
type executor_QuoteExecutorParams = QuoteExecutorParams;
type executor_TooManyExecutorsError = TooManyExecutorsError;
declare const executor_TooManyExecutorsError: typeof TooManyExecutorsError;
type executor_UnsupportedOptionTypeError = UnsupportedOptionTypeError;
declare const executor_UnsupportedOptionTypeError: typeof UnsupportedOptionTypeError;
type executor_ZeroLzComposeGasProvidedError = ZeroLzComposeGasProvidedError;
declare const executor_ZeroLzComposeGasProvidedError: typeof ZeroLzComposeGasProvidedError;
type executor_ZeroLzReceiveGasProvidedError = ZeroLzReceiveGasProvidedError;
declare const executor_ZeroLzReceiveGasProvidedError: typeof ZeroLzReceiveGasProvidedError;
declare const executor_adminSetConfigInstructionDiscriminator: typeof adminSetConfigInstructionDiscriminator;
declare const executor_adminSetConfigParamsBeet: typeof adminSetConfigParamsBeet;
declare const executor_adminSetConfigStruct: typeof adminSetConfigStruct;
declare const executor_composeInstructionDiscriminator: typeof composeInstructionDiscriminator;
declare const executor_composeParamsBeet: typeof composeParamsBeet;
declare const executor_composeStruct: typeof composeStruct;
declare const executor_createAdminSetConfigInstruction: typeof createAdminSetConfigInstruction;
declare const executor_createAdminSetConfigInstructionAccounts: typeof createAdminSetConfigInstructionAccounts;
declare const executor_createComposeInstruction: typeof createComposeInstruction;
declare const executor_createComposeInstructionAccounts: typeof createComposeInstructionAccounts;
declare const executor_createExecutableInstruction: typeof createExecutableInstruction;
declare const executor_createExecutableInstructionAccounts: typeof createExecutableInstructionAccounts;
declare const executor_createExecuteInstruction: typeof createExecuteInstruction;
declare const executor_createExecuteInstructionAccounts: typeof createExecuteInstructionAccounts;
declare const executor_createInitExecutorInstruction: typeof createInitExecutorInstruction;
declare const executor_createInitExecutorInstructionAccounts: typeof createInitExecutorInstructionAccounts;
declare const executor_createNativeDropInstruction: typeof createNativeDropInstruction;
declare const executor_createNativeDropInstructionAccounts: typeof createNativeDropInstructionAccounts;
declare const executor_createOwnerSetConfigInstruction: typeof createOwnerSetConfigInstruction;
declare const executor_createOwnerSetConfigInstructionAccounts: typeof createOwnerSetConfigInstructionAccounts;
declare const executor_createQuoteExecutorInstruction: typeof createQuoteExecutorInstruction;
declare const executor_createQuoteExecutorInstructionAccounts: typeof createQuoteExecutorInstructionAccounts;
declare const executor_executableInstructionDiscriminator: typeof executableInstructionDiscriminator;
declare const executor_executableParamsBeet: typeof executableParamsBeet;
declare const executor_executableStruct: typeof executableStruct;
declare const executor_executeInstructionDiscriminator: typeof executeInstructionDiscriminator;
declare const executor_executeParamsBeet: typeof executeParamsBeet;
declare const executor_executeStruct: typeof executeStruct;
declare const executor_executionStateBeet: typeof executionStateBeet;
declare const executor_executorConfigBeet: typeof executorConfigBeet;
declare const executor_executorConfigDiscriminator: typeof executorConfigDiscriminator;
declare const executor_initExecutorInstructionDiscriminator: typeof initExecutorInstructionDiscriminator;
declare const executor_initExecutorParamsBeet: typeof initExecutorParamsBeet;
declare const executor_initExecutorStruct: typeof initExecutorStruct;
declare const executor_isAdminSetConfigParamsDefaultMultiplierBps: typeof isAdminSetConfigParamsDefaultMultiplierBps;
declare const executor_isAdminSetConfigParamsDstConfigs: typeof isAdminSetConfigParamsDstConfigs;
declare const executor_isAdminSetConfigParamsPriceFeed: typeof isAdminSetConfigParamsPriceFeed;
declare const executor_isOwnerSetConfigParamsAdmins: typeof isOwnerSetConfigParamsAdmins;
declare const executor_isOwnerSetConfigParamsAllowlist: typeof isOwnerSetConfigParamsAllowlist;
declare const executor_isOwnerSetConfigParamsDenylist: typeof isOwnerSetConfigParamsDenylist;
declare const executor_isOwnerSetConfigParamsExecutors: typeof isOwnerSetConfigParamsExecutors;
declare const executor_isOwnerSetConfigParamsMsglibs: typeof isOwnerSetConfigParamsMsglibs;
declare const executor_isOwnerSetConfigParamsOwner: typeof isOwnerSetConfigParamsOwner;
declare const executor_isOwnerSetConfigParamsPaused: typeof isOwnerSetConfigParamsPaused;
declare const executor_lzComposeParamsBeet: typeof lzComposeParamsBeet;
declare const executor_nativeDropInstructionDiscriminator: typeof nativeDropInstructionDiscriminator;
declare const executor_nativeDropParamsBeet: typeof nativeDropParamsBeet;
declare const executor_nativeDropRequestBeet: typeof nativeDropRequestBeet;
declare const executor_nativeDropStruct: typeof nativeDropStruct;
declare const executor_nonceBeet: typeof nonceBeet;
declare const executor_nonceDiscriminator: typeof nonceDiscriminator;
declare const executor_ownerSetConfigInstructionDiscriminator: typeof ownerSetConfigInstructionDiscriminator;
declare const executor_ownerSetConfigParamsBeet: typeof ownerSetConfigParamsBeet;
declare const executor_ownerSetConfigStruct: typeof ownerSetConfigStruct;
declare const executor_quoteExecutorInstructionDiscriminator: typeof quoteExecutorInstructionDiscriminator;
declare const executor_quoteExecutorParamsBeet: typeof quoteExecutorParamsBeet;
declare const executor_quoteExecutorStruct: typeof quoteExecutorStruct;
declare namespace executor {
  export { type Acl$1 as Acl, type executor_AdminSetConfigInstructionAccounts as AdminSetConfigInstructionAccounts, type executor_AdminSetConfigInstructionArgs as AdminSetConfigInstructionArgs, type executor_AdminSetConfigParams as AdminSetConfigParams, type executor_AdminSetConfigParamsRecord as AdminSetConfigParamsRecord, type executor_ComposeInstructionAccounts as ComposeInstructionAccounts, type executor_ComposeInstructionArgs as ComposeInstructionArgs, type executor_ComposeParams as ComposeParams, type DstConfig$1 as DstConfig, EidNotSupportedError$1 as EidNotSupportedError, type executor_ExecutableInstructionAccounts as ExecutableInstructionAccounts, type executor_ExecutableInstructionArgs as ExecutableInstructionArgs, type executor_ExecutableParams as ExecutableParams, type executor_ExecuteInstructionAccounts as ExecuteInstructionAccounts, type executor_ExecuteInstructionArgs as ExecuteInstructionArgs, type executor_ExecuteParams as ExecuteParams, executor_ExecutionState as ExecutionState, executor_Executor as Executor, executor_ExecutorConfig as ExecutorConfig, type executor_ExecutorConfigArgs as ExecutorConfigArgs, executor_ExecutorIsAdminError as ExecutorIsAdminError, type executor_InitExecutorInstructionAccounts as InitExecutorInstructionAccounts, type executor_InitExecutorInstructionArgs as InitExecutorInstructionArgs, type executor_InitExecutorParams as InitExecutorParams, executor_InsufficientBalanceError as InsufficientBalanceError, executor_InvalidNativeDropReceiverError as InvalidNativeDropReceiverError, executor_InvalidNativeDropRequestsLengthError as InvalidNativeDropRequestsLengthError, executor_InvalidSizeError as InvalidSizeError, type LzComposeParams$1 as LzComposeParams, type LzOption$1 as LzOption, type LzReceiveParams$2 as LzReceiveParams, MsgLibNotAllowedError$1 as MsgLibNotAllowedError, executor_NativeAmountExceedsCapError as NativeAmountExceedsCapError, type executor_NativeDropInstructionAccounts as NativeDropInstructionAccounts, type executor_NativeDropInstructionArgs as NativeDropInstructionArgs, type executor_NativeDropParams as NativeDropParams, type executor_NativeDropRequest as NativeDropRequest, executor_Nonce as Nonce, type executor_NonceArgs as NonceArgs, NotAdminError$1 as NotAdminError, executor_NotExecutorError as NotExecutorError, type executor_OwnerSetConfigInstructionAccounts as OwnerSetConfigInstructionAccounts, type executor_OwnerSetConfigInstructionArgs as OwnerSetConfigInstructionArgs, type executor_OwnerSetConfigParams as OwnerSetConfigParams, type executor_OwnerSetConfigParamsRecord as OwnerSetConfigParamsRecord, PROGRAM_ADDRESS$3 as PROGRAM_ADDRESS, PROGRAM_ID$4 as PROGRAM_ID, PausedError$1 as PausedError, type executor_QuoteExecutorInstructionAccounts as QuoteExecutorInstructionAccounts, type executor_QuoteExecutorInstructionArgs as QuoteExecutorInstructionArgs, type executor_QuoteExecutorParams as QuoteExecutorParams, TooManyAdminsError$1 as TooManyAdminsError, executor_TooManyExecutorsError as TooManyExecutorsError, TooManyOptionTypesError$1 as TooManyOptionTypesError, executor_UnsupportedOptionTypeError as UnsupportedOptionTypeError, executor_ZeroLzComposeGasProvidedError as ZeroLzComposeGasProvidedError, executor_ZeroLzReceiveGasProvidedError as ZeroLzReceiveGasProvidedError, accountProviders$3 as accountProviders, index$e as accounts, aclBeet$1 as aclBeet, executor_adminSetConfigInstructionDiscriminator as adminSetConfigInstructionDiscriminator, executor_adminSetConfigParamsBeet as adminSetConfigParamsBeet, executor_adminSetConfigStruct as adminSetConfigStruct, executor_composeInstructionDiscriminator as composeInstructionDiscriminator, executor_composeParamsBeet as composeParamsBeet, executor_composeStruct as composeStruct, executor_createAdminSetConfigInstruction as createAdminSetConfigInstruction, executor_createAdminSetConfigInstructionAccounts as createAdminSetConfigInstructionAccounts, executor_createComposeInstruction as createComposeInstruction, executor_createComposeInstructionAccounts as createComposeInstructionAccounts, executor_createExecutableInstruction as createExecutableInstruction, executor_createExecutableInstructionAccounts as createExecutableInstructionAccounts, executor_createExecuteInstruction as createExecuteInstruction, executor_createExecuteInstructionAccounts as createExecuteInstructionAccounts, executor_createInitExecutorInstruction as createInitExecutorInstruction, executor_createInitExecutorInstructionAccounts as createInitExecutorInstructionAccounts, executor_createNativeDropInstruction as createNativeDropInstruction, executor_createNativeDropInstructionAccounts as createNativeDropInstructionAccounts, executor_createOwnerSetConfigInstruction as createOwnerSetConfigInstruction, executor_createOwnerSetConfigInstructionAccounts as createOwnerSetConfigInstructionAccounts, executor_createQuoteExecutorInstruction as createQuoteExecutorInstruction, executor_createQuoteExecutorInstructionAccounts as createQuoteExecutorInstructionAccounts, dstConfigBeet$1 as dstConfigBeet, errorFromCode$2 as errorFromCode, errorFromName$2 as errorFromName, index$d as events, executor_executableInstructionDiscriminator as executableInstructionDiscriminator, executor_executableParamsBeet as executableParamsBeet, executor_executableStruct as executableStruct, executor_executeInstructionDiscriminator as executeInstructionDiscriminator, executor_executeParamsBeet as executeParamsBeet, executor_executeStruct as executeStruct, executor_executionStateBeet as executionStateBeet, executor_executorConfigBeet as executorConfigBeet, executor_executorConfigDiscriminator as executorConfigDiscriminator, executor_initExecutorInstructionDiscriminator as initExecutorInstructionDiscriminator, executor_initExecutorParamsBeet as initExecutorParamsBeet, executor_initExecutorStruct as initExecutorStruct, index$c as instructions, executor_isAdminSetConfigParamsDefaultMultiplierBps as isAdminSetConfigParamsDefaultMultiplierBps, executor_isAdminSetConfigParamsDstConfigs as isAdminSetConfigParamsDstConfigs, executor_isAdminSetConfigParamsPriceFeed as isAdminSetConfigParamsPriceFeed, executor_isOwnerSetConfigParamsAdmins as isOwnerSetConfigParamsAdmins, executor_isOwnerSetConfigParamsAllowlist as isOwnerSetConfigParamsAllowlist, executor_isOwnerSetConfigParamsDenylist as isOwnerSetConfigParamsDenylist, executor_isOwnerSetConfigParamsExecutors as isOwnerSetConfigParamsExecutors, executor_isOwnerSetConfigParamsMsglibs as isOwnerSetConfigParamsMsglibs, executor_isOwnerSetConfigParamsOwner as isOwnerSetConfigParamsOwner, executor_isOwnerSetConfigParamsPaused as isOwnerSetConfigParamsPaused, executor_lzComposeParamsBeet as lzComposeParamsBeet, lzOptionBeet$1 as lzOptionBeet, lzReceiveParamsBeet$1 as lzReceiveParamsBeet, executor_nativeDropInstructionDiscriminator as nativeDropInstructionDiscriminator, executor_nativeDropParamsBeet as nativeDropParamsBeet, executor_nativeDropRequestBeet as nativeDropRequestBeet, executor_nativeDropStruct as nativeDropStruct, executor_nonceBeet as nonceBeet, executor_nonceDiscriminator as nonceDiscriminator, executor_ownerSetConfigInstructionDiscriminator as ownerSetConfigInstructionDiscriminator, executor_ownerSetConfigParamsBeet as ownerSetConfigParamsBeet, executor_ownerSetConfigStruct as ownerSetConfigStruct, executor_quoteExecutorInstructionDiscriminator as quoteExecutorInstructionDiscriminator, executor_quoteExecutorParamsBeet as quoteExecutorParamsBeet, executor_quoteExecutorStruct as quoteExecutorStruct, index$b as types };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link ModelType} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link ModelType} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type ModelTypeRecord = {
    Arbitrum: {
        gasPerL2Tx: beet.bignum;
        gasPerL1CalldataByte: number;
    };
    Optimism: {
        l1Eid: number;
    };
};
/**
 * Union type respresenting the ModelType data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isModelType*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type ModelType = beet.DataEnumKeyAsKind<ModelTypeRecord>;
declare const isModelTypeArbitrum: (x: ModelType) => x is {
    __kind: "Arbitrum";
} & Omit<{
    gasPerL2Tx: beet.bignum;
    gasPerL1CalldataByte: number;
}, "void"> & {
    __kind: 'Arbitrum';
};
declare const isModelTypeOptimism: (x: ModelType) => x is {
    __kind: "Optimism";
} & Omit<{
    l1Eid: number;
}, "void"> & {
    __kind: 'Optimism';
};
/**
 * @category userTypes
 * @category generated
 */
declare const modelTypeBeet: beet.FixableBeet<ModelType, ModelType>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Price = {
    eid: number;
    priceRatio: beet.bignum;
    gasPriceInUnit: beet.bignum;
    gasPerByte: number;
    modelType: beet.COption<ModelType>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const priceBeet: beet.FixableBeetArgsStruct<Price>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link PriceFeed}
 * @category Accounts
 * @category generated
 */
type PriceFeedArgs = {
    admin: web3.PublicKey;
    updaters: web3.PublicKey[];
    priceRatioDenominator: beet.bignum;
    arbitrumCompressionPercent: beet.bignum;
    nativeTokenPriceUsd: beet.COption<beet.bignum>;
    prices: Price[];
    bump: number;
};
declare const priceFeedDiscriminator: number[];
/**
 * Holds the data for the {@link PriceFeed} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class PriceFeed$1 implements PriceFeedArgs {
    readonly admin: web3.PublicKey;
    readonly updaters: web3.PublicKey[];
    readonly priceRatioDenominator: beet.bignum;
    readonly arbitrumCompressionPercent: beet.bignum;
    readonly nativeTokenPriceUsd: beet.COption<beet.bignum>;
    readonly prices: Price[];
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link PriceFeed} instance from the provided args.
     */
    static fromArgs(args: PriceFeedArgs): PriceFeed$1;
    /**
     * Deserializes the {@link PriceFeed} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [PriceFeed$1, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link PriceFeed} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<PriceFeed$1>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<PriceFeedArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link PriceFeed} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [PriceFeed$1, number];
    /**
     * Serializes the {@link PriceFeed} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link PriceFeed} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: PriceFeedArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link PriceFeed} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: PriceFeedArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link PriceFeed} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        admin: string;
        updaters: web3.PublicKey[];
        priceRatioDenominator: number | {
            toNumber: () => number;
        };
        arbitrumCompressionPercent: number | {
            toNumber: () => number;
        };
        nativeTokenPriceUsd: beet.COption<beet.bignum>;
        prices: Price[];
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const priceFeedBeet: beet.FixableBeetStruct<PriceFeed$1, PriceFeedArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$2: {
    PriceFeed: typeof PriceFeed$1;
};

type index$a_PriceFeedArgs = PriceFeedArgs;
declare const index$a_priceFeedBeet: typeof priceFeedBeet;
declare const index$a_priceFeedDiscriminator: typeof priceFeedDiscriminator;
declare namespace index$a {
  export { PriceFeed$1 as PriceFeed, type index$a_PriceFeedArgs as PriceFeedArgs, accountProviders$2 as accountProviders, index$a_priceFeedBeet as priceFeedBeet, index$a_priceFeedDiscriminator as priceFeedDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type GetFeeParams = {
    dstEid: number;
    calldataSize: beet.bignum;
    totalGas: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const getFeeParamsBeet: beet.BeetArgsStruct<GetFeeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category GetFee
 * @category generated
 */
type GetFeeInstructionArgs = {
    params: GetFeeParams;
};
/**
 * @category Instructions
 * @category GetFee
 * @category generated
 */
declare const getFeeStruct: beet.BeetArgsStruct<GetFeeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _getFee_ instruction
 *
 * @property [] priceFeed
 * @category Instructions
 * @category GetFee
 * @category generated
 */
type GetFeeInstructionAccounts = {
    priceFeed: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const getFeeInstructionDiscriminator: number[];
/**
 * Creates a _GetFee_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category GetFee
 * @category generated
 */
declare function createGetFeeInstruction(accounts: GetFeeInstructionAccounts, args: GetFeeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _GetFee_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category GetFee
 * @category generated
 */
declare function createGetFeeInstructionAccounts(accounts: GetFeeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitPriceFeedParams = {
    admin: web3.PublicKey;
    updaters: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const initPriceFeedParamsBeet: beet.FixableBeetArgsStruct<InitPriceFeedParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitPriceFeed
 * @category generated
 */
type InitPriceFeedInstructionArgs = {
    params: InitPriceFeedParams;
};
/**
 * @category Instructions
 * @category InitPriceFeed
 * @category generated
 */
declare const initPriceFeedStruct: beet.FixableBeetArgsStruct<InitPriceFeedInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initPriceFeed_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] priceFeed
 * @category Instructions
 * @category InitPriceFeed
 * @category generated
 */
type InitPriceFeedInstructionAccounts = {
    payer: web3.PublicKey;
    priceFeed: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initPriceFeedInstructionDiscriminator: number[];
/**
 * Creates a _InitPriceFeed_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitPriceFeed
 * @category generated
 */
declare function createInitPriceFeedInstruction(accounts: InitPriceFeedInstructionAccounts, args: InitPriceFeedInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitPriceFeed_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitPriceFeed
 * @category generated
 */
declare function createInitPriceFeedInstructionAccounts(accounts: InitPriceFeedInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PriceParams = {
    priceRatio: beet.bignum;
    gasPriceInUnit: beet.bignum;
    gasPerByte: number;
    modelType: beet.COption<ModelType>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const priceParamsBeet: beet.FixableBeetArgsStruct<PriceParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetPriceParams = {
    dstEid: number;
    params: beet.COption<PriceParams>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setPriceParamsBeet: beet.FixableBeetArgsStruct<SetPriceParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetPrice
 * @category generated
 */
type SetPriceInstructionArgs = {
    params: SetPriceParams;
};
/**
 * @category Instructions
 * @category SetPrice
 * @category generated
 */
declare const setPriceStruct: beet.FixableBeetArgsStruct<SetPriceInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setPrice_ instruction
 *
 * @property [**signer**] updater
 * @property [_writable_] priceFeed
 * @category Instructions
 * @category SetPrice
 * @category generated
 */
type SetPriceInstructionAccounts = {
    updater: web3.PublicKey;
    priceFeed: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setPriceInstructionDiscriminator: number[];
/**
 * Creates a _SetPrice_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetPrice
 * @category generated
 */
declare function createSetPriceInstruction(accounts: SetPriceInstructionAccounts, args: SetPriceInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetPrice_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetPrice
 * @category generated
 */
declare function createSetPriceInstructionAccounts(accounts: SetPriceInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetPriceFeedParams = {
    updaters: web3.PublicKey[];
    priceRatioDenominator: beet.bignum;
    arbitrumCompressionPercent: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setPriceFeedParamsBeet: beet.FixableBeetArgsStruct<SetPriceFeedParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetPriceFeed
 * @category generated
 */
type SetPriceFeedInstructionArgs = {
    params: SetPriceFeedParams;
};
/**
 * @category Instructions
 * @category SetPriceFeed
 * @category generated
 */
declare const setPriceFeedStruct: beet.FixableBeetArgsStruct<SetPriceFeedInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setPriceFeed_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [_writable_] priceFeed
 * @category Instructions
 * @category SetPriceFeed
 * @category generated
 */
type SetPriceFeedInstructionAccounts = {
    admin: web3.PublicKey;
    priceFeed: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setPriceFeedInstructionDiscriminator: number[];
/**
 * Creates a _SetPriceFeed_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetPriceFeed
 * @category generated
 */
declare function createSetPriceFeedInstruction(accounts: SetPriceFeedInstructionAccounts, args: SetPriceFeedInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetPriceFeed_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetPriceFeed
 * @category generated
 */
declare function createSetPriceFeedInstructionAccounts(accounts: SetPriceFeedInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetSolPriceParams = {
    nativeTokenPriceUsd: beet.COption<beet.bignum>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setSolPriceParamsBeet: beet.FixableBeetArgsStruct<SetSolPriceParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetSolPrice
 * @category generated
 */
type SetSolPriceInstructionArgs = {
    params: SetSolPriceParams;
};
/**
 * @category Instructions
 * @category SetSolPrice
 * @category generated
 */
declare const setSolPriceStruct: beet.FixableBeetArgsStruct<SetSolPriceInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setSolPrice_ instruction
 *
 * @property [**signer**] updater
 * @property [_writable_] priceFeed
 * @category Instructions
 * @category SetSolPrice
 * @category generated
 */
type SetSolPriceInstructionAccounts = {
    updater: web3.PublicKey;
    priceFeed: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setSolPriceInstructionDiscriminator: number[];
/**
 * Creates a _SetSolPrice_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetSolPrice
 * @category generated
 */
declare function createSetSolPriceInstruction(accounts: SetSolPriceInstructionAccounts, args: SetSolPriceInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetSolPrice_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetSolPrice
 * @category generated
 */
declare function createSetSolPriceInstructionAccounts(accounts: SetSolPriceInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransferAdminParams$1 = {
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transferAdminParamsBeet$1: beet.BeetArgsStruct<TransferAdminParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionArgs$1 = {
    params: TransferAdminParams$1;
};
/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare const transferAdminStruct$1: beet.BeetArgsStruct<TransferAdminInstructionArgs$1 & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _transferAdmin_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] priceFeed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionAccounts$1 = {
    admin: web3.PublicKey;
    priceFeed: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const transferAdminInstructionDiscriminator$1: number[];
/**
 * Creates a _TransferAdmin_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstruction$1(accounts: TransferAdminInstructionAccounts$1, args: TransferAdminInstructionArgs$1, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _TransferAdmin_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstructionAccounts$1(accounts: TransferAdminInstructionAccounts$1, programId?: web3.PublicKey): web3.AccountMeta[];

type index$9_GetFeeInstructionAccounts = GetFeeInstructionAccounts;
type index$9_GetFeeInstructionArgs = GetFeeInstructionArgs;
type index$9_InitPriceFeedInstructionAccounts = InitPriceFeedInstructionAccounts;
type index$9_InitPriceFeedInstructionArgs = InitPriceFeedInstructionArgs;
type index$9_SetPriceFeedInstructionAccounts = SetPriceFeedInstructionAccounts;
type index$9_SetPriceFeedInstructionArgs = SetPriceFeedInstructionArgs;
type index$9_SetPriceInstructionAccounts = SetPriceInstructionAccounts;
type index$9_SetPriceInstructionArgs = SetPriceInstructionArgs;
type index$9_SetSolPriceInstructionAccounts = SetSolPriceInstructionAccounts;
type index$9_SetSolPriceInstructionArgs = SetSolPriceInstructionArgs;
declare const index$9_createGetFeeInstruction: typeof createGetFeeInstruction;
declare const index$9_createGetFeeInstructionAccounts: typeof createGetFeeInstructionAccounts;
declare const index$9_createInitPriceFeedInstruction: typeof createInitPriceFeedInstruction;
declare const index$9_createInitPriceFeedInstructionAccounts: typeof createInitPriceFeedInstructionAccounts;
declare const index$9_createSetPriceFeedInstruction: typeof createSetPriceFeedInstruction;
declare const index$9_createSetPriceFeedInstructionAccounts: typeof createSetPriceFeedInstructionAccounts;
declare const index$9_createSetPriceInstruction: typeof createSetPriceInstruction;
declare const index$9_createSetPriceInstructionAccounts: typeof createSetPriceInstructionAccounts;
declare const index$9_createSetSolPriceInstruction: typeof createSetSolPriceInstruction;
declare const index$9_createSetSolPriceInstructionAccounts: typeof createSetSolPriceInstructionAccounts;
declare const index$9_getFeeInstructionDiscriminator: typeof getFeeInstructionDiscriminator;
declare const index$9_getFeeStruct: typeof getFeeStruct;
declare const index$9_initPriceFeedInstructionDiscriminator: typeof initPriceFeedInstructionDiscriminator;
declare const index$9_initPriceFeedStruct: typeof initPriceFeedStruct;
declare const index$9_setPriceFeedInstructionDiscriminator: typeof setPriceFeedInstructionDiscriminator;
declare const index$9_setPriceFeedStruct: typeof setPriceFeedStruct;
declare const index$9_setPriceInstructionDiscriminator: typeof setPriceInstructionDiscriminator;
declare const index$9_setPriceStruct: typeof setPriceStruct;
declare const index$9_setSolPriceInstructionDiscriminator: typeof setSolPriceInstructionDiscriminator;
declare const index$9_setSolPriceStruct: typeof setSolPriceStruct;
declare namespace index$9 {
  export { type index$9_GetFeeInstructionAccounts as GetFeeInstructionAccounts, type index$9_GetFeeInstructionArgs as GetFeeInstructionArgs, type index$9_InitPriceFeedInstructionAccounts as InitPriceFeedInstructionAccounts, type index$9_InitPriceFeedInstructionArgs as InitPriceFeedInstructionArgs, type index$9_SetPriceFeedInstructionAccounts as SetPriceFeedInstructionAccounts, type index$9_SetPriceFeedInstructionArgs as SetPriceFeedInstructionArgs, type index$9_SetPriceInstructionAccounts as SetPriceInstructionAccounts, type index$9_SetPriceInstructionArgs as SetPriceInstructionArgs, type index$9_SetSolPriceInstructionAccounts as SetSolPriceInstructionAccounts, type index$9_SetSolPriceInstructionArgs as SetSolPriceInstructionArgs, type TransferAdminInstructionAccounts$1 as TransferAdminInstructionAccounts, type TransferAdminInstructionArgs$1 as TransferAdminInstructionArgs, index$9_createGetFeeInstruction as createGetFeeInstruction, index$9_createGetFeeInstructionAccounts as createGetFeeInstructionAccounts, index$9_createInitPriceFeedInstruction as createInitPriceFeedInstruction, index$9_createInitPriceFeedInstructionAccounts as createInitPriceFeedInstructionAccounts, index$9_createSetPriceFeedInstruction as createSetPriceFeedInstruction, index$9_createSetPriceFeedInstructionAccounts as createSetPriceFeedInstructionAccounts, index$9_createSetPriceInstruction as createSetPriceInstruction, index$9_createSetPriceInstructionAccounts as createSetPriceInstructionAccounts, index$9_createSetSolPriceInstruction as createSetSolPriceInstruction, index$9_createSetSolPriceInstructionAccounts as createSetSolPriceInstructionAccounts, createTransferAdminInstruction$1 as createTransferAdminInstruction, createTransferAdminInstructionAccounts$1 as createTransferAdminInstructionAccounts, index$9_getFeeInstructionDiscriminator as getFeeInstructionDiscriminator, index$9_getFeeStruct as getFeeStruct, index$9_initPriceFeedInstructionDiscriminator as initPriceFeedInstructionDiscriminator, index$9_initPriceFeedStruct as initPriceFeedStruct, index$9_setPriceFeedInstructionDiscriminator as setPriceFeedInstructionDiscriminator, index$9_setPriceFeedStruct as setPriceFeedStruct, index$9_setPriceInstructionDiscriminator as setPriceInstructionDiscriminator, index$9_setPriceStruct as setPriceStruct, index$9_setSolPriceInstructionDiscriminator as setSolPriceInstructionDiscriminator, index$9_setSolPriceStruct as setSolPriceStruct, transferAdminInstructionDiscriminator$1 as transferAdminInstructionDiscriminator, transferAdminStruct$1 as transferAdminStruct };
}

type index$8_GetFeeParams = GetFeeParams;
type index$8_InitPriceFeedParams = InitPriceFeedParams;
type index$8_ModelType = ModelType;
type index$8_ModelTypeRecord = ModelTypeRecord;
type index$8_Price = Price;
type index$8_PriceParams = PriceParams;
type index$8_SetPriceFeedParams = SetPriceFeedParams;
type index$8_SetPriceParams = SetPriceParams;
type index$8_SetSolPriceParams = SetSolPriceParams;
declare const index$8_getFeeParamsBeet: typeof getFeeParamsBeet;
declare const index$8_initPriceFeedParamsBeet: typeof initPriceFeedParamsBeet;
declare const index$8_isModelTypeArbitrum: typeof isModelTypeArbitrum;
declare const index$8_isModelTypeOptimism: typeof isModelTypeOptimism;
declare const index$8_modelTypeBeet: typeof modelTypeBeet;
declare const index$8_priceBeet: typeof priceBeet;
declare const index$8_priceParamsBeet: typeof priceParamsBeet;
declare const index$8_setPriceFeedParamsBeet: typeof setPriceFeedParamsBeet;
declare const index$8_setPriceParamsBeet: typeof setPriceParamsBeet;
declare const index$8_setSolPriceParamsBeet: typeof setSolPriceParamsBeet;
declare namespace index$8 {
  export { type index$8_GetFeeParams as GetFeeParams, type index$8_InitPriceFeedParams as InitPriceFeedParams, type index$8_ModelType as ModelType, type index$8_ModelTypeRecord as ModelTypeRecord, type index$8_Price as Price, type index$8_PriceParams as PriceParams, type index$8_SetPriceFeedParams as SetPriceFeedParams, type index$8_SetPriceParams as SetPriceParams, type index$8_SetSolPriceParams as SetSolPriceParams, type TransferAdminParams$1 as TransferAdminParams, index$8_getFeeParamsBeet as getFeeParamsBeet, index$8_initPriceFeedParamsBeet as initPriceFeedParamsBeet, index$8_isModelTypeArbitrum as isModelTypeArbitrum, index$8_isModelTypeOptimism as isModelTypeOptimism, index$8_modelTypeBeet as modelTypeBeet, index$8_priceBeet as priceBeet, index$8_priceParamsBeet as priceParamsBeet, index$8_setPriceFeedParamsBeet as setPriceFeedParamsBeet, index$8_setPriceParamsBeet as setPriceParamsBeet, index$8_setSolPriceParamsBeet as setSolPriceParamsBeet, transferAdminParamsBeet$1 as transferAdminParamsBeet };
}

/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$3: PublicKey;

declare class PriceFeed {
    readonly program: PublicKey;
    deriver: PriceFeedPDADeriver;
    constructor(program: PublicKey);
    initPriceFeed(connection: Connection, payer: PublicKey, admin: PublicKey, updaters: PublicKey[], commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
    setPriceFeed(admin: PublicKey, updaters: PublicKey[], priceRatioDenominator: bignum, arbitrumCompressionPercent: number): TransactionInstruction;
    setPrice(updater: PublicKey, dstEid: number, priceRatio: bignum, gasPriceInUnit: bignum, gasPerByte: number, modelType: ModelType | null): TransactionInstruction;
    setSolPrice(updater: PublicKey, nativeTokenPriceUsd: bignum | null): TransactionInstruction;
    transferAdmin(admin: PublicKey, newAdmin: PublicKey): TransactionInstruction;
    getPriceFeed(connection: Connection, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<PriceFeed$1 | null>;
}

type pricefeed_PriceFeed = PriceFeed;
declare const pricefeed_PriceFeed: typeof PriceFeed;
declare namespace pricefeed {
  export { PROGRAM_ID$3 as PROGRAM_ID, pricefeed_PriceFeed as PriceFeed, index$a as accounts, index$9 as instructions, index$8 as types };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Multisig = {
    signers: number[][];
    quorum: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const multisigBeet: beet.FixableBeetArgsStruct<Multisig>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Acl = {
    allowList: web3.PublicKey[];
    denyList: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const aclBeet: beet.FixableBeetArgsStruct<Acl>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DstConfig = {
    eid: number;
    dstGas: number;
    multiplierBps: beet.COption<number>;
    floorMarginUsd: beet.COption<beet.bignum>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const dstConfigBeet: beet.FixableBeetArgsStruct<DstConfig>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link DvnConfig}
 * @category Accounts
 * @category generated
 */
type DvnConfigArgs = {
    vid: number;
    bump: number;
    multisig: Multisig;
    acl: Acl;
    paused: boolean;
    msglibs: web3.PublicKey[];
    admins: web3.PublicKey[];
    priceFeed: web3.PublicKey;
    dstConfigs: DstConfig[];
    defaultMultiplierBps: number;
};
declare const dvnConfigDiscriminator: number[];
/**
 * Holds the data for the {@link DvnConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class DvnConfig implements DvnConfigArgs {
    readonly vid: number;
    readonly bump: number;
    readonly multisig: Multisig;
    readonly acl: Acl;
    readonly paused: boolean;
    readonly msglibs: web3.PublicKey[];
    readonly admins: web3.PublicKey[];
    readonly priceFeed: web3.PublicKey;
    readonly dstConfigs: DstConfig[];
    readonly defaultMultiplierBps: number;
    private constructor();
    /**
     * Creates a {@link DvnConfig} instance from the provided args.
     */
    static fromArgs(args: DvnConfigArgs): DvnConfig;
    /**
     * Deserializes the {@link DvnConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [DvnConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link DvnConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<DvnConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<DvnConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link DvnConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [DvnConfig, number];
    /**
     * Serializes the {@link DvnConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link DvnConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: DvnConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link DvnConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: DvnConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link DvnConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        vid: number;
        bump: number;
        multisig: Multisig;
        acl: Acl;
        paused: boolean;
        msglibs: web3.PublicKey[];
        admins: web3.PublicKey[];
        priceFeed: string;
        dstConfigs: DstConfig[];
        defaultMultiplierBps: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const dvnConfigBeet: beet.FixableBeetStruct<DvnConfig, DvnConfigArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ExecuteHash}
 * @category Accounts
 * @category generated
 */
type ExecuteHashArgs = {
    expiration: beet.bignum;
    bump: number;
};
declare const executeHashDiscriminator: number[];
/**
 * Holds the data for the {@link ExecuteHash} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ExecuteHash implements ExecuteHashArgs {
    readonly expiration: beet.bignum;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link ExecuteHash} instance from the provided args.
     */
    static fromArgs(args: ExecuteHashArgs): ExecuteHash;
    /**
     * Deserializes the {@link ExecuteHash} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ExecuteHash, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ExecuteHash} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ExecuteHash>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        bump: any;
        accountDiscriminator: any;
        expiration: any;
    }>;
    /**
     * Deserializes the {@link ExecuteHash} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ExecuteHash, number];
    /**
     * Serializes the {@link ExecuteHash} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ExecuteHash}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ExecuteHash} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link ExecuteHash} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link ExecuteHash} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        expiration: number | {
            toNumber: () => number;
        };
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const executeHashBeet: beet.BeetStruct<ExecuteHash, ExecuteHashArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type UlnConfig = {
    confirmations: beet.bignum;
    requiredDvnCount: number;
    optionalDvnCount: number;
    optionalDvnThreshold: number;
    requiredDvns: web3.PublicKey[];
    optionalDvns: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const ulnConfigBeet: beet.FixableBeetArgsStruct<UlnConfig>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link ReceiveConfig}
 * @category Accounts
 * @category generated
 */
type ReceiveConfigArgs = {
    bump: number;
    uln: UlnConfig;
};
declare const receiveConfigDiscriminator: number[];
/**
 * Holds the data for the {@link ReceiveConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class ReceiveConfig implements ReceiveConfigArgs {
    readonly bump: number;
    readonly uln: UlnConfig;
    private constructor();
    /**
     * Creates a {@link ReceiveConfig} instance from the provided args.
     */
    static fromArgs(args: ReceiveConfigArgs): ReceiveConfig;
    /**
     * Deserializes the {@link ReceiveConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [ReceiveConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link ReceiveConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<ReceiveConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<ReceiveConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link ReceiveConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [ReceiveConfig, number];
    /**
     * Serializes the {@link ReceiveConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link ReceiveConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: ReceiveConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link ReceiveConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: ReceiveConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link ReceiveConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        bump: number;
        uln: UlnConfig;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const receiveConfigBeet: beet.FixableBeetStruct<ReceiveConfig, ReceiveConfigArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders$1: {
    DvnConfig: typeof DvnConfig;
    ExecuteHash: typeof ExecuteHash;
    ReceiveConfig: typeof ReceiveConfig;
};

type index$7_DvnConfig = DvnConfig;
declare const index$7_DvnConfig: typeof DvnConfig;
type index$7_DvnConfigArgs = DvnConfigArgs;
type index$7_ExecuteHash = ExecuteHash;
declare const index$7_ExecuteHash: typeof ExecuteHash;
type index$7_ExecuteHashArgs = ExecuteHashArgs;
type index$7_ReceiveConfig = ReceiveConfig;
declare const index$7_ReceiveConfig: typeof ReceiveConfig;
type index$7_ReceiveConfigArgs = ReceiveConfigArgs;
declare const index$7_dvnConfigBeet: typeof dvnConfigBeet;
declare const index$7_dvnConfigDiscriminator: typeof dvnConfigDiscriminator;
declare const index$7_executeHashBeet: typeof executeHashBeet;
declare const index$7_executeHashDiscriminator: typeof executeHashDiscriminator;
declare const index$7_receiveConfigBeet: typeof receiveConfigBeet;
declare const index$7_receiveConfigDiscriminator: typeof receiveConfigDiscriminator;
declare namespace index$7 {
  export { index$7_DvnConfig as DvnConfig, type index$7_DvnConfigArgs as DvnConfigArgs, index$7_ExecuteHash as ExecuteHash, type index$7_ExecuteHashArgs as ExecuteHashArgs, index$7_ReceiveConfig as ReceiveConfig, type index$7_ReceiveConfigArgs as ReceiveConfigArgs, accountProviders$1 as accountProviders, index$7_dvnConfigBeet as dvnConfigBeet, index$7_dvnConfigDiscriminator as dvnConfigDiscriminator, index$7_executeHashBeet as executeHashBeet, index$7_executeHashDiscriminator as executeHashDiscriminator, index$7_receiveConfigBeet as receiveConfigBeet, index$7_receiveConfigDiscriminator as receiveConfigDiscriminator };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode$1 = Error & {
    code: number;
};
type MaybeErrorWithCode$1 = ErrorWithCode$1 | null | undefined;
/**
 * InvalidSignatureLen: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSignatureLenError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NotAdmin: ''
 *
 * @category Errors
 * @category generated
 */
declare class NotAdminError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MsgLibNotAllowed: ''
 *
 * @category Errors
 * @category generated
 */
declare class MsgLibNotAllowedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidQuorum: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidQuorumError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidSignersLen: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSignersLenError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * UniqueOwners: ''
 *
 * @category Errors
 * @category generated
 */
declare class UniqueOwnersError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * SignatureError: ''
 *
 * @category Errors
 * @category generated
 */
declare class SignatureErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * SignerNotInCommittee: ''
 *
 * @category Errors
 * @category generated
 */
declare class SignerNotInCommitteeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyAdmins: ''
 *
 * @category Errors
 * @category generated
 */
declare class TooManyAdminsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyOptionTypes: ''
 *
 * @category Errors
 * @category generated
 */
declare class TooManyOptionTypesError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * DuplicateSignature: ''
 *
 * @category Errors
 * @category generated
 */
declare class DuplicateSignatureError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Expired: ''
 *
 * @category Errors
 * @category generated
 */
declare class ExpiredError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidVid: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidVidError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Paused: ''
 *
 * @category Errors
 * @category generated
 */
declare class PausedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * UnexpiredExecuteHash: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnexpiredExecuteHashError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidAmount: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidAmountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * EidNotSupported: ''
 *
 * @category Errors
 * @category generated
 */
declare class EidNotSupportedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode$1(code: number): MaybeErrorWithCode$1;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName$1(name: string): MaybeErrorWithCode$1;

type index$6_DuplicateSignatureError = DuplicateSignatureError;
declare const index$6_DuplicateSignatureError: typeof DuplicateSignatureError;
type index$6_EidNotSupportedError = EidNotSupportedError;
declare const index$6_EidNotSupportedError: typeof EidNotSupportedError;
type index$6_ExpiredError = ExpiredError;
declare const index$6_ExpiredError: typeof ExpiredError;
type index$6_InvalidAmountError = InvalidAmountError;
declare const index$6_InvalidAmountError: typeof InvalidAmountError;
type index$6_InvalidQuorumError = InvalidQuorumError;
declare const index$6_InvalidQuorumError: typeof InvalidQuorumError;
type index$6_InvalidSignatureLenError = InvalidSignatureLenError;
declare const index$6_InvalidSignatureLenError: typeof InvalidSignatureLenError;
type index$6_InvalidSignersLenError = InvalidSignersLenError;
declare const index$6_InvalidSignersLenError: typeof InvalidSignersLenError;
type index$6_InvalidVidError = InvalidVidError;
declare const index$6_InvalidVidError: typeof InvalidVidError;
type index$6_MsgLibNotAllowedError = MsgLibNotAllowedError;
declare const index$6_MsgLibNotAllowedError: typeof MsgLibNotAllowedError;
type index$6_NotAdminError = NotAdminError;
declare const index$6_NotAdminError: typeof NotAdminError;
type index$6_PausedError = PausedError;
declare const index$6_PausedError: typeof PausedError;
type index$6_SignatureErrorError = SignatureErrorError;
declare const index$6_SignatureErrorError: typeof SignatureErrorError;
type index$6_SignerNotInCommitteeError = SignerNotInCommitteeError;
declare const index$6_SignerNotInCommitteeError: typeof SignerNotInCommitteeError;
type index$6_TooManyAdminsError = TooManyAdminsError;
declare const index$6_TooManyAdminsError: typeof TooManyAdminsError;
type index$6_TooManyOptionTypesError = TooManyOptionTypesError;
declare const index$6_TooManyOptionTypesError: typeof TooManyOptionTypesError;
type index$6_UnexpiredExecuteHashError = UnexpiredExecuteHashError;
declare const index$6_UnexpiredExecuteHashError: typeof UnexpiredExecuteHashError;
type index$6_UniqueOwnersError = UniqueOwnersError;
declare const index$6_UniqueOwnersError: typeof UniqueOwnersError;
declare namespace index$6 {
  export { index$6_DuplicateSignatureError as DuplicateSignatureError, index$6_EidNotSupportedError as EidNotSupportedError, index$6_ExpiredError as ExpiredError, index$6_InvalidAmountError as InvalidAmountError, index$6_InvalidQuorumError as InvalidQuorumError, index$6_InvalidSignatureLenError as InvalidSignatureLenError, index$6_InvalidSignersLenError as InvalidSignersLenError, index$6_InvalidVidError as InvalidVidError, index$6_MsgLibNotAllowedError as MsgLibNotAllowedError, index$6_NotAdminError as NotAdminError, index$6_PausedError as PausedError, index$6_SignatureErrorError as SignatureErrorError, index$6_SignerNotInCommitteeError as SignerNotInCommitteeError, index$6_TooManyAdminsError as TooManyAdminsError, index$6_TooManyOptionTypesError as TooManyOptionTypesError, index$6_UnexpiredExecuteHashError as UnexpiredExecuteHashError, index$6_UniqueOwnersError as UniqueOwnersError, errorFromCode$1 as errorFromCode, errorFromName$1 as errorFromName };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CloseExecuteParams = {
    digestHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const closeExecuteParamsBeet: beet.BeetArgsStruct<CloseExecuteParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CloseExecute
 * @category generated
 */
type CloseExecuteInstructionArgs = {
    params: CloseExecuteParams;
};
/**
 * @category Instructions
 * @category CloseExecute
 * @category generated
 */
declare const closeExecuteStruct: beet.BeetArgsStruct<CloseExecuteInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _closeExecute_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] config
 * @property [_writable_] executeHash
 * @category Instructions
 * @category CloseExecute
 * @category generated
 */
type CloseExecuteInstructionAccounts = {
    admin: web3.PublicKey;
    config: web3.PublicKey;
    executeHash: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const closeExecuteInstructionDiscriminator: number[];
/**
 * Creates a _CloseExecute_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CloseExecute
 * @category generated
 */
declare function createCloseExecuteInstruction(accounts: CloseExecuteInstructionAccounts, args: CloseExecuteInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _CloseExecute_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CloseExecute
 * @category generated
 */
declare function createCloseExecuteInstructionAccounts(accounts: CloseExecuteInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitDvnParams = {
    vid: number;
    msglibs: web3.PublicKey[];
    priceFeed: web3.PublicKey;
    signers: number[][];
    quorum: number;
    admins: web3.PublicKey[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const initDvnParamsBeet: beet.FixableBeetArgsStruct<InitDvnParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitDvn
 * @category generated
 */
type InitDvnInstructionArgs = {
    params: InitDvnParams;
};
/**
 * @category Instructions
 * @category InitDvn
 * @category generated
 */
declare const initDvnStruct: beet.FixableBeetArgsStruct<InitDvnInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initDvn_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] config
 * @category Instructions
 * @category InitDvn
 * @category generated
 */
type InitDvnInstructionAccounts = {
    payer: web3.PublicKey;
    config: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initDvnInstructionDiscriminator: number[];
/**
 * Creates a _InitDvn_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitDvn
 * @category generated
 */
declare function createInitDvnInstruction(accounts: InitDvnInstructionAccounts, args: InitDvnInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitDvn_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitDvn
 * @category generated
 */
declare function createInitDvnInstructionAccounts(accounts: InitDvnInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransactionAccount = {
    pubkey: web3.PublicKey;
    isSigner: boolean;
    isWritable: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transactionAccountBeet: beet.BeetArgsStruct<TransactionAccount>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ExecuteTransactionDigest = {
    vid: number;
    programId: web3.PublicKey;
    accounts: TransactionAccount[];
    data: Uint8Array;
    expiration: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const executeTransactionDigestBeet: beet.FixableBeetArgsStruct<ExecuteTransactionDigest>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InvokeParams = {
    digest: ExecuteTransactionDigest;
    signatures: number[][];
};
/**
 * @category userTypes
 * @category generated
 */
declare const invokeParamsBeet: beet.FixableBeetArgsStruct<InvokeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Invoke
 * @category generated
 */
type InvokeInstructionArgs = {
    params: InvokeParams;
};
/**
 * @category Instructions
 * @category Invoke
 * @category generated
 */
declare const invokeStruct: beet.FixableBeetArgsStruct<InvokeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _invoke_ instruction
 *
 * @property [_writable_, **signer**] signer
 * @property [_writable_] config
 * @property [_writable_] executeHash
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Invoke
 * @category generated
 */
type InvokeInstructionAccounts = {
    signer: web3.PublicKey;
    config: web3.PublicKey;
    executeHash: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const invokeInstructionDiscriminator: number[];
/**
 * Creates a _Invoke_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Invoke
 * @category generated
 */
declare function createInvokeInstruction(accounts: InvokeInstructionAccounts, args: InvokeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Invoke_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Invoke
 * @category generated
 */
declare function createInvokeInstructionAccounts(accounts: InvokeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzOption = {
    optionType: number;
    params: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzOptionBeet: beet.FixableBeetArgsStruct<LzOption>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteDvnParams = {
    msglib: web3.PublicKey;
    dstEid: number;
    sender: web3.PublicKey;
    packetHeader: Uint8Array;
    payloadHash: number[];
    confirmations: beet.bignum;
    options: LzOption[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteDvnParamsBeet: beet.FixableBeetArgsStruct<QuoteDvnParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category QuoteDvn
 * @category generated
 */
type QuoteDvnInstructionArgs = {
    params: QuoteDvnParams;
};
/**
 * @category Instructions
 * @category QuoteDvn
 * @category generated
 */
declare const quoteDvnStruct: beet.FixableBeetArgsStruct<QuoteDvnInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quoteDvn_ instruction
 *
 * @property [] dvnConfig
 * @property [] priceFeedProgram
 * @property [] priceFeedConfig
 * @category Instructions
 * @category QuoteDvn
 * @category generated
 */
type QuoteDvnInstructionAccounts = {
    dvnConfig: web3.PublicKey;
    priceFeedProgram: web3.PublicKey;
    priceFeedConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteDvnInstructionDiscriminator: number[];
/**
 * Creates a _QuoteDvn_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category QuoteDvn
 * @category generated
 */
declare function createQuoteDvnInstruction(accounts: QuoteDvnInstructionAccounts, args: QuoteDvnInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _QuoteDvn_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category QuoteDvn
 * @category generated
 */
declare function createQuoteDvnInstructionAccounts(accounts: QuoteDvnInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link AdminConfig} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link AdminConfig} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type AdminConfigRecord = {
    Admins: {
        fields: [web3.PublicKey[]];
    };
    DefaultMultiplierBps: {
        fields: [number];
    };
    DstConfigs: {
        fields: [DstConfig[]];
    };
    PriceFeed: {
        fields: [web3.PublicKey];
    };
};
/**
 * Union type respresenting the AdminConfig data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isAdminConfig*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type AdminConfig = beet.DataEnumKeyAsKind<AdminConfigRecord>;
declare const isAdminConfigAdmins: (x: AdminConfig) => x is {
    __kind: "Admins";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Admins';
};
declare const isAdminConfigDefaultMultiplierBps: (x: AdminConfig) => x is {
    __kind: "DefaultMultiplierBps";
} & Omit<{
    fields: [number];
}, "void"> & {
    __kind: 'DefaultMultiplierBps';
};
declare const isAdminConfigDstConfigs: (x: AdminConfig) => x is {
    __kind: "DstConfigs";
} & Omit<{
    fields: [DstConfig[]];
}, "void"> & {
    __kind: 'DstConfigs';
};
declare const isAdminConfigPriceFeed: (x: AdminConfig) => x is {
    __kind: "PriceFeed";
} & Omit<{
    fields: [web3.PublicKey];
}, "void"> & {
    __kind: 'PriceFeed';
};
/**
 * @category userTypes
 * @category generated
 */
declare const adminConfigBeet: beet.FixableBeet<AdminConfig, AdminConfig>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetConfigParams = {
    config: AdminConfig;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setConfigParamsBeet: beet.FixableBeetArgsStruct<SetConfigParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionArgs = {
    params: SetConfigParams;
};
/**
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare const setConfigStruct: beet.FixableBeetArgsStruct<SetConfigInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setConfig_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] config
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
type SetConfigInstructionAccounts = {
    admin: web3.PublicKey;
    config: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setConfigInstructionDiscriminator: number[];
/**
 * Creates a _SetConfig_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstruction(accounts: SetConfigInstructionAccounts, args: SetConfigInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetConfig_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetConfig
 * @category generated
 */
declare function createSetConfigInstructionAccounts(accounts: SetConfigInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type VerifiableParams = {
    packetHeader: number[];
    payloadHash: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const verifiableParamsBeet: beet.BeetArgsStruct<VerifiableParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Verifiable
 * @category generated
 */
type VerifiableInstructionArgs = {
    params: VerifiableParams;
};
/**
 * @category Instructions
 * @category Verifiable
 * @category generated
 */
declare const verifiableStruct: beet.BeetArgsStruct<VerifiableInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _verifiable_ instruction
 *
 * @property [] nonce
 * @property [] payloadHash
 * @property [] receiveConfig
 * @property [] defaultReceiveConfig
 * @category Instructions
 * @category Verifiable
 * @category generated
 */
type VerifiableInstructionAccounts = {
    nonce: web3.PublicKey;
    payloadHash: web3.PublicKey;
    receiveConfig: web3.PublicKey;
    defaultReceiveConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const verifiableInstructionDiscriminator: number[];
/**
 * Creates a _Verifiable_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Verifiable
 * @category generated
 */
declare function createVerifiableInstruction(accounts: VerifiableInstructionAccounts, args: VerifiableInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Verifiable_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Verifiable
 * @category generated
 */
declare function createVerifiableInstructionAccounts(accounts: VerifiableInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawFeeParams = {
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawFeeParamsBeet: beet.BeetArgsStruct<WithdrawFeeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawFee
 * @category generated
 */
type WithdrawFeeInstructionArgs = {
    params: WithdrawFeeParams;
};
/**
 * @category Instructions
 * @category WithdrawFee
 * @category generated
 */
declare const withdrawFeeStruct: beet.BeetArgsStruct<WithdrawFeeInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _withdrawFee_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] config
 * @property [_writable_] receiver
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category WithdrawFee
 * @category generated
 */
type WithdrawFeeInstructionAccounts = {
    admin: web3.PublicKey;
    config: web3.PublicKey;
    receiver: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const withdrawFeeInstructionDiscriminator: number[];
/**
 * Creates a _WithdrawFee_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawFee
 * @category generated
 */
declare function createWithdrawFeeInstruction(accounts: WithdrawFeeInstructionAccounts, args: WithdrawFeeInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _WithdrawFee_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category WithdrawFee
 * @category generated
 */
declare function createWithdrawFeeInstructionAccounts(accounts: WithdrawFeeInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

type index$5_CloseExecuteInstructionAccounts = CloseExecuteInstructionAccounts;
type index$5_CloseExecuteInstructionArgs = CloseExecuteInstructionArgs;
type index$5_InitDvnInstructionAccounts = InitDvnInstructionAccounts;
type index$5_InitDvnInstructionArgs = InitDvnInstructionArgs;
type index$5_InvokeInstructionAccounts = InvokeInstructionAccounts;
type index$5_InvokeInstructionArgs = InvokeInstructionArgs;
type index$5_QuoteDvnInstructionAccounts = QuoteDvnInstructionAccounts;
type index$5_QuoteDvnInstructionArgs = QuoteDvnInstructionArgs;
type index$5_SetConfigInstructionAccounts = SetConfigInstructionAccounts;
type index$5_SetConfigInstructionArgs = SetConfigInstructionArgs;
type index$5_VerifiableInstructionAccounts = VerifiableInstructionAccounts;
type index$5_VerifiableInstructionArgs = VerifiableInstructionArgs;
type index$5_WithdrawFeeInstructionAccounts = WithdrawFeeInstructionAccounts;
type index$5_WithdrawFeeInstructionArgs = WithdrawFeeInstructionArgs;
declare const index$5_closeExecuteInstructionDiscriminator: typeof closeExecuteInstructionDiscriminator;
declare const index$5_closeExecuteStruct: typeof closeExecuteStruct;
declare const index$5_createCloseExecuteInstruction: typeof createCloseExecuteInstruction;
declare const index$5_createCloseExecuteInstructionAccounts: typeof createCloseExecuteInstructionAccounts;
declare const index$5_createInitDvnInstruction: typeof createInitDvnInstruction;
declare const index$5_createInitDvnInstructionAccounts: typeof createInitDvnInstructionAccounts;
declare const index$5_createInvokeInstruction: typeof createInvokeInstruction;
declare const index$5_createInvokeInstructionAccounts: typeof createInvokeInstructionAccounts;
declare const index$5_createQuoteDvnInstruction: typeof createQuoteDvnInstruction;
declare const index$5_createQuoteDvnInstructionAccounts: typeof createQuoteDvnInstructionAccounts;
declare const index$5_createSetConfigInstruction: typeof createSetConfigInstruction;
declare const index$5_createSetConfigInstructionAccounts: typeof createSetConfigInstructionAccounts;
declare const index$5_createVerifiableInstruction: typeof createVerifiableInstruction;
declare const index$5_createVerifiableInstructionAccounts: typeof createVerifiableInstructionAccounts;
declare const index$5_createWithdrawFeeInstruction: typeof createWithdrawFeeInstruction;
declare const index$5_createWithdrawFeeInstructionAccounts: typeof createWithdrawFeeInstructionAccounts;
declare const index$5_initDvnInstructionDiscriminator: typeof initDvnInstructionDiscriminator;
declare const index$5_initDvnStruct: typeof initDvnStruct;
declare const index$5_invokeInstructionDiscriminator: typeof invokeInstructionDiscriminator;
declare const index$5_invokeStruct: typeof invokeStruct;
declare const index$5_quoteDvnInstructionDiscriminator: typeof quoteDvnInstructionDiscriminator;
declare const index$5_quoteDvnStruct: typeof quoteDvnStruct;
declare const index$5_setConfigInstructionDiscriminator: typeof setConfigInstructionDiscriminator;
declare const index$5_setConfigStruct: typeof setConfigStruct;
declare const index$5_verifiableInstructionDiscriminator: typeof verifiableInstructionDiscriminator;
declare const index$5_verifiableStruct: typeof verifiableStruct;
declare const index$5_withdrawFeeInstructionDiscriminator: typeof withdrawFeeInstructionDiscriminator;
declare const index$5_withdrawFeeStruct: typeof withdrawFeeStruct;
declare namespace index$5 {
  export { type index$5_CloseExecuteInstructionAccounts as CloseExecuteInstructionAccounts, type index$5_CloseExecuteInstructionArgs as CloseExecuteInstructionArgs, type index$5_InitDvnInstructionAccounts as InitDvnInstructionAccounts, type index$5_InitDvnInstructionArgs as InitDvnInstructionArgs, type index$5_InvokeInstructionAccounts as InvokeInstructionAccounts, type index$5_InvokeInstructionArgs as InvokeInstructionArgs, type index$5_QuoteDvnInstructionAccounts as QuoteDvnInstructionAccounts, type index$5_QuoteDvnInstructionArgs as QuoteDvnInstructionArgs, type index$5_SetConfigInstructionAccounts as SetConfigInstructionAccounts, type index$5_SetConfigInstructionArgs as SetConfigInstructionArgs, type index$5_VerifiableInstructionAccounts as VerifiableInstructionAccounts, type index$5_VerifiableInstructionArgs as VerifiableInstructionArgs, type index$5_WithdrawFeeInstructionAccounts as WithdrawFeeInstructionAccounts, type index$5_WithdrawFeeInstructionArgs as WithdrawFeeInstructionArgs, index$5_closeExecuteInstructionDiscriminator as closeExecuteInstructionDiscriminator, index$5_closeExecuteStruct as closeExecuteStruct, index$5_createCloseExecuteInstruction as createCloseExecuteInstruction, index$5_createCloseExecuteInstructionAccounts as createCloseExecuteInstructionAccounts, index$5_createInitDvnInstruction as createInitDvnInstruction, index$5_createInitDvnInstructionAccounts as createInitDvnInstructionAccounts, index$5_createInvokeInstruction as createInvokeInstruction, index$5_createInvokeInstructionAccounts as createInvokeInstructionAccounts, index$5_createQuoteDvnInstruction as createQuoteDvnInstruction, index$5_createQuoteDvnInstructionAccounts as createQuoteDvnInstructionAccounts, index$5_createSetConfigInstruction as createSetConfigInstruction, index$5_createSetConfigInstructionAccounts as createSetConfigInstructionAccounts, index$5_createVerifiableInstruction as createVerifiableInstruction, index$5_createVerifiableInstructionAccounts as createVerifiableInstructionAccounts, index$5_createWithdrawFeeInstruction as createWithdrawFeeInstruction, index$5_createWithdrawFeeInstructionAccounts as createWithdrawFeeInstructionAccounts, index$5_initDvnInstructionDiscriminator as initDvnInstructionDiscriminator, index$5_initDvnStruct as initDvnStruct, index$5_invokeInstructionDiscriminator as invokeInstructionDiscriminator, index$5_invokeStruct as invokeStruct, index$5_quoteDvnInstructionDiscriminator as quoteDvnInstructionDiscriminator, index$5_quoteDvnStruct as quoteDvnStruct, index$5_setConfigInstructionDiscriminator as setConfigInstructionDiscriminator, index$5_setConfigStruct as setConfigStruct, index$5_verifiableInstructionDiscriminator as verifiableInstructionDiscriminator, index$5_verifiableStruct as verifiableStruct, index$5_withdrawFeeInstructionDiscriminator as withdrawFeeInstructionDiscriminator, index$5_withdrawFeeStruct as withdrawFeeStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link MultisigConfig} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link MultisigConfig} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type MultisigConfigRecord = {
    Admins: {
        fields: [web3.PublicKey[]];
    };
    Allowlist: {
        fields: [web3.PublicKey[]];
    };
    Denylist: {
        fields: [web3.PublicKey[]];
    };
    Msglibs: {
        fields: [web3.PublicKey[]];
    };
    Paused: {
        fields: [boolean];
    };
    Quorum: {
        fields: [number];
    };
    Signers: {
        fields: [number[][]];
    };
};
/**
 * Union type respresenting the MultisigConfig data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isMultisigConfig*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type MultisigConfig = beet.DataEnumKeyAsKind<MultisigConfigRecord>;
declare const isMultisigConfigAdmins: (x: MultisigConfig) => x is {
    __kind: "Admins";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Admins';
};
declare const isMultisigConfigAllowlist: (x: MultisigConfig) => x is {
    __kind: "Allowlist";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Allowlist';
};
declare const isMultisigConfigDenylist: (x: MultisigConfig) => x is {
    __kind: "Denylist";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Denylist';
};
declare const isMultisigConfigMsglibs: (x: MultisigConfig) => x is {
    __kind: "Msglibs";
} & Omit<{
    fields: [web3.PublicKey[]];
}, "void"> & {
    __kind: 'Msglibs';
};
declare const isMultisigConfigPaused: (x: MultisigConfig) => x is {
    __kind: "Paused";
} & Omit<{
    fields: [boolean];
}, "void"> & {
    __kind: 'Paused';
};
declare const isMultisigConfigQuorum: (x: MultisigConfig) => x is {
    __kind: "Quorum";
} & Omit<{
    fields: [number];
}, "void"> & {
    __kind: 'Quorum';
};
declare const isMultisigConfigSigners: (x: MultisigConfig) => x is {
    __kind: "Signers";
} & Omit<{
    fields: [number[][]];
}, "void"> & {
    __kind: 'Signers';
};
/**
 * @category userTypes
 * @category generated
 */
declare const multisigConfigBeet: beet.FixableBeet<MultisigConfig, MultisigConfig>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum VerificationState {
    Verifying = 0,
    Verifiable = 1,
    Verified = 2,
    NotInitializable = 3,
    VerifiableButCapExceeded = 4
}
/**
 * @category userTypes
 * @category generated
 */
declare const verificationStateBeet: beet.FixedSizeBeet<VerificationState, VerificationState>;

type index$4_Acl = Acl;
type index$4_AdminConfig = AdminConfig;
type index$4_AdminConfigRecord = AdminConfigRecord;
type index$4_CloseExecuteParams = CloseExecuteParams;
type index$4_DstConfig = DstConfig;
type index$4_ExecuteTransactionDigest = ExecuteTransactionDigest;
type index$4_InitDvnParams = InitDvnParams;
type index$4_InvokeParams = InvokeParams;
type index$4_LzOption = LzOption;
type index$4_Multisig = Multisig;
type index$4_MultisigConfig = MultisigConfig;
type index$4_MultisigConfigRecord = MultisigConfigRecord;
type index$4_QuoteDvnParams = QuoteDvnParams;
type index$4_SetConfigParams = SetConfigParams;
type index$4_TransactionAccount = TransactionAccount;
type index$4_UlnConfig = UlnConfig;
type index$4_VerifiableParams = VerifiableParams;
type index$4_VerificationState = VerificationState;
declare const index$4_VerificationState: typeof VerificationState;
type index$4_WithdrawFeeParams = WithdrawFeeParams;
declare const index$4_aclBeet: typeof aclBeet;
declare const index$4_adminConfigBeet: typeof adminConfigBeet;
declare const index$4_closeExecuteParamsBeet: typeof closeExecuteParamsBeet;
declare const index$4_dstConfigBeet: typeof dstConfigBeet;
declare const index$4_executeTransactionDigestBeet: typeof executeTransactionDigestBeet;
declare const index$4_initDvnParamsBeet: typeof initDvnParamsBeet;
declare const index$4_invokeParamsBeet: typeof invokeParamsBeet;
declare const index$4_isAdminConfigAdmins: typeof isAdminConfigAdmins;
declare const index$4_isAdminConfigDefaultMultiplierBps: typeof isAdminConfigDefaultMultiplierBps;
declare const index$4_isAdminConfigDstConfigs: typeof isAdminConfigDstConfigs;
declare const index$4_isAdminConfigPriceFeed: typeof isAdminConfigPriceFeed;
declare const index$4_isMultisigConfigAdmins: typeof isMultisigConfigAdmins;
declare const index$4_isMultisigConfigAllowlist: typeof isMultisigConfigAllowlist;
declare const index$4_isMultisigConfigDenylist: typeof isMultisigConfigDenylist;
declare const index$4_isMultisigConfigMsglibs: typeof isMultisigConfigMsglibs;
declare const index$4_isMultisigConfigPaused: typeof isMultisigConfigPaused;
declare const index$4_isMultisigConfigQuorum: typeof isMultisigConfigQuorum;
declare const index$4_isMultisigConfigSigners: typeof isMultisigConfigSigners;
declare const index$4_lzOptionBeet: typeof lzOptionBeet;
declare const index$4_multisigBeet: typeof multisigBeet;
declare const index$4_multisigConfigBeet: typeof multisigConfigBeet;
declare const index$4_quoteDvnParamsBeet: typeof quoteDvnParamsBeet;
declare const index$4_setConfigParamsBeet: typeof setConfigParamsBeet;
declare const index$4_transactionAccountBeet: typeof transactionAccountBeet;
declare const index$4_ulnConfigBeet: typeof ulnConfigBeet;
declare const index$4_verifiableParamsBeet: typeof verifiableParamsBeet;
declare const index$4_verificationStateBeet: typeof verificationStateBeet;
declare const index$4_withdrawFeeParamsBeet: typeof withdrawFeeParamsBeet;
declare namespace index$4 {
  export { type index$4_Acl as Acl, type index$4_AdminConfig as AdminConfig, type index$4_AdminConfigRecord as AdminConfigRecord, type index$4_CloseExecuteParams as CloseExecuteParams, type index$4_DstConfig as DstConfig, type index$4_ExecuteTransactionDigest as ExecuteTransactionDigest, type index$4_InitDvnParams as InitDvnParams, type index$4_InvokeParams as InvokeParams, type index$4_LzOption as LzOption, type index$4_Multisig as Multisig, type index$4_MultisigConfig as MultisigConfig, type index$4_MultisigConfigRecord as MultisigConfigRecord, type index$4_QuoteDvnParams as QuoteDvnParams, type index$4_SetConfigParams as SetConfigParams, type index$4_TransactionAccount as TransactionAccount, type index$4_UlnConfig as UlnConfig, type index$4_VerifiableParams as VerifiableParams, index$4_VerificationState as VerificationState, type index$4_WithdrawFeeParams as WithdrawFeeParams, index$4_aclBeet as aclBeet, index$4_adminConfigBeet as adminConfigBeet, index$4_closeExecuteParamsBeet as closeExecuteParamsBeet, index$4_dstConfigBeet as dstConfigBeet, index$4_executeTransactionDigestBeet as executeTransactionDigestBeet, index$4_initDvnParamsBeet as initDvnParamsBeet, index$4_invokeParamsBeet as invokeParamsBeet, index$4_isAdminConfigAdmins as isAdminConfigAdmins, index$4_isAdminConfigDefaultMultiplierBps as isAdminConfigDefaultMultiplierBps, index$4_isAdminConfigDstConfigs as isAdminConfigDstConfigs, index$4_isAdminConfigPriceFeed as isAdminConfigPriceFeed, index$4_isMultisigConfigAdmins as isMultisigConfigAdmins, index$4_isMultisigConfigAllowlist as isMultisigConfigAllowlist, index$4_isMultisigConfigDenylist as isMultisigConfigDenylist, index$4_isMultisigConfigMsglibs as isMultisigConfigMsglibs, index$4_isMultisigConfigPaused as isMultisigConfigPaused, index$4_isMultisigConfigQuorum as isMultisigConfigQuorum, index$4_isMultisigConfigSigners as isMultisigConfigSigners, index$4_lzOptionBeet as lzOptionBeet, index$4_multisigBeet as multisigBeet, index$4_multisigConfigBeet as multisigConfigBeet, index$4_quoteDvnParamsBeet as quoteDvnParamsBeet, index$4_setConfigParamsBeet as setConfigParamsBeet, index$4_transactionAccountBeet as transactionAccountBeet, index$4_ulnConfigBeet as ulnConfigBeet, index$4_verifiableParamsBeet as verifiableParamsBeet, index$4_verificationStateBeet as verificationStateBeet, index$4_withdrawFeeParamsBeet as withdrawFeeParamsBeet };
}

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS$2 = "HtEYV4xB4wvsj5fgTkcfuChYpvGYzgzwvNhgDZQNh7wW";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$2: PublicKey;

type index$3_Acl = Acl;
type index$3_AdminConfig = AdminConfig;
type index$3_AdminConfigRecord = AdminConfigRecord;
type index$3_CloseExecuteInstructionAccounts = CloseExecuteInstructionAccounts;
type index$3_CloseExecuteInstructionArgs = CloseExecuteInstructionArgs;
type index$3_CloseExecuteParams = CloseExecuteParams;
type index$3_DstConfig = DstConfig;
type index$3_DuplicateSignatureError = DuplicateSignatureError;
declare const index$3_DuplicateSignatureError: typeof DuplicateSignatureError;
type index$3_DvnConfig = DvnConfig;
declare const index$3_DvnConfig: typeof DvnConfig;
type index$3_DvnConfigArgs = DvnConfigArgs;
type index$3_EidNotSupportedError = EidNotSupportedError;
declare const index$3_EidNotSupportedError: typeof EidNotSupportedError;
type index$3_ExecuteHash = ExecuteHash;
declare const index$3_ExecuteHash: typeof ExecuteHash;
type index$3_ExecuteHashArgs = ExecuteHashArgs;
type index$3_ExecuteTransactionDigest = ExecuteTransactionDigest;
type index$3_ExpiredError = ExpiredError;
declare const index$3_ExpiredError: typeof ExpiredError;
type index$3_InitDvnInstructionAccounts = InitDvnInstructionAccounts;
type index$3_InitDvnInstructionArgs = InitDvnInstructionArgs;
type index$3_InitDvnParams = InitDvnParams;
type index$3_InvalidAmountError = InvalidAmountError;
declare const index$3_InvalidAmountError: typeof InvalidAmountError;
type index$3_InvalidQuorumError = InvalidQuorumError;
declare const index$3_InvalidQuorumError: typeof InvalidQuorumError;
type index$3_InvalidSignatureLenError = InvalidSignatureLenError;
declare const index$3_InvalidSignatureLenError: typeof InvalidSignatureLenError;
type index$3_InvalidSignersLenError = InvalidSignersLenError;
declare const index$3_InvalidSignersLenError: typeof InvalidSignersLenError;
type index$3_InvalidVidError = InvalidVidError;
declare const index$3_InvalidVidError: typeof InvalidVidError;
type index$3_InvokeInstructionAccounts = InvokeInstructionAccounts;
type index$3_InvokeInstructionArgs = InvokeInstructionArgs;
type index$3_InvokeParams = InvokeParams;
type index$3_LzOption = LzOption;
type index$3_MsgLibNotAllowedError = MsgLibNotAllowedError;
declare const index$3_MsgLibNotAllowedError: typeof MsgLibNotAllowedError;
type index$3_Multisig = Multisig;
type index$3_MultisigConfig = MultisigConfig;
type index$3_MultisigConfigRecord = MultisigConfigRecord;
type index$3_NotAdminError = NotAdminError;
declare const index$3_NotAdminError: typeof NotAdminError;
type index$3_PausedError = PausedError;
declare const index$3_PausedError: typeof PausedError;
type index$3_QuoteDvnInstructionAccounts = QuoteDvnInstructionAccounts;
type index$3_QuoteDvnInstructionArgs = QuoteDvnInstructionArgs;
type index$3_QuoteDvnParams = QuoteDvnParams;
type index$3_ReceiveConfig = ReceiveConfig;
declare const index$3_ReceiveConfig: typeof ReceiveConfig;
type index$3_ReceiveConfigArgs = ReceiveConfigArgs;
type index$3_SetConfigInstructionAccounts = SetConfigInstructionAccounts;
type index$3_SetConfigInstructionArgs = SetConfigInstructionArgs;
type index$3_SetConfigParams = SetConfigParams;
type index$3_SignatureErrorError = SignatureErrorError;
declare const index$3_SignatureErrorError: typeof SignatureErrorError;
type index$3_SignerNotInCommitteeError = SignerNotInCommitteeError;
declare const index$3_SignerNotInCommitteeError: typeof SignerNotInCommitteeError;
type index$3_TooManyAdminsError = TooManyAdminsError;
declare const index$3_TooManyAdminsError: typeof TooManyAdminsError;
type index$3_TooManyOptionTypesError = TooManyOptionTypesError;
declare const index$3_TooManyOptionTypesError: typeof TooManyOptionTypesError;
type index$3_TransactionAccount = TransactionAccount;
type index$3_UlnConfig = UlnConfig;
type index$3_UnexpiredExecuteHashError = UnexpiredExecuteHashError;
declare const index$3_UnexpiredExecuteHashError: typeof UnexpiredExecuteHashError;
type index$3_UniqueOwnersError = UniqueOwnersError;
declare const index$3_UniqueOwnersError: typeof UniqueOwnersError;
type index$3_VerifiableInstructionAccounts = VerifiableInstructionAccounts;
type index$3_VerifiableInstructionArgs = VerifiableInstructionArgs;
type index$3_VerifiableParams = VerifiableParams;
type index$3_VerificationState = VerificationState;
declare const index$3_VerificationState: typeof VerificationState;
type index$3_WithdrawFeeInstructionAccounts = WithdrawFeeInstructionAccounts;
type index$3_WithdrawFeeInstructionArgs = WithdrawFeeInstructionArgs;
type index$3_WithdrawFeeParams = WithdrawFeeParams;
declare const index$3_aclBeet: typeof aclBeet;
declare const index$3_adminConfigBeet: typeof adminConfigBeet;
declare const index$3_closeExecuteInstructionDiscriminator: typeof closeExecuteInstructionDiscriminator;
declare const index$3_closeExecuteParamsBeet: typeof closeExecuteParamsBeet;
declare const index$3_closeExecuteStruct: typeof closeExecuteStruct;
declare const index$3_createCloseExecuteInstruction: typeof createCloseExecuteInstruction;
declare const index$3_createCloseExecuteInstructionAccounts: typeof createCloseExecuteInstructionAccounts;
declare const index$3_createInitDvnInstruction: typeof createInitDvnInstruction;
declare const index$3_createInitDvnInstructionAccounts: typeof createInitDvnInstructionAccounts;
declare const index$3_createInvokeInstruction: typeof createInvokeInstruction;
declare const index$3_createInvokeInstructionAccounts: typeof createInvokeInstructionAccounts;
declare const index$3_createQuoteDvnInstruction: typeof createQuoteDvnInstruction;
declare const index$3_createQuoteDvnInstructionAccounts: typeof createQuoteDvnInstructionAccounts;
declare const index$3_createSetConfigInstruction: typeof createSetConfigInstruction;
declare const index$3_createSetConfigInstructionAccounts: typeof createSetConfigInstructionAccounts;
declare const index$3_createVerifiableInstruction: typeof createVerifiableInstruction;
declare const index$3_createVerifiableInstructionAccounts: typeof createVerifiableInstructionAccounts;
declare const index$3_createWithdrawFeeInstruction: typeof createWithdrawFeeInstruction;
declare const index$3_createWithdrawFeeInstructionAccounts: typeof createWithdrawFeeInstructionAccounts;
declare const index$3_dstConfigBeet: typeof dstConfigBeet;
declare const index$3_dvnConfigBeet: typeof dvnConfigBeet;
declare const index$3_dvnConfigDiscriminator: typeof dvnConfigDiscriminator;
declare const index$3_executeHashBeet: typeof executeHashBeet;
declare const index$3_executeHashDiscriminator: typeof executeHashDiscriminator;
declare const index$3_executeTransactionDigestBeet: typeof executeTransactionDigestBeet;
declare const index$3_initDvnInstructionDiscriminator: typeof initDvnInstructionDiscriminator;
declare const index$3_initDvnParamsBeet: typeof initDvnParamsBeet;
declare const index$3_initDvnStruct: typeof initDvnStruct;
declare const index$3_invokeInstructionDiscriminator: typeof invokeInstructionDiscriminator;
declare const index$3_invokeParamsBeet: typeof invokeParamsBeet;
declare const index$3_invokeStruct: typeof invokeStruct;
declare const index$3_isAdminConfigAdmins: typeof isAdminConfigAdmins;
declare const index$3_isAdminConfigDefaultMultiplierBps: typeof isAdminConfigDefaultMultiplierBps;
declare const index$3_isAdminConfigDstConfigs: typeof isAdminConfigDstConfigs;
declare const index$3_isAdminConfigPriceFeed: typeof isAdminConfigPriceFeed;
declare const index$3_isMultisigConfigAdmins: typeof isMultisigConfigAdmins;
declare const index$3_isMultisigConfigAllowlist: typeof isMultisigConfigAllowlist;
declare const index$3_isMultisigConfigDenylist: typeof isMultisigConfigDenylist;
declare const index$3_isMultisigConfigMsglibs: typeof isMultisigConfigMsglibs;
declare const index$3_isMultisigConfigPaused: typeof isMultisigConfigPaused;
declare const index$3_isMultisigConfigQuorum: typeof isMultisigConfigQuorum;
declare const index$3_isMultisigConfigSigners: typeof isMultisigConfigSigners;
declare const index$3_lzOptionBeet: typeof lzOptionBeet;
declare const index$3_multisigBeet: typeof multisigBeet;
declare const index$3_multisigConfigBeet: typeof multisigConfigBeet;
declare const index$3_quoteDvnInstructionDiscriminator: typeof quoteDvnInstructionDiscriminator;
declare const index$3_quoteDvnParamsBeet: typeof quoteDvnParamsBeet;
declare const index$3_quoteDvnStruct: typeof quoteDvnStruct;
declare const index$3_receiveConfigBeet: typeof receiveConfigBeet;
declare const index$3_receiveConfigDiscriminator: typeof receiveConfigDiscriminator;
declare const index$3_setConfigInstructionDiscriminator: typeof setConfigInstructionDiscriminator;
declare const index$3_setConfigParamsBeet: typeof setConfigParamsBeet;
declare const index$3_setConfigStruct: typeof setConfigStruct;
declare const index$3_transactionAccountBeet: typeof transactionAccountBeet;
declare const index$3_ulnConfigBeet: typeof ulnConfigBeet;
declare const index$3_verifiableInstructionDiscriminator: typeof verifiableInstructionDiscriminator;
declare const index$3_verifiableParamsBeet: typeof verifiableParamsBeet;
declare const index$3_verifiableStruct: typeof verifiableStruct;
declare const index$3_verificationStateBeet: typeof verificationStateBeet;
declare const index$3_withdrawFeeInstructionDiscriminator: typeof withdrawFeeInstructionDiscriminator;
declare const index$3_withdrawFeeParamsBeet: typeof withdrawFeeParamsBeet;
declare const index$3_withdrawFeeStruct: typeof withdrawFeeStruct;
declare namespace index$3 {
  export { type index$3_Acl as Acl, type index$3_AdminConfig as AdminConfig, type index$3_AdminConfigRecord as AdminConfigRecord, type index$3_CloseExecuteInstructionAccounts as CloseExecuteInstructionAccounts, type index$3_CloseExecuteInstructionArgs as CloseExecuteInstructionArgs, type index$3_CloseExecuteParams as CloseExecuteParams, type index$3_DstConfig as DstConfig, index$3_DuplicateSignatureError as DuplicateSignatureError, index$3_DvnConfig as DvnConfig, type index$3_DvnConfigArgs as DvnConfigArgs, index$3_EidNotSupportedError as EidNotSupportedError, index$3_ExecuteHash as ExecuteHash, type index$3_ExecuteHashArgs as ExecuteHashArgs, type index$3_ExecuteTransactionDigest as ExecuteTransactionDigest, index$3_ExpiredError as ExpiredError, type index$3_InitDvnInstructionAccounts as InitDvnInstructionAccounts, type index$3_InitDvnInstructionArgs as InitDvnInstructionArgs, type index$3_InitDvnParams as InitDvnParams, index$3_InvalidAmountError as InvalidAmountError, index$3_InvalidQuorumError as InvalidQuorumError, index$3_InvalidSignatureLenError as InvalidSignatureLenError, index$3_InvalidSignersLenError as InvalidSignersLenError, index$3_InvalidVidError as InvalidVidError, type index$3_InvokeInstructionAccounts as InvokeInstructionAccounts, type index$3_InvokeInstructionArgs as InvokeInstructionArgs, type index$3_InvokeParams as InvokeParams, type index$3_LzOption as LzOption, index$3_MsgLibNotAllowedError as MsgLibNotAllowedError, type index$3_Multisig as Multisig, type index$3_MultisigConfig as MultisigConfig, type index$3_MultisigConfigRecord as MultisigConfigRecord, index$3_NotAdminError as NotAdminError, PROGRAM_ADDRESS$2 as PROGRAM_ADDRESS, PROGRAM_ID$2 as PROGRAM_ID, index$3_PausedError as PausedError, type index$3_QuoteDvnInstructionAccounts as QuoteDvnInstructionAccounts, type index$3_QuoteDvnInstructionArgs as QuoteDvnInstructionArgs, type index$3_QuoteDvnParams as QuoteDvnParams, index$3_ReceiveConfig as ReceiveConfig, type index$3_ReceiveConfigArgs as ReceiveConfigArgs, type index$3_SetConfigInstructionAccounts as SetConfigInstructionAccounts, type index$3_SetConfigInstructionArgs as SetConfigInstructionArgs, type index$3_SetConfigParams as SetConfigParams, index$3_SignatureErrorError as SignatureErrorError, index$3_SignerNotInCommitteeError as SignerNotInCommitteeError, index$3_TooManyAdminsError as TooManyAdminsError, index$3_TooManyOptionTypesError as TooManyOptionTypesError, type index$3_TransactionAccount as TransactionAccount, type index$3_UlnConfig as UlnConfig, index$3_UnexpiredExecuteHashError as UnexpiredExecuteHashError, index$3_UniqueOwnersError as UniqueOwnersError, type index$3_VerifiableInstructionAccounts as VerifiableInstructionAccounts, type index$3_VerifiableInstructionArgs as VerifiableInstructionArgs, type index$3_VerifiableParams as VerifiableParams, index$3_VerificationState as VerificationState, type index$3_WithdrawFeeInstructionAccounts as WithdrawFeeInstructionAccounts, type index$3_WithdrawFeeInstructionArgs as WithdrawFeeInstructionArgs, type index$3_WithdrawFeeParams as WithdrawFeeParams, accountProviders$1 as accountProviders, index$3_aclBeet as aclBeet, index$3_adminConfigBeet as adminConfigBeet, index$3_closeExecuteInstructionDiscriminator as closeExecuteInstructionDiscriminator, index$3_closeExecuteParamsBeet as closeExecuteParamsBeet, index$3_closeExecuteStruct as closeExecuteStruct, index$3_createCloseExecuteInstruction as createCloseExecuteInstruction, index$3_createCloseExecuteInstructionAccounts as createCloseExecuteInstructionAccounts, index$3_createInitDvnInstruction as createInitDvnInstruction, index$3_createInitDvnInstructionAccounts as createInitDvnInstructionAccounts, index$3_createInvokeInstruction as createInvokeInstruction, index$3_createInvokeInstructionAccounts as createInvokeInstructionAccounts, index$3_createQuoteDvnInstruction as createQuoteDvnInstruction, index$3_createQuoteDvnInstructionAccounts as createQuoteDvnInstructionAccounts, index$3_createSetConfigInstruction as createSetConfigInstruction, index$3_createSetConfigInstructionAccounts as createSetConfigInstructionAccounts, index$3_createVerifiableInstruction as createVerifiableInstruction, index$3_createVerifiableInstructionAccounts as createVerifiableInstructionAccounts, index$3_createWithdrawFeeInstruction as createWithdrawFeeInstruction, index$3_createWithdrawFeeInstructionAccounts as createWithdrawFeeInstructionAccounts, index$3_dstConfigBeet as dstConfigBeet, index$3_dvnConfigBeet as dvnConfigBeet, index$3_dvnConfigDiscriminator as dvnConfigDiscriminator, errorFromCode$1 as errorFromCode, errorFromName$1 as errorFromName, index$3_executeHashBeet as executeHashBeet, index$3_executeHashDiscriminator as executeHashDiscriminator, index$3_executeTransactionDigestBeet as executeTransactionDigestBeet, index$3_initDvnInstructionDiscriminator as initDvnInstructionDiscriminator, index$3_initDvnParamsBeet as initDvnParamsBeet, index$3_initDvnStruct as initDvnStruct, index$3_invokeInstructionDiscriminator as invokeInstructionDiscriminator, index$3_invokeParamsBeet as invokeParamsBeet, index$3_invokeStruct as invokeStruct, index$3_isAdminConfigAdmins as isAdminConfigAdmins, index$3_isAdminConfigDefaultMultiplierBps as isAdminConfigDefaultMultiplierBps, index$3_isAdminConfigDstConfigs as isAdminConfigDstConfigs, index$3_isAdminConfigPriceFeed as isAdminConfigPriceFeed, index$3_isMultisigConfigAdmins as isMultisigConfigAdmins, index$3_isMultisigConfigAllowlist as isMultisigConfigAllowlist, index$3_isMultisigConfigDenylist as isMultisigConfigDenylist, index$3_isMultisigConfigMsglibs as isMultisigConfigMsglibs, index$3_isMultisigConfigPaused as isMultisigConfigPaused, index$3_isMultisigConfigQuorum as isMultisigConfigQuorum, index$3_isMultisigConfigSigners as isMultisigConfigSigners, index$3_lzOptionBeet as lzOptionBeet, index$3_multisigBeet as multisigBeet, index$3_multisigConfigBeet as multisigConfigBeet, index$3_quoteDvnInstructionDiscriminator as quoteDvnInstructionDiscriminator, index$3_quoteDvnParamsBeet as quoteDvnParamsBeet, index$3_quoteDvnStruct as quoteDvnStruct, index$3_receiveConfigBeet as receiveConfigBeet, index$3_receiveConfigDiscriminator as receiveConfigDiscriminator, index$3_setConfigInstructionDiscriminator as setConfigInstructionDiscriminator, index$3_setConfigParamsBeet as setConfigParamsBeet, index$3_setConfigStruct as setConfigStruct, index$3_transactionAccountBeet as transactionAccountBeet, index$3_ulnConfigBeet as ulnConfigBeet, index$3_verifiableInstructionDiscriminator as verifiableInstructionDiscriminator, index$3_verifiableParamsBeet as verifiableParamsBeet, index$3_verifiableStruct as verifiableStruct, index$3_verificationStateBeet as verificationStateBeet, index$3_withdrawFeeInstructionDiscriminator as withdrawFeeInstructionDiscriminator, index$3_withdrawFeeParamsBeet as withdrawFeeParamsBeet, index$3_withdrawFeeStruct as withdrawFeeStruct };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type AdminConfigSetEvent = {
    config: AdminConfig;
};
/**
 * @category userTypes
 * @category generated
 */
declare const adminConfigSetEventBeet: beet.FixableBeetArgsStruct<AdminConfigSetEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FeeWithdrawnEvent = {
    receiver: web3.PublicKey;
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const feeWithdrawnEventBeet: beet.BeetArgsStruct<FeeWithdrawnEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MultisigConfigSetEvent = {
    config: MultisigConfig;
};
/**
 * @category userTypes
 * @category generated
 */
declare const multisigConfigSetEventBeet: beet.FixableBeetArgsStruct<MultisigConfigSetEvent>;

type index$2_AdminConfigSetEvent = AdminConfigSetEvent;
type index$2_FeeWithdrawnEvent = FeeWithdrawnEvent;
type index$2_MultisigConfigSetEvent = MultisigConfigSetEvent;
declare const index$2_adminConfigSetEventBeet: typeof adminConfigSetEventBeet;
declare const index$2_feeWithdrawnEventBeet: typeof feeWithdrawnEventBeet;
declare const index$2_multisigConfigSetEventBeet: typeof multisigConfigSetEventBeet;
declare namespace index$2 {
  export { type index$2_AdminConfigSetEvent as AdminConfigSetEvent, type index$2_FeeWithdrawnEvent as FeeWithdrawnEvent, type index$2_MultisigConfigSetEvent as MultisigConfigSetEvent, index$2_adminConfigSetEventBeet as adminConfigSetEventBeet, index$2_feeWithdrawnEventBeet as feeWithdrawnEventBeet, index$2_multisigConfigSetEventBeet as multisigConfigSetEventBeet };
}

interface SignFunc {
    sign(message: Buffer): Promise<{
        signature: Uint8Array;
        recoveryId: number;
    }[]>;
}
declare class SolanaSignerExt implements SignFunc {
    private readonly signers;
    private constructor();
    static from(signers: SolanaSigner[]): SolanaSignerExt;
    sign(message: Buffer): Promise<{
        signature: Uint8Array;
        recoveryId: number;
    }[]>;
}
declare class DVN {
    readonly programId: PublicKey;
    dvnDeriver: DVNDeriver;
    vid: number;
    eventAuthority: PublicKey;
    constructor(programId: PublicKey, endpointId?: EndpointId);
    initDVN(connection: Connection, payer: PublicKey, params: InitDvnParams): Promise<TransactionInstruction>;
    getDigest(vid: number, instruction: TransactionInstruction, expiration: number): ExecuteTransactionDigest;
    getExecuteHash(hashBytes: Buffer): PublicKey;
    getHashBytes(digest: ExecuteTransactionDigest): Buffer;
    invoke(connection: Connection, vid: number, payer: PublicKey, instruction: TransactionInstruction, expiration: number, sign: SignFunc): Promise<TransactionInstruction>;
    createSetQuorumInstruction(quorum: number): TransactionInstruction;
    createSetAdminsInstruction(admins: PublicKey[]): TransactionInstruction;
    createSetSignersInstruction(signers: Uint8Array[]): TransactionInstruction;
    createSetAllowlistInstruction(allowlist: PublicKey[]): TransactionInstruction;
    createSetDenylistInstruction(denylist: PublicKey[]): TransactionInstruction;
    createSetPauseInstruction(pause: boolean): TransactionInstruction;
    createSetDefaultMultiplierBpsInstruction(admin: PublicKey, defaultMultiplierBps: number): TransactionInstruction;
    createChangeAdminsInstruction(admin: PublicKey, admins: PublicKey[]): TransactionInstruction;
    createSetDstConfigInstruction(admin: PublicKey, dstConfigs: DstConfig[]): TransactionInstruction;
    createSetMsgLibsInstruction(msglibPrograms: PublicKey[]): TransactionInstruction;
    _getExpiration(): number;
    setMsgLibs(connection: Connection, payer: PublicKey, msgLibs: PublicKey[], sign: SignFunc): Promise<TransactionInstruction>;
    createSetPriceFeedInstruction(admin: PublicKey, priceFeedProgram: PublicKey): TransactionInstruction;
    getQuoteIXAccountMetaForCPI(connection: Connection, payment: boolean, commitment?: Commitment): Promise<AccountMeta[]>;
    getConfigState(connection: Connection, commitment?: Commitment | GetAccountInfoConfig): Promise<DvnConfig | null>;
}

type dvn_DVN = DVN;
declare const dvn_DVN: typeof DVN;
type dvn_SignFunc = SignFunc;
type dvn_SolanaSignerExt = SolanaSignerExt;
declare const dvn_SolanaSignerExt: typeof SolanaSignerExt;
declare namespace dvn {
  export { dvn_DVN as DVN, PROGRAM_ID$2 as PROGRAM_ID, type dvn_SignFunc as SignFunc, dvn_SolanaSignerExt as SolanaSignerExt, index$7 as accounts, index$6 as errors, index$2 as events, index$5 as instructions, index$4 as types };
}

declare const SOLANA_EID = 1;
declare const OFT_SEED = "Oft";
declare enum ConfigType {
    Executor = 1,
    SendUln = 2,
    ReceiveUln = 3
}
declare function isAccountInitialized$1(connection: Connection, account: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
declare function createNonceTx(connection: Connection, nonceAccount: PublicKey, nonceAuthority: PublicKey, instructions: TransactionInstruction[], commitmentOrConfig?: Commitment | GetNonceConfig): Promise<Transaction>;
declare function createInitAdapterOftIx(payer: PublicKey, admin: PublicKey, mint: PublicKey, lzDelegate: PublicKey, escrow: PublicKey, sharedDecimals?: number, tokenProgram?: PublicKey): Promise<TransactionInstruction>;
declare function createInitNativeOftIx(payer: PublicKey, admin: PublicKey, mint: PublicKey, oftMintAuthority: PublicKey, lzDelegate: PublicKey, sharedDecimals?: number, tokenProgram?: PublicKey): Promise<TransactionInstruction>;
declare function createSetPeerIx(admin: PublicKey, oftConfig: PublicKey, dstEid: number, peer: number[]): Promise<TransactionInstruction>;
declare function createSetDelegateIx(admin: PublicKey, oftConfig: PublicKey, delegate: PublicKey): Promise<TransactionInstruction>;
declare function createInitSendLibraryIx(signer: PublicKey, oftConfig: PublicKey, dstEid: number): Promise<TransactionInstruction>;
declare function createInitReceiveLibraryIx(signer: PublicKey, oftConfig: PublicKey, remoteEid: number): Promise<TransactionInstruction>;
declare function createSetSendLibraryIx(signer: PublicKey, oftConfig: PublicKey, sendLibraryProgram: PublicKey, dstEid: number): Promise<TransactionInstruction>;
declare function createSetReceiveLibraryIx(signer: PublicKey, oftConfig: PublicKey, receiveLibraryProgram: PublicKey, dstEid: number, gracePeriod: bigint): Promise<TransactionInstruction>;
declare function createMintToIx(signer: PublicKey, tokenMint: PublicKey, tokenDest: PublicKey, amount: bigint, tokenProgram?: PublicKey): Promise<TransactionInstruction>;
declare function createSetRateLimitIx(signer: PublicKey, oftConfig: PublicKey, dstEid: number, capacity: bigint, refillPerSecond: bigint, enabled: boolean): Promise<TransactionInstruction>;
declare function createInitConfigIx(signer: PublicKey, oftConfig: PublicKey, messageLibProgram: PublicKey, dstEid: number): Promise<TransactionInstruction>;
declare function createSetConfigIx(signer: PublicKey, oftConfig: PublicKey, dstEid: number, configType: ConfigType, config: Uint8Array, messageLibProgram?: PublicKey): Promise<TransactionInstruction>;
declare function createSetEnforcedOptionsIx(admin: PublicKey, oftConfig: PublicKey, dstEid: number, sendOptions: Uint8Array, sendAndCallOptions: Uint8Array): Promise<TransactionInstruction>;
declare function createTransferAdminIx(signer: PublicKey, oftConfig: PublicKey, newAdmin: PublicKey): Promise<TransactionInstruction>;
declare function sendWithUln(connection: Connection, payer: PublicKey, tokenMint: PublicKey, tokenSource: PublicKey, dstEid: number, amountLd: bigint, minAmountLd: bigint, options: Uint8Array, to: number[], nativeFee: bigint, tokenEscrow?: PublicKey | undefined, lzTokenFee?: bigint, tokenProgram?: PublicKey, composeMsg?: Uint8Array | null): Promise<TransactionInstruction>;
declare function createInitNonceIx(delegate: PublicKey, // payer
dstEid: number, oftInstance: PublicKey, remoteOappAddr: Uint8Array): Promise<TransactionInstruction>;
declare function quoteOft(connection: Connection, payer: PublicKey, tokenMint: PublicKey, dstEid: number, amountLd: bigint, minAmountLd: bigint, options: Uint8Array, to: number[], tokenEscrow?: PublicKey | undefined, payInLzToken?: boolean, composeMsg?: Uint8Array | null): Promise<{
    oftLimits: {
        minAmountLd: string;
        maxAmountLd: string;
    };
    oftFeeDetail: {
        feeAmountLd: string;
        description: string;
    };
    oftReceipt: {
        amountSentLd: string;
        amountReceivedLd: string;
    };
}>;
declare function quoteWithUln(connection: Connection, payer: PublicKey, tokenMint: PublicKey, dstEid: number, amountLd: bigint, minAmountLd: bigint, options: Uint8Array, to: number[], tokenEscrow?: PublicKey | undefined, payInLzToken?: boolean, composeMsg?: Uint8Array | null): Promise<{
    nativeFee: bigint;
    lzTokenFee: bigint;
}>;
declare function createSetMintAuthorityIx(signer: PublicKey, oftInstance: PublicKey, newAuthority: PublicKey | null): Promise<TransactionInstruction>;
declare function getEndpointConfig(connection: Connection, oftInstance: PublicKey, dstEid: number): Promise<{
    sendLibraryConfig: SendLibraryConfig & {
        ulnSendConfig?: SendConfig;
    };
    receiveLibraryConfig: ReceiveLibraryConfig & {
        ulnReceiveConfig?: ReceiveConfig$1;
    };
}>;
declare function getPeerAddress(connection: Connection, oftInstance: PublicKey, dstEid: number): Promise<string>;
declare function getDelegate(connection: Connection, oftInstance: PublicKey): Promise<PublicKey>;
declare function getEnforcedOptions(connection: Connection, oftInstance: PublicKey, dstEid: number): Promise<any>;

type OftTools_ConfigType = ConfigType;
declare const OftTools_ConfigType: typeof ConfigType;
declare const OftTools_OFT_SEED: typeof OFT_SEED;
declare const OftTools_SOLANA_EID: typeof SOLANA_EID;
declare const OftTools_createInitAdapterOftIx: typeof createInitAdapterOftIx;
declare const OftTools_createInitConfigIx: typeof createInitConfigIx;
declare const OftTools_createInitNativeOftIx: typeof createInitNativeOftIx;
declare const OftTools_createInitNonceIx: typeof createInitNonceIx;
declare const OftTools_createInitReceiveLibraryIx: typeof createInitReceiveLibraryIx;
declare const OftTools_createInitSendLibraryIx: typeof createInitSendLibraryIx;
declare const OftTools_createMintToIx: typeof createMintToIx;
declare const OftTools_createNonceTx: typeof createNonceTx;
declare const OftTools_createSetConfigIx: typeof createSetConfigIx;
declare const OftTools_createSetDelegateIx: typeof createSetDelegateIx;
declare const OftTools_createSetEnforcedOptionsIx: typeof createSetEnforcedOptionsIx;
declare const OftTools_createSetMintAuthorityIx: typeof createSetMintAuthorityIx;
declare const OftTools_createSetPeerIx: typeof createSetPeerIx;
declare const OftTools_createSetRateLimitIx: typeof createSetRateLimitIx;
declare const OftTools_createSetReceiveLibraryIx: typeof createSetReceiveLibraryIx;
declare const OftTools_createSetSendLibraryIx: typeof createSetSendLibraryIx;
declare const OftTools_createTransferAdminIx: typeof createTransferAdminIx;
declare const OftTools_getDelegate: typeof getDelegate;
declare const OftTools_getEndpointConfig: typeof getEndpointConfig;
declare const OftTools_getEnforcedOptions: typeof getEnforcedOptions;
declare const OftTools_getPeerAddress: typeof getPeerAddress;
declare const OftTools_quoteOft: typeof quoteOft;
declare const OftTools_quoteWithUln: typeof quoteWithUln;
declare const OftTools_sendWithUln: typeof sendWithUln;
declare namespace OftTools {
  export { OftTools_ConfigType as ConfigType, OftTools_OFT_SEED as OFT_SEED, OftTools_SOLANA_EID as SOLANA_EID, OftTools_createInitAdapterOftIx as createInitAdapterOftIx, OftTools_createInitConfigIx as createInitConfigIx, OftTools_createInitNativeOftIx as createInitNativeOftIx, OftTools_createInitNonceIx as createInitNonceIx, OftTools_createInitReceiveLibraryIx as createInitReceiveLibraryIx, OftTools_createInitSendLibraryIx as createInitSendLibraryIx, OftTools_createMintToIx as createMintToIx, OftTools_createNonceTx as createNonceTx, OftTools_createSetConfigIx as createSetConfigIx, OftTools_createSetDelegateIx as createSetDelegateIx, OftTools_createSetEnforcedOptionsIx as createSetEnforcedOptionsIx, OftTools_createSetMintAuthorityIx as createSetMintAuthorityIx, OftTools_createSetPeerIx as createSetPeerIx, OftTools_createSetRateLimitIx as createSetRateLimitIx, OftTools_createSetReceiveLibraryIx as createSetReceiveLibraryIx, OftTools_createSetSendLibraryIx as createSetSendLibraryIx, OftTools_createTransferAdminIx as createTransferAdminIx, OftTools_getDelegate as getDelegate, OftTools_getEndpointConfig as getEndpointConfig, OftTools_getEnforcedOptions as getEnforcedOptions, OftTools_getPeerAddress as getPeerAddress, isAccountInitialized$1 as isAccountInitialized, OftTools_quoteOft as quoteOft, OftTools_quoteWithUln as quoteWithUln, OftTools_sendWithUln as sendWithUln };
}

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link EnforcedOptions}
 * @category Accounts
 * @category generated
 */
type EnforcedOptionsArgs = {
    send: Uint8Array;
    sendAndCall: Uint8Array;
    bump: number;
};
declare const enforcedOptionsDiscriminator: number[];
/**
 * Holds the data for the {@link EnforcedOptions} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class EnforcedOptions implements EnforcedOptionsArgs {
    readonly send: Uint8Array;
    readonly sendAndCall: Uint8Array;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link EnforcedOptions} instance from the provided args.
     */
    static fromArgs(args: EnforcedOptionsArgs): EnforcedOptions;
    /**
     * Deserializes the {@link EnforcedOptions} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [EnforcedOptions, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link EnforcedOptions} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<EnforcedOptions>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<EnforcedOptionsArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link EnforcedOptions} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [EnforcedOptions, number];
    /**
     * Serializes the {@link EnforcedOptions} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link EnforcedOptions} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: EnforcedOptionsArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link EnforcedOptions} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: EnforcedOptionsArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link EnforcedOptions} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        send: Uint8Array;
        sendAndCall: Uint8Array;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const enforcedOptionsBeet: beet.FixableBeetStruct<EnforcedOptions, EnforcedOptionsArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link LzReceiveTypesAccounts}
 * @category Accounts
 * @category generated
 */
type LzReceiveTypesAccountsArgs = {
    oftConfig: web3.PublicKey;
    tokenMint: web3.PublicKey;
};
declare const lzReceiveTypesAccountsDiscriminator: number[];
/**
 * Holds the data for the {@link LzReceiveTypesAccounts} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class LzReceiveTypesAccounts implements LzReceiveTypesAccountsArgs {
    readonly oftConfig: web3.PublicKey;
    readonly tokenMint: web3.PublicKey;
    private constructor();
    /**
     * Creates a {@link LzReceiveTypesAccounts} instance from the provided args.
     */
    static fromArgs(args: LzReceiveTypesAccountsArgs): LzReceiveTypesAccounts;
    /**
     * Deserializes the {@link LzReceiveTypesAccounts} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [LzReceiveTypesAccounts, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link LzReceiveTypesAccounts} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<LzReceiveTypesAccounts>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<{
        accountDiscriminator: any;
        oftConfig: any;
        tokenMint: any;
    }>;
    /**
     * Deserializes the {@link LzReceiveTypesAccounts} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [LzReceiveTypesAccounts, number];
    /**
     * Serializes the {@link LzReceiveTypesAccounts} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link LzReceiveTypesAccounts}
     */
    static get byteSize(): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link LzReceiveTypesAccounts} data from rent
     *
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Determines if the provided {@link Buffer} has the correct byte size to
     * hold {@link LzReceiveTypesAccounts} data.
     */
    static hasCorrectByteSize(buf: Buffer, offset?: number): boolean;
    /**
     * Returns a readable version of {@link LzReceiveTypesAccounts} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        oftConfig: string;
        tokenMint: string;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const lzReceiveTypesAccountsBeet: beet.BeetStruct<LzReceiveTypesAccounts, LzReceiveTypesAccountsArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link OftConfigExt} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link OftConfigExt} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type OftConfigExtRecord = {
    Native: {
        fields: [beet.COption<web3.PublicKey>];
    };
    Adapter: {
        fields: [web3.PublicKey];
    };
};
/**
 * Union type respresenting the OftConfigExt data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isOftConfigExt*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type OftConfigExt = beet.DataEnumKeyAsKind<OftConfigExtRecord>;
declare const isOftConfigExtNative: (x: OftConfigExt) => x is {
    __kind: "Native";
} & Omit<{
    fields: [beet.COption<web3.PublicKey>];
}, "void"> & {
    __kind: 'Native';
};
declare const isOftConfigExtAdapter: (x: OftConfigExt) => x is {
    __kind: "Adapter";
} & Omit<{
    fields: [web3.PublicKey];
}, "void"> & {
    __kind: 'Adapter';
};
/**
 * @category userTypes
 * @category generated
 */
declare const oftConfigExtBeet: beet.FixableBeet<OftConfigExt, OftConfigExt>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link OftConfig}
 * @category Accounts
 * @category generated
 */
type OftConfigArgs = {
    ld2sdRate: beet.bignum;
    tokenMint: web3.PublicKey;
    tokenProgram: web3.PublicKey;
    endpointProgram: web3.PublicKey;
    bump: number;
    admin: web3.PublicKey;
    ext: OftConfigExt;
};
declare const oftConfigDiscriminator: number[];
/**
 * Holds the data for the {@link OftConfig} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class OftConfig implements OftConfigArgs {
    readonly ld2sdRate: beet.bignum;
    readonly tokenMint: web3.PublicKey;
    readonly tokenProgram: web3.PublicKey;
    readonly endpointProgram: web3.PublicKey;
    readonly bump: number;
    readonly admin: web3.PublicKey;
    readonly ext: OftConfigExt;
    private constructor();
    /**
     * Creates a {@link OftConfig} instance from the provided args.
     */
    static fromArgs(args: OftConfigArgs): OftConfig;
    /**
     * Deserializes the {@link OftConfig} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [OftConfig, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link OftConfig} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<OftConfig>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<OftConfigArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link OftConfig} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [OftConfig, number];
    /**
     * Serializes the {@link OftConfig} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link OftConfig} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: OftConfigArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link OftConfig} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: OftConfigArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link OftConfig} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        ld2sdRate: number | {
            toNumber: () => number;
        };
        tokenMint: string;
        tokenProgram: string;
        endpointProgram: string;
        bump: number;
        admin: string;
        ext: "Native" | "Adapter";
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const oftConfigBeet: beet.FixableBeetStruct<OftConfig, OftConfigArgs & {
    accountDiscriminator: number[];
}>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type RateLimiter = {
    capacity: beet.bignum;
    tokens: beet.bignum;
    refillPerSecond: beet.bignum;
    lastRefillTime: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const rateLimiterBeet: beet.BeetArgsStruct<RateLimiter>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * Arguments used to create {@link Peer}
 * @category Accounts
 * @category generated
 */
type PeerArgs = {
    address: number[];
    rateLimiter: beet.COption<RateLimiter>;
    bump: number;
};
declare const peerDiscriminator: number[];
/**
 * Holds the data for the {@link Peer} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
declare class Peer implements PeerArgs {
    readonly address: number[];
    readonly rateLimiter: beet.COption<RateLimiter>;
    readonly bump: number;
    private constructor();
    /**
     * Creates a {@link Peer} instance from the provided args.
     */
    static fromArgs(args: PeerArgs): Peer;
    /**
     * Deserializes the {@link Peer} from the data of the provided {@link web3.AccountInfo}.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static fromAccountInfo(accountInfo: web3.AccountInfo<Buffer>, offset?: number): [Peer, number];
    /**
     * Retrieves the account info from the provided address and deserializes
     * the {@link Peer} from its data.
     *
     * @throws Error if no account info is found at the address or if deserialization fails
     */
    static fromAccountAddress(connection: web3.Connection, address: web3.PublicKey, commitmentOrConfig?: web3.Commitment | web3.GetAccountInfoConfig): Promise<Peer>;
    /**
     * Provides a {@link web3.Connection.getProgramAccounts} config builder,
     * to fetch accounts matching filters that can be specified via that builder.
     *
     * @param programId - the program that owns the accounts we are filtering
     */
    static gpaBuilder(programId?: web3.PublicKey): beetSolana.GpaBuilder<PeerArgs & {
        accountDiscriminator: number[];
    }>;
    /**
     * Deserializes the {@link Peer} from the provided data Buffer.
     * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
     */
    static deserialize(buf: Buffer, offset?: number): [Peer, number];
    /**
     * Serializes the {@link Peer} into a Buffer.
     * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
     */
    serialize(): [Buffer, number];
    /**
     * Returns the byteSize of a {@link Buffer} holding the serialized data of
     * {@link Peer} for the provided args.
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     */
    static byteSize(args: PeerArgs): number;
    /**
     * Fetches the minimum balance needed to exempt an account holding
     * {@link Peer} data from rent
     *
     * @param args need to be provided since the byte size for this account
     * depends on them
     * @param connection used to retrieve the rent exemption information
     */
    static getMinimumBalanceForRentExemption(args: PeerArgs, connection: web3.Connection, commitment?: web3.Commitment): Promise<number>;
    /**
     * Returns a readable version of {@link Peer} properties
     * and can be used to convert to JSON and/or logging
     */
    pretty(): {
        address: number[];
        rateLimiter: beet.COption<RateLimiter>;
        bump: number;
    };
}
/**
 * @category Accounts
 * @category generated
 */
declare const peerBeet: beet.FixableBeetStruct<Peer, PeerArgs & {
    accountDiscriminator: number[];
}>;

declare const accountProviders: {
    EnforcedOptions: typeof EnforcedOptions;
    LzReceiveTypesAccounts: typeof LzReceiveTypesAccounts;
    OftConfig: typeof OftConfig;
    Peer: typeof Peer;
};

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode = Error & {
    code: number;
};
type MaybeErrorWithCode = ErrorWithCode | null | undefined;
/**
 * Unauthorized: ''
 *
 * @category Errors
 * @category generated
 */
declare class UnauthorizedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidSender: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSenderError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidDecimals: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidDecimalsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * SlippageExceeded: ''
 *
 * @category Errors
 * @category generated
 */
declare class SlippageExceededError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTokenMint: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTokenMintError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTokenEscrow: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTokenEscrowError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTokenDest: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTokenDestError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidOptions: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidOptionsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidEndpointProgram: ''
 *
 * @category Errors
 * @category generated
 */
declare class InvalidEndpointProgramError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * RateLimitExceeded: ''
 *
 * @category Errors
 * @category generated
 */
declare class RateLimitExceededError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode(code: number): MaybeErrorWithCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName(name: string): MaybeErrorWithCode;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitAdapterOftParams = {
    admin: web3.PublicKey;
    sharedDecimals: number;
    endpointProgram: beet.COption<web3.PublicKey>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initAdapterOftParamsBeet: beet.FixableBeetArgsStruct<InitAdapterOftParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitAdapterOft
 * @category generated
 */
type InitAdapterOftInstructionArgs = {
    params: InitAdapterOftParams;
};
/**
 * @category Instructions
 * @category InitAdapterOft
 * @category generated
 */
declare const initAdapterOftStruct: beet.FixableBeetArgsStruct<InitAdapterOftInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initAdapterOft_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] oftConfig
 * @property [_writable_] lzReceiveTypesAccounts
 * @property [] tokenMint
 * @property [_writable_, **signer**] tokenEscrow
 * @category Instructions
 * @category InitAdapterOft
 * @category generated
 */
type InitAdapterOftInstructionAccounts = {
    payer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    lzReceiveTypesAccounts: web3.PublicKey;
    tokenMint: web3.PublicKey;
    tokenEscrow: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initAdapterOftInstructionDiscriminator: number[];
/**
 * Creates a _InitAdapterOft_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitAdapterOft
 * @category generated
 */
declare function createInitAdapterOftInstruction(accounts: InitAdapterOftInstructionAccounts, args: InitAdapterOftInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitAdapterOft_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitAdapterOft
 * @category generated
 */
declare function createInitAdapterOftInstructionAccounts(accounts: InitAdapterOftInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitOftParams = {
    admin: web3.PublicKey;
    sharedDecimals: number;
    endpointProgram: beet.COption<web3.PublicKey>;
    mintAuthority: beet.COption<web3.PublicKey>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initOftParamsBeet: beet.FixableBeetArgsStruct<InitOftParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category InitOft
 * @category generated
 */
type InitOftInstructionArgs = {
    params: InitOftParams;
};
/**
 * @category Instructions
 * @category InitOft
 * @category generated
 */
declare const initOftStruct: beet.FixableBeetArgsStruct<InitOftInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _initOft_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] oftConfig
 * @property [_writable_] lzReceiveTypesAccounts
 * @property [] tokenMint
 * @category Instructions
 * @category InitOft
 * @category generated
 */
type InitOftInstructionAccounts = {
    payer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    lzReceiveTypesAccounts: web3.PublicKey;
    tokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const initOftInstructionDiscriminator: number[];
/**
 * Creates a _InitOft_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category InitOft
 * @category generated
 */
declare function createInitOftInstruction(accounts: InitOftInstructionAccounts, args: InitOftInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _InitOft_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category InitOft
 * @category generated
 */
declare function createInitOftInstructionAccounts(accounts: InitOftInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzReceiveParams$1 = {
    srcEid: number;
    sender: number[];
    nonce: beet.bignum;
    guid: number[];
    message: Uint8Array;
    extraData: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzReceiveParamsBeet: beet.FixableBeetArgsStruct<LzReceiveParams$1>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category LzReceive
 * @category generated
 */
type LzReceiveInstructionArgs = {
    params: LzReceiveParams$1;
};
/**
 * @category Instructions
 * @category LzReceive
 * @category generated
 */
declare const lzReceiveStruct: beet.FixableBeetArgsStruct<LzReceiveInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _lzReceive_ instruction
 *
 * @property [_writable_, **signer**] payer
 * @property [_writable_] peer
 * @property [] oftConfig
 * @property [_writable_] tokenEscrow (optional)
 * @property [] toAddress
 * @property [_writable_] tokenDest
 * @property [_writable_] tokenMint
 * @property [] associatedTokenProgram
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category LzReceive
 * @category generated
 */
type LzReceiveInstructionAccounts = {
    payer: web3.PublicKey;
    peer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    tokenEscrow?: web3.PublicKey;
    toAddress: web3.PublicKey;
    tokenDest: web3.PublicKey;
    tokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    associatedTokenProgram: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const lzReceiveInstructionDiscriminator: number[];
/**
 * Creates a _LzReceive_ instruction.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category LzReceive
 * @category generated
 */
declare function createLzReceiveInstruction(accounts: LzReceiveInstructionAccounts, args: LzReceiveInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _LzReceive_ instructionAccounts.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category LzReceive
 * @category generated
 */
declare function createLzReceiveInstructionAccounts(accounts: LzReceiveInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category LzReceiveTypes
 * @category generated
 */
type LzReceiveTypesInstructionArgs = {
    params: LzReceiveParams$1;
};
/**
 * @category Instructions
 * @category LzReceiveTypes
 * @category generated
 */
declare const lzReceiveTypesStruct: beet.FixableBeetArgsStruct<LzReceiveTypesInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _lzReceiveTypes_ instruction
 *
 * @property [] oftConfig
 * @property [] tokenMint
 * @category Instructions
 * @category LzReceiveTypes
 * @category generated
 */
type LzReceiveTypesInstructionAccounts = {
    oftConfig: web3.PublicKey;
    tokenMint: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const lzReceiveTypesInstructionDiscriminator: number[];
/**
 * Creates a _LzReceiveTypes_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category LzReceiveTypes
 * @category generated
 */
declare function createLzReceiveTypesInstruction(accounts: LzReceiveTypesInstructionAccounts, args: LzReceiveTypesInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _LzReceiveTypes_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category LzReceiveTypes
 * @category generated
 */
declare function createLzReceiveTypesInstructionAccounts(accounts: LzReceiveTypesInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MintToParams = {
    amount: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const mintToParamsBeet: beet.BeetArgsStruct<MintToParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category MintTo
 * @category generated
 */
type MintToInstructionArgs = {
    params: MintToParams;
};
/**
 * @category Instructions
 * @category MintTo
 * @category generated
 */
declare const mintToStruct: beet.BeetArgsStruct<MintToInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _mintTo_ instruction
 *
 * @property [**signer**] minter
 * @property [] oftConfig
 * @property [_writable_] tokenDest
 * @property [_writable_] tokenMint
 * @category Instructions
 * @category MintTo
 * @category generated
 */
type MintToInstructionAccounts = {
    minter: web3.PublicKey;
    oftConfig: web3.PublicKey;
    tokenDest: web3.PublicKey;
    tokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const mintToInstructionDiscriminator: number[];
/**
 * Creates a _MintTo_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category MintTo
 * @category generated
 */
declare function createMintToInstruction(accounts: MintToInstructionAccounts, args: MintToInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _MintTo_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category MintTo
 * @category generated
 */
declare function createMintToInstructionAccounts(accounts: MintToInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteParams = {
    dstEid: number;
    to: number[];
    amountLd: beet.bignum;
    minAmountLd: beet.bignum;
    options: Uint8Array;
    composeMsg: beet.COption<Uint8Array>;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteParamsBeet: beet.FixableBeetArgsStruct<QuoteParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionArgs = {
    params: QuoteParams;
};
/**
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare const quoteStruct: beet.FixableBeetArgsStruct<QuoteInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quote_ instruction
 *
 * @property [] oftConfig
 * @property [] peer
 * @property [] enforcedOptions
 * @property [] tokenMint
 * @category Instructions
 * @category Quote
 * @category generated
 */
type QuoteInstructionAccounts = {
    oftConfig: web3.PublicKey;
    peer: web3.PublicKey;
    enforcedOptions: web3.PublicKey;
    tokenMint: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteInstructionDiscriminator: number[];
/**
 * Creates a _Quote_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstruction(accounts: QuoteInstructionAccounts, args: QuoteInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Quote_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Quote
 * @category generated
 */
declare function createQuoteInstructionAccounts(accounts: QuoteInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteOftParams = {
    dstEid: number;
    to: number[];
    amountLd: beet.bignum;
    minAmountLd: beet.bignum;
    options: Uint8Array;
    composeMsg: beet.COption<Uint8Array>;
    payInLzToken: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteOftParamsBeet: beet.FixableBeetArgsStruct<QuoteOftParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category QuoteOft
 * @category generated
 */
type QuoteOftInstructionArgs = {
    params: QuoteOftParams;
};
/**
 * @category Instructions
 * @category QuoteOft
 * @category generated
 */
declare const quoteOftStruct: beet.FixableBeetArgsStruct<QuoteOftInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _quoteOft_ instruction
 *
 * @property [] oftConfig
 * @property [] peer
 * @property [] tokenMint
 * @category Instructions
 * @category QuoteOft
 * @category generated
 */
type QuoteOftInstructionAccounts = {
    oftConfig: web3.PublicKey;
    peer: web3.PublicKey;
    tokenMint: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const quoteOftInstructionDiscriminator: number[];
/**
 * Creates a _QuoteOft_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category QuoteOft
 * @category generated
 */
declare function createQuoteOftInstruction(accounts: QuoteOftInstructionAccounts, args: QuoteOftInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _QuoteOft_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category QuoteOft
 * @category generated
 */
declare function createQuoteOftInstructionAccounts(accounts: QuoteOftInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SendParams = {
    dstEid: number;
    to: number[];
    amountLd: beet.bignum;
    minAmountLd: beet.bignum;
    options: Uint8Array;
    composeMsg: beet.COption<Uint8Array>;
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const sendParamsBeet: beet.FixableBeetArgsStruct<SendParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionArgs = {
    params: SendParams;
};
/**
 * @category Instructions
 * @category Send
 * @category generated
 */
declare const sendStruct: beet.FixableBeetArgsStruct<SendInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _send_ instruction
 *
 * @property [**signer**] signer
 * @property [_writable_] peer
 * @property [] enforcedOptions
 * @property [] oftConfig
 * @property [_writable_] tokenSource
 * @property [_writable_] tokenEscrow (optional)
 * @property [_writable_] tokenMint
 * @property [] eventAuthority
 * @property [] program
 * @category Instructions
 * @category Send
 * @category generated
 */
type SendInstructionAccounts = {
    signer: web3.PublicKey;
    peer: web3.PublicKey;
    enforcedOptions: web3.PublicKey;
    oftConfig: web3.PublicKey;
    tokenSource: web3.PublicKey;
    tokenEscrow?: web3.PublicKey;
    tokenMint: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
    eventAuthority: web3.PublicKey;
    program: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const sendInstructionDiscriminator: number[];
/**
 * Creates a _Send_ instruction.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstruction(accounts: SendInstructionAccounts, args: SendInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Send_ instructionAccounts.
 *
 * Optional accounts that are not provided default to the program ID since
 * this was indicated in the IDL from which this instruction was generated.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Send
 * @category generated
 */
declare function createSendInstructionAccounts(accounts: SendInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetDelegateParams = {
    delegate: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setDelegateParamsBeet: beet.BeetArgsStruct<SetDelegateParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
type SetDelegateInstructionArgs = {
    params: SetDelegateParams;
};
/**
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare const setDelegateStruct: beet.BeetArgsStruct<SetDelegateInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setDelegate_ instruction
 *
 * @property [**signer**] admin
 * @property [] oftConfig
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
type SetDelegateInstructionAccounts = {
    admin: web3.PublicKey;
    oftConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setDelegateInstructionDiscriminator: number[];
/**
 * Creates a _SetDelegate_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare function createSetDelegateInstruction(accounts: SetDelegateInstructionAccounts, args: SetDelegateInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetDelegate_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetDelegate
 * @category generated
 */
declare function createSetDelegateInstructionAccounts(accounts: SetDelegateInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetEnforcedOptionsParams = {
    dstEid: number;
    send: Uint8Array;
    sendAndCall: Uint8Array;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setEnforcedOptionsParamsBeet: beet.FixableBeetArgsStruct<SetEnforcedOptionsParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetEnforcedOptions
 * @category generated
 */
type SetEnforcedOptionsInstructionArgs = {
    params: SetEnforcedOptionsParams;
};
/**
 * @category Instructions
 * @category SetEnforcedOptions
 * @category generated
 */
declare const setEnforcedOptionsStruct: beet.FixableBeetArgsStruct<SetEnforcedOptionsInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setEnforcedOptions_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [_writable_] enforcedOptions
 * @property [] oftConfig
 * @category Instructions
 * @category SetEnforcedOptions
 * @category generated
 */
type SetEnforcedOptionsInstructionAccounts = {
    admin: web3.PublicKey;
    enforcedOptions: web3.PublicKey;
    oftConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setEnforcedOptionsInstructionDiscriminator: number[];
/**
 * Creates a _SetEnforcedOptions_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetEnforcedOptions
 * @category generated
 */
declare function createSetEnforcedOptionsInstruction(accounts: SetEnforcedOptionsInstructionAccounts, args: SetEnforcedOptionsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetEnforcedOptions_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetEnforcedOptions
 * @category generated
 */
declare function createSetEnforcedOptionsInstructionAccounts(accounts: SetEnforcedOptionsInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetMintAuthorityParams = {
    mintAuthority: beet.COption<web3.PublicKey>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setMintAuthorityParamsBeet: beet.FixableBeetArgsStruct<SetMintAuthorityParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetMintAuthority
 * @category generated
 */
type SetMintAuthorityInstructionArgs = {
    params: SetMintAuthorityParams;
};
/**
 * @category Instructions
 * @category SetMintAuthority
 * @category generated
 */
declare const setMintAuthorityStruct: beet.FixableBeetArgsStruct<SetMintAuthorityInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setMintAuthority_ instruction
 *
 * @property [**signer**] signer
 * @property [_writable_] oftConfig
 * @category Instructions
 * @category SetMintAuthority
 * @category generated
 */
type SetMintAuthorityInstructionAccounts = {
    signer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setMintAuthorityInstructionDiscriminator: number[];
/**
 * Creates a _SetMintAuthority_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetMintAuthority
 * @category generated
 */
declare function createSetMintAuthorityInstruction(accounts: SetMintAuthorityInstructionAccounts, args: SetMintAuthorityInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetMintAuthority_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetMintAuthority
 * @category generated
 */
declare function createSetMintAuthorityInstructionAccounts(accounts: SetMintAuthorityInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetPeerParams = {
    dstEid: number;
    peer: number[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const setPeerParamsBeet: beet.BeetArgsStruct<SetPeerParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetPeer
 * @category generated
 */
type SetPeerInstructionArgs = {
    params: SetPeerParams;
};
/**
 * @category Instructions
 * @category SetPeer
 * @category generated
 */
declare const setPeerStruct: beet.BeetArgsStruct<SetPeerInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setPeer_ instruction
 *
 * @property [_writable_, **signer**] admin
 * @property [_writable_] peer
 * @property [] oftConfig
 * @category Instructions
 * @category SetPeer
 * @category generated
 */
type SetPeerInstructionAccounts = {
    admin: web3.PublicKey;
    peer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    systemProgram?: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setPeerInstructionDiscriminator: number[];
/**
 * Creates a _SetPeer_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetPeer
 * @category generated
 */
declare function createSetPeerInstruction(accounts: SetPeerInstructionAccounts, args: SetPeerInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetPeer_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetPeer
 * @category generated
 */
declare function createSetPeerInstructionAccounts(accounts: SetPeerInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type SetRateLimitParams = {
    dstEid: number;
    refillPerSecond: beet.COption<beet.bignum>;
    capacity: beet.COption<beet.bignum>;
    enabled: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const setRateLimitParamsBeet: beet.FixableBeetArgsStruct<SetRateLimitParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SetRateLimit
 * @category generated
 */
type SetRateLimitInstructionArgs = {
    params: SetRateLimitParams;
};
/**
 * @category Instructions
 * @category SetRateLimit
 * @category generated
 */
declare const setRateLimitStruct: beet.FixableBeetArgsStruct<SetRateLimitInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _setRateLimit_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] peer
 * @property [] oftConfig
 * @category Instructions
 * @category SetRateLimit
 * @category generated
 */
type SetRateLimitInstructionAccounts = {
    admin: web3.PublicKey;
    peer: web3.PublicKey;
    oftConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const setRateLimitInstructionDiscriminator: number[];
/**
 * Creates a _SetRateLimit_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SetRateLimit
 * @category generated
 */
declare function createSetRateLimitInstruction(accounts: SetRateLimitInstructionAccounts, args: SetRateLimitInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _SetRateLimit_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category SetRateLimit
 * @category generated
 */
declare function createSetRateLimitInstructionAccounts(accounts: SetRateLimitInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TransferAdminParams = {
    admin: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const transferAdminParamsBeet: beet.BeetArgsStruct<TransferAdminParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionArgs = {
    params: TransferAdminParams;
};
/**
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare const transferAdminStruct: beet.BeetArgsStruct<TransferAdminInstructionArgs & {
    instructionDiscriminator: number[];
}>;
/**
 * Accounts required by the _transferAdmin_ instruction
 *
 * @property [**signer**] admin
 * @property [_writable_] oftConfig
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
type TransferAdminInstructionAccounts = {
    admin: web3.PublicKey;
    oftConfig: web3.PublicKey;
    anchorRemainingAccounts?: web3.AccountMeta[];
};
declare const transferAdminInstructionDiscriminator: number[];
/**
 * Creates a _TransferAdmin_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstruction(accounts: TransferAdminInstructionAccounts, args: TransferAdminInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _TransferAdmin_ instructionAccounts.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category TransferAdmin
 * @category generated
 */
declare function createTransferAdminInstructionAccounts(accounts: TransferAdminInstructionAccounts, programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Version
 * @category generated
 */
declare const versionStruct$1: beet.BeetArgsStruct<{
    instructionDiscriminator: number[];
}>;
declare const versionInstructionDiscriminator$1: number[];
/**
 * Creates a _Version_ instruction.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstruction$1(programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Version_ instructionAccounts.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstructionAccounts$1(programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type LzAccount = {
    pubkey: web3.PublicKey;
    isSigner: boolean;
    isWritable: boolean;
};
/**
 * @category userTypes
 * @category generated
 */
declare const lzAccountBeet: beet.BeetArgsStruct<LzAccount>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingFee = {
    nativeFee: beet.bignum;
    lzTokenFee: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingFeeBeet: beet.BeetArgsStruct<MessagingFee>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MessagingReceipt = {
    guid: number[];
    nonce: beet.bignum;
    fee: MessagingFee;
};
/**
 * @category userTypes
 * @category generated
 */
declare const messagingReceiptBeet: beet.BeetArgsStruct<MessagingReceipt>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type OFTFeeDetail = {
    feeAmountLd: beet.bignum;
    description: string;
};
/**
 * @category userTypes
 * @category generated
 */
declare const oFTFeeDetailBeet: beet.FixableBeetArgsStruct<OFTFeeDetail>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type OFTLimits = {
    minAmountLd: beet.bignum;
    maxAmountLd: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const oFTLimitsBeet: beet.BeetArgsStruct<OFTLimits>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type OFTReceipt = {
    amountSentLd: beet.bignum;
    amountReceivedLd: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const oFTReceiptBeet: beet.BeetArgsStruct<OFTReceipt>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type QuoteOftResult = {
    oftLimits: OFTLimits;
    oftFeeDetails: OFTFeeDetail[];
    oftReceipt: OFTReceipt;
};
/**
 * @category userTypes
 * @category generated
 */
declare const quoteOftResultBeet: beet.FixableBeetArgsStruct<QuoteOftResult>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Version = {
    sdkVersion: beet.bignum;
    oftVersion: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const versionBeet: beet.BeetArgsStruct<Version>;

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS$1 = "HRPXLCqspQocTjfcX4rvAPaY9q6Gwb1rrD3xXWrfJWdW";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID$1: PublicKey;

type index$1_EnforcedOptions = EnforcedOptions;
declare const index$1_EnforcedOptions: typeof EnforcedOptions;
type index$1_EnforcedOptionsArgs = EnforcedOptionsArgs;
type index$1_InitAdapterOftInstructionAccounts = InitAdapterOftInstructionAccounts;
type index$1_InitAdapterOftInstructionArgs = InitAdapterOftInstructionArgs;
type index$1_InitAdapterOftParams = InitAdapterOftParams;
type index$1_InitOftInstructionAccounts = InitOftInstructionAccounts;
type index$1_InitOftInstructionArgs = InitOftInstructionArgs;
type index$1_InitOftParams = InitOftParams;
type index$1_InvalidDecimalsError = InvalidDecimalsError;
declare const index$1_InvalidDecimalsError: typeof InvalidDecimalsError;
type index$1_InvalidEndpointProgramError = InvalidEndpointProgramError;
declare const index$1_InvalidEndpointProgramError: typeof InvalidEndpointProgramError;
type index$1_InvalidOptionsError = InvalidOptionsError;
declare const index$1_InvalidOptionsError: typeof InvalidOptionsError;
type index$1_InvalidSenderError = InvalidSenderError;
declare const index$1_InvalidSenderError: typeof InvalidSenderError;
type index$1_InvalidTokenDestError = InvalidTokenDestError;
declare const index$1_InvalidTokenDestError: typeof InvalidTokenDestError;
type index$1_InvalidTokenEscrowError = InvalidTokenEscrowError;
declare const index$1_InvalidTokenEscrowError: typeof InvalidTokenEscrowError;
type index$1_InvalidTokenMintError = InvalidTokenMintError;
declare const index$1_InvalidTokenMintError: typeof InvalidTokenMintError;
type index$1_LzAccount = LzAccount;
type index$1_LzReceiveInstructionAccounts = LzReceiveInstructionAccounts;
type index$1_LzReceiveInstructionArgs = LzReceiveInstructionArgs;
type index$1_LzReceiveTypesAccounts = LzReceiveTypesAccounts;
declare const index$1_LzReceiveTypesAccounts: typeof LzReceiveTypesAccounts;
type index$1_LzReceiveTypesAccountsArgs = LzReceiveTypesAccountsArgs;
type index$1_LzReceiveTypesInstructionAccounts = LzReceiveTypesInstructionAccounts;
type index$1_LzReceiveTypesInstructionArgs = LzReceiveTypesInstructionArgs;
type index$1_MessagingFee = MessagingFee;
type index$1_MessagingReceipt = MessagingReceipt;
type index$1_MintToInstructionAccounts = MintToInstructionAccounts;
type index$1_MintToInstructionArgs = MintToInstructionArgs;
type index$1_MintToParams = MintToParams;
type index$1_OFTFeeDetail = OFTFeeDetail;
type index$1_OFTLimits = OFTLimits;
type index$1_OFTReceipt = OFTReceipt;
type index$1_OftConfig = OftConfig;
declare const index$1_OftConfig: typeof OftConfig;
type index$1_OftConfigArgs = OftConfigArgs;
type index$1_OftConfigExt = OftConfigExt;
type index$1_OftConfigExtRecord = OftConfigExtRecord;
type index$1_Peer = Peer;
declare const index$1_Peer: typeof Peer;
type index$1_PeerArgs = PeerArgs;
type index$1_QuoteInstructionAccounts = QuoteInstructionAccounts;
type index$1_QuoteInstructionArgs = QuoteInstructionArgs;
type index$1_QuoteOftInstructionAccounts = QuoteOftInstructionAccounts;
type index$1_QuoteOftInstructionArgs = QuoteOftInstructionArgs;
type index$1_QuoteOftParams = QuoteOftParams;
type index$1_QuoteOftResult = QuoteOftResult;
type index$1_QuoteParams = QuoteParams;
type index$1_RateLimitExceededError = RateLimitExceededError;
declare const index$1_RateLimitExceededError: typeof RateLimitExceededError;
type index$1_RateLimiter = RateLimiter;
type index$1_SendInstructionAccounts = SendInstructionAccounts;
type index$1_SendInstructionArgs = SendInstructionArgs;
type index$1_SendParams = SendParams;
type index$1_SetDelegateInstructionAccounts = SetDelegateInstructionAccounts;
type index$1_SetDelegateInstructionArgs = SetDelegateInstructionArgs;
type index$1_SetDelegateParams = SetDelegateParams;
type index$1_SetEnforcedOptionsInstructionAccounts = SetEnforcedOptionsInstructionAccounts;
type index$1_SetEnforcedOptionsInstructionArgs = SetEnforcedOptionsInstructionArgs;
type index$1_SetEnforcedOptionsParams = SetEnforcedOptionsParams;
type index$1_SetMintAuthorityInstructionAccounts = SetMintAuthorityInstructionAccounts;
type index$1_SetMintAuthorityInstructionArgs = SetMintAuthorityInstructionArgs;
type index$1_SetMintAuthorityParams = SetMintAuthorityParams;
type index$1_SetPeerInstructionAccounts = SetPeerInstructionAccounts;
type index$1_SetPeerInstructionArgs = SetPeerInstructionArgs;
type index$1_SetPeerParams = SetPeerParams;
type index$1_SetRateLimitInstructionAccounts = SetRateLimitInstructionAccounts;
type index$1_SetRateLimitInstructionArgs = SetRateLimitInstructionArgs;
type index$1_SetRateLimitParams = SetRateLimitParams;
type index$1_SlippageExceededError = SlippageExceededError;
declare const index$1_SlippageExceededError: typeof SlippageExceededError;
type index$1_TransferAdminInstructionAccounts = TransferAdminInstructionAccounts;
type index$1_TransferAdminInstructionArgs = TransferAdminInstructionArgs;
type index$1_TransferAdminParams = TransferAdminParams;
type index$1_UnauthorizedError = UnauthorizedError;
declare const index$1_UnauthorizedError: typeof UnauthorizedError;
type index$1_Version = Version;
declare const index$1_accountProviders: typeof accountProviders;
declare const index$1_createInitAdapterOftInstruction: typeof createInitAdapterOftInstruction;
declare const index$1_createInitAdapterOftInstructionAccounts: typeof createInitAdapterOftInstructionAccounts;
declare const index$1_createInitOftInstruction: typeof createInitOftInstruction;
declare const index$1_createInitOftInstructionAccounts: typeof createInitOftInstructionAccounts;
declare const index$1_createLzReceiveInstruction: typeof createLzReceiveInstruction;
declare const index$1_createLzReceiveInstructionAccounts: typeof createLzReceiveInstructionAccounts;
declare const index$1_createLzReceiveTypesInstruction: typeof createLzReceiveTypesInstruction;
declare const index$1_createLzReceiveTypesInstructionAccounts: typeof createLzReceiveTypesInstructionAccounts;
declare const index$1_createMintToInstruction: typeof createMintToInstruction;
declare const index$1_createMintToInstructionAccounts: typeof createMintToInstructionAccounts;
declare const index$1_createQuoteInstruction: typeof createQuoteInstruction;
declare const index$1_createQuoteInstructionAccounts: typeof createQuoteInstructionAccounts;
declare const index$1_createQuoteOftInstruction: typeof createQuoteOftInstruction;
declare const index$1_createQuoteOftInstructionAccounts: typeof createQuoteOftInstructionAccounts;
declare const index$1_createSendInstruction: typeof createSendInstruction;
declare const index$1_createSendInstructionAccounts: typeof createSendInstructionAccounts;
declare const index$1_createSetDelegateInstruction: typeof createSetDelegateInstruction;
declare const index$1_createSetDelegateInstructionAccounts: typeof createSetDelegateInstructionAccounts;
declare const index$1_createSetEnforcedOptionsInstruction: typeof createSetEnforcedOptionsInstruction;
declare const index$1_createSetEnforcedOptionsInstructionAccounts: typeof createSetEnforcedOptionsInstructionAccounts;
declare const index$1_createSetMintAuthorityInstruction: typeof createSetMintAuthorityInstruction;
declare const index$1_createSetMintAuthorityInstructionAccounts: typeof createSetMintAuthorityInstructionAccounts;
declare const index$1_createSetPeerInstruction: typeof createSetPeerInstruction;
declare const index$1_createSetPeerInstructionAccounts: typeof createSetPeerInstructionAccounts;
declare const index$1_createSetRateLimitInstruction: typeof createSetRateLimitInstruction;
declare const index$1_createSetRateLimitInstructionAccounts: typeof createSetRateLimitInstructionAccounts;
declare const index$1_createTransferAdminInstruction: typeof createTransferAdminInstruction;
declare const index$1_createTransferAdminInstructionAccounts: typeof createTransferAdminInstructionAccounts;
declare const index$1_enforcedOptionsBeet: typeof enforcedOptionsBeet;
declare const index$1_enforcedOptionsDiscriminator: typeof enforcedOptionsDiscriminator;
declare const index$1_errorFromCode: typeof errorFromCode;
declare const index$1_errorFromName: typeof errorFromName;
declare const index$1_initAdapterOftInstructionDiscriminator: typeof initAdapterOftInstructionDiscriminator;
declare const index$1_initAdapterOftParamsBeet: typeof initAdapterOftParamsBeet;
declare const index$1_initAdapterOftStruct: typeof initAdapterOftStruct;
declare const index$1_initOftInstructionDiscriminator: typeof initOftInstructionDiscriminator;
declare const index$1_initOftParamsBeet: typeof initOftParamsBeet;
declare const index$1_initOftStruct: typeof initOftStruct;
declare const index$1_isOftConfigExtAdapter: typeof isOftConfigExtAdapter;
declare const index$1_isOftConfigExtNative: typeof isOftConfigExtNative;
declare const index$1_lzAccountBeet: typeof lzAccountBeet;
declare const index$1_lzReceiveInstructionDiscriminator: typeof lzReceiveInstructionDiscriminator;
declare const index$1_lzReceiveParamsBeet: typeof lzReceiveParamsBeet;
declare const index$1_lzReceiveStruct: typeof lzReceiveStruct;
declare const index$1_lzReceiveTypesAccountsBeet: typeof lzReceiveTypesAccountsBeet;
declare const index$1_lzReceiveTypesAccountsDiscriminator: typeof lzReceiveTypesAccountsDiscriminator;
declare const index$1_lzReceiveTypesInstructionDiscriminator: typeof lzReceiveTypesInstructionDiscriminator;
declare const index$1_lzReceiveTypesStruct: typeof lzReceiveTypesStruct;
declare const index$1_messagingFeeBeet: typeof messagingFeeBeet;
declare const index$1_messagingReceiptBeet: typeof messagingReceiptBeet;
declare const index$1_mintToInstructionDiscriminator: typeof mintToInstructionDiscriminator;
declare const index$1_mintToParamsBeet: typeof mintToParamsBeet;
declare const index$1_mintToStruct: typeof mintToStruct;
declare const index$1_oFTFeeDetailBeet: typeof oFTFeeDetailBeet;
declare const index$1_oFTLimitsBeet: typeof oFTLimitsBeet;
declare const index$1_oFTReceiptBeet: typeof oFTReceiptBeet;
declare const index$1_oftConfigBeet: typeof oftConfigBeet;
declare const index$1_oftConfigDiscriminator: typeof oftConfigDiscriminator;
declare const index$1_oftConfigExtBeet: typeof oftConfigExtBeet;
declare const index$1_peerBeet: typeof peerBeet;
declare const index$1_peerDiscriminator: typeof peerDiscriminator;
declare const index$1_quoteInstructionDiscriminator: typeof quoteInstructionDiscriminator;
declare const index$1_quoteOftInstructionDiscriminator: typeof quoteOftInstructionDiscriminator;
declare const index$1_quoteOftParamsBeet: typeof quoteOftParamsBeet;
declare const index$1_quoteOftResultBeet: typeof quoteOftResultBeet;
declare const index$1_quoteOftStruct: typeof quoteOftStruct;
declare const index$1_quoteParamsBeet: typeof quoteParamsBeet;
declare const index$1_quoteStruct: typeof quoteStruct;
declare const index$1_rateLimiterBeet: typeof rateLimiterBeet;
declare const index$1_sendInstructionDiscriminator: typeof sendInstructionDiscriminator;
declare const index$1_sendParamsBeet: typeof sendParamsBeet;
declare const index$1_sendStruct: typeof sendStruct;
declare const index$1_setDelegateInstructionDiscriminator: typeof setDelegateInstructionDiscriminator;
declare const index$1_setDelegateParamsBeet: typeof setDelegateParamsBeet;
declare const index$1_setDelegateStruct: typeof setDelegateStruct;
declare const index$1_setEnforcedOptionsInstructionDiscriminator: typeof setEnforcedOptionsInstructionDiscriminator;
declare const index$1_setEnforcedOptionsParamsBeet: typeof setEnforcedOptionsParamsBeet;
declare const index$1_setEnforcedOptionsStruct: typeof setEnforcedOptionsStruct;
declare const index$1_setMintAuthorityInstructionDiscriminator: typeof setMintAuthorityInstructionDiscriminator;
declare const index$1_setMintAuthorityParamsBeet: typeof setMintAuthorityParamsBeet;
declare const index$1_setMintAuthorityStruct: typeof setMintAuthorityStruct;
declare const index$1_setPeerInstructionDiscriminator: typeof setPeerInstructionDiscriminator;
declare const index$1_setPeerParamsBeet: typeof setPeerParamsBeet;
declare const index$1_setPeerStruct: typeof setPeerStruct;
declare const index$1_setRateLimitInstructionDiscriminator: typeof setRateLimitInstructionDiscriminator;
declare const index$1_setRateLimitParamsBeet: typeof setRateLimitParamsBeet;
declare const index$1_setRateLimitStruct: typeof setRateLimitStruct;
declare const index$1_transferAdminInstructionDiscriminator: typeof transferAdminInstructionDiscriminator;
declare const index$1_transferAdminParamsBeet: typeof transferAdminParamsBeet;
declare const index$1_transferAdminStruct: typeof transferAdminStruct;
declare const index$1_versionBeet: typeof versionBeet;
declare namespace index$1 {
  export { index$1_EnforcedOptions as EnforcedOptions, type index$1_EnforcedOptionsArgs as EnforcedOptionsArgs, type index$1_InitAdapterOftInstructionAccounts as InitAdapterOftInstructionAccounts, type index$1_InitAdapterOftInstructionArgs as InitAdapterOftInstructionArgs, type index$1_InitAdapterOftParams as InitAdapterOftParams, type index$1_InitOftInstructionAccounts as InitOftInstructionAccounts, type index$1_InitOftInstructionArgs as InitOftInstructionArgs, type index$1_InitOftParams as InitOftParams, index$1_InvalidDecimalsError as InvalidDecimalsError, index$1_InvalidEndpointProgramError as InvalidEndpointProgramError, index$1_InvalidOptionsError as InvalidOptionsError, index$1_InvalidSenderError as InvalidSenderError, index$1_InvalidTokenDestError as InvalidTokenDestError, index$1_InvalidTokenEscrowError as InvalidTokenEscrowError, index$1_InvalidTokenMintError as InvalidTokenMintError, type index$1_LzAccount as LzAccount, type index$1_LzReceiveInstructionAccounts as LzReceiveInstructionAccounts, type index$1_LzReceiveInstructionArgs as LzReceiveInstructionArgs, type LzReceiveParams$1 as LzReceiveParams, index$1_LzReceiveTypesAccounts as LzReceiveTypesAccounts, type index$1_LzReceiveTypesAccountsArgs as LzReceiveTypesAccountsArgs, type index$1_LzReceiveTypesInstructionAccounts as LzReceiveTypesInstructionAccounts, type index$1_LzReceiveTypesInstructionArgs as LzReceiveTypesInstructionArgs, type index$1_MessagingFee as MessagingFee, type index$1_MessagingReceipt as MessagingReceipt, type index$1_MintToInstructionAccounts as MintToInstructionAccounts, type index$1_MintToInstructionArgs as MintToInstructionArgs, type index$1_MintToParams as MintToParams, type index$1_OFTFeeDetail as OFTFeeDetail, type index$1_OFTLimits as OFTLimits, type index$1_OFTReceipt as OFTReceipt, index$1_OftConfig as OftConfig, type index$1_OftConfigArgs as OftConfigArgs, type index$1_OftConfigExt as OftConfigExt, type index$1_OftConfigExtRecord as OftConfigExtRecord, PROGRAM_ADDRESS$1 as PROGRAM_ADDRESS, PROGRAM_ID$1 as PROGRAM_ID, index$1_Peer as Peer, type index$1_PeerArgs as PeerArgs, type index$1_QuoteInstructionAccounts as QuoteInstructionAccounts, type index$1_QuoteInstructionArgs as QuoteInstructionArgs, type index$1_QuoteOftInstructionAccounts as QuoteOftInstructionAccounts, type index$1_QuoteOftInstructionArgs as QuoteOftInstructionArgs, type index$1_QuoteOftParams as QuoteOftParams, type index$1_QuoteOftResult as QuoteOftResult, type index$1_QuoteParams as QuoteParams, index$1_RateLimitExceededError as RateLimitExceededError, type index$1_RateLimiter as RateLimiter, type index$1_SendInstructionAccounts as SendInstructionAccounts, type index$1_SendInstructionArgs as SendInstructionArgs, type index$1_SendParams as SendParams, type index$1_SetDelegateInstructionAccounts as SetDelegateInstructionAccounts, type index$1_SetDelegateInstructionArgs as SetDelegateInstructionArgs, type index$1_SetDelegateParams as SetDelegateParams, type index$1_SetEnforcedOptionsInstructionAccounts as SetEnforcedOptionsInstructionAccounts, type index$1_SetEnforcedOptionsInstructionArgs as SetEnforcedOptionsInstructionArgs, type index$1_SetEnforcedOptionsParams as SetEnforcedOptionsParams, type index$1_SetMintAuthorityInstructionAccounts as SetMintAuthorityInstructionAccounts, type index$1_SetMintAuthorityInstructionArgs as SetMintAuthorityInstructionArgs, type index$1_SetMintAuthorityParams as SetMintAuthorityParams, type index$1_SetPeerInstructionAccounts as SetPeerInstructionAccounts, type index$1_SetPeerInstructionArgs as SetPeerInstructionArgs, type index$1_SetPeerParams as SetPeerParams, type index$1_SetRateLimitInstructionAccounts as SetRateLimitInstructionAccounts, type index$1_SetRateLimitInstructionArgs as SetRateLimitInstructionArgs, type index$1_SetRateLimitParams as SetRateLimitParams, index$1_SlippageExceededError as SlippageExceededError, type index$1_TransferAdminInstructionAccounts as TransferAdminInstructionAccounts, type index$1_TransferAdminInstructionArgs as TransferAdminInstructionArgs, type index$1_TransferAdminParams as TransferAdminParams, index$1_UnauthorizedError as UnauthorizedError, type index$1_Version as Version, index$1_accountProviders as accountProviders, index$1_createInitAdapterOftInstruction as createInitAdapterOftInstruction, index$1_createInitAdapterOftInstructionAccounts as createInitAdapterOftInstructionAccounts, index$1_createInitOftInstruction as createInitOftInstruction, index$1_createInitOftInstructionAccounts as createInitOftInstructionAccounts, index$1_createLzReceiveInstruction as createLzReceiveInstruction, index$1_createLzReceiveInstructionAccounts as createLzReceiveInstructionAccounts, index$1_createLzReceiveTypesInstruction as createLzReceiveTypesInstruction, index$1_createLzReceiveTypesInstructionAccounts as createLzReceiveTypesInstructionAccounts, index$1_createMintToInstruction as createMintToInstruction, index$1_createMintToInstructionAccounts as createMintToInstructionAccounts, index$1_createQuoteInstruction as createQuoteInstruction, index$1_createQuoteInstructionAccounts as createQuoteInstructionAccounts, index$1_createQuoteOftInstruction as createQuoteOftInstruction, index$1_createQuoteOftInstructionAccounts as createQuoteOftInstructionAccounts, index$1_createSendInstruction as createSendInstruction, index$1_createSendInstructionAccounts as createSendInstructionAccounts, index$1_createSetDelegateInstruction as createSetDelegateInstruction, index$1_createSetDelegateInstructionAccounts as createSetDelegateInstructionAccounts, index$1_createSetEnforcedOptionsInstruction as createSetEnforcedOptionsInstruction, index$1_createSetEnforcedOptionsInstructionAccounts as createSetEnforcedOptionsInstructionAccounts, index$1_createSetMintAuthorityInstruction as createSetMintAuthorityInstruction, index$1_createSetMintAuthorityInstructionAccounts as createSetMintAuthorityInstructionAccounts, index$1_createSetPeerInstruction as createSetPeerInstruction, index$1_createSetPeerInstructionAccounts as createSetPeerInstructionAccounts, index$1_createSetRateLimitInstruction as createSetRateLimitInstruction, index$1_createSetRateLimitInstructionAccounts as createSetRateLimitInstructionAccounts, index$1_createTransferAdminInstruction as createTransferAdminInstruction, index$1_createTransferAdminInstructionAccounts as createTransferAdminInstructionAccounts, createVersionInstruction$1 as createVersionInstruction, createVersionInstructionAccounts$1 as createVersionInstructionAccounts, index$1_enforcedOptionsBeet as enforcedOptionsBeet, index$1_enforcedOptionsDiscriminator as enforcedOptionsDiscriminator, index$1_errorFromCode as errorFromCode, index$1_errorFromName as errorFromName, index$1_initAdapterOftInstructionDiscriminator as initAdapterOftInstructionDiscriminator, index$1_initAdapterOftParamsBeet as initAdapterOftParamsBeet, index$1_initAdapterOftStruct as initAdapterOftStruct, index$1_initOftInstructionDiscriminator as initOftInstructionDiscriminator, index$1_initOftParamsBeet as initOftParamsBeet, index$1_initOftStruct as initOftStruct, index$1_isOftConfigExtAdapter as isOftConfigExtAdapter, index$1_isOftConfigExtNative as isOftConfigExtNative, index$1_lzAccountBeet as lzAccountBeet, index$1_lzReceiveInstructionDiscriminator as lzReceiveInstructionDiscriminator, index$1_lzReceiveParamsBeet as lzReceiveParamsBeet, index$1_lzReceiveStruct as lzReceiveStruct, index$1_lzReceiveTypesAccountsBeet as lzReceiveTypesAccountsBeet, index$1_lzReceiveTypesAccountsDiscriminator as lzReceiveTypesAccountsDiscriminator, index$1_lzReceiveTypesInstructionDiscriminator as lzReceiveTypesInstructionDiscriminator, index$1_lzReceiveTypesStruct as lzReceiveTypesStruct, index$1_messagingFeeBeet as messagingFeeBeet, index$1_messagingReceiptBeet as messagingReceiptBeet, index$1_mintToInstructionDiscriminator as mintToInstructionDiscriminator, index$1_mintToParamsBeet as mintToParamsBeet, index$1_mintToStruct as mintToStruct, index$1_oFTFeeDetailBeet as oFTFeeDetailBeet, index$1_oFTLimitsBeet as oFTLimitsBeet, index$1_oFTReceiptBeet as oFTReceiptBeet, index$1_oftConfigBeet as oftConfigBeet, index$1_oftConfigDiscriminator as oftConfigDiscriminator, index$1_oftConfigExtBeet as oftConfigExtBeet, index$1_peerBeet as peerBeet, index$1_peerDiscriminator as peerDiscriminator, index$1_quoteInstructionDiscriminator as quoteInstructionDiscriminator, index$1_quoteOftInstructionDiscriminator as quoteOftInstructionDiscriminator, index$1_quoteOftParamsBeet as quoteOftParamsBeet, index$1_quoteOftResultBeet as quoteOftResultBeet, index$1_quoteOftStruct as quoteOftStruct, index$1_quoteParamsBeet as quoteParamsBeet, index$1_quoteStruct as quoteStruct, index$1_rateLimiterBeet as rateLimiterBeet, index$1_sendInstructionDiscriminator as sendInstructionDiscriminator, index$1_sendParamsBeet as sendParamsBeet, index$1_sendStruct as sendStruct, index$1_setDelegateInstructionDiscriminator as setDelegateInstructionDiscriminator, index$1_setDelegateParamsBeet as setDelegateParamsBeet, index$1_setDelegateStruct as setDelegateStruct, index$1_setEnforcedOptionsInstructionDiscriminator as setEnforcedOptionsInstructionDiscriminator, index$1_setEnforcedOptionsParamsBeet as setEnforcedOptionsParamsBeet, index$1_setEnforcedOptionsStruct as setEnforcedOptionsStruct, index$1_setMintAuthorityInstructionDiscriminator as setMintAuthorityInstructionDiscriminator, index$1_setMintAuthorityParamsBeet as setMintAuthorityParamsBeet, index$1_setMintAuthorityStruct as setMintAuthorityStruct, index$1_setPeerInstructionDiscriminator as setPeerInstructionDiscriminator, index$1_setPeerParamsBeet as setPeerParamsBeet, index$1_setPeerStruct as setPeerStruct, index$1_setRateLimitInstructionDiscriminator as setRateLimitInstructionDiscriminator, index$1_setRateLimitParamsBeet as setRateLimitParamsBeet, index$1_setRateLimitStruct as setRateLimitStruct, index$1_transferAdminInstructionDiscriminator as transferAdminInstructionDiscriminator, index$1_transferAdminParamsBeet as transferAdminParamsBeet, index$1_transferAdminStruct as transferAdminStruct, index$1_versionBeet as versionBeet, versionInstructionDiscriminator$1 as versionInstructionDiscriminator, versionStruct$1 as versionStruct };
}

declare function oappIDPDA(program: PublicKey, seed?: string, id?: number): [PublicKey, number];
declare function deriveLzReceiveTypesAccountsPDA(program: PublicKey, oappId?: PublicKey): [PublicKey, number];
declare function deriveLzComposeTypesAccountsPDA(program: PublicKey, oappId?: PublicKey): [PublicKey, number];
declare abstract class BaseOApp {
    program: PublicKey;
    oappBaseDeriver: OAppBasePDADeriver;
    constructor(program: PublicKey);
    abstract getEndpoint(connection: Connection): Promise<Endpoint>;
    abstract getSendLibraryProgram(connection: Connection, payer: PublicKey, dstEid: number, endpoint?: Endpoint): Promise<SimpleMessageLib | Uln>;
    queryIDPDAInfo(connection: Connection, commitmentOrConfig?: web3$1.Commitment | web3$1.GetAccountInfoConfig): Promise<AccountInfo<Buffer> | null>;
    queryPDAInfo(connection: Connection, pda: PublicKey, commitmentOrConfig?: web3$1.Commitment | web3$1.GetAccountInfoConfig): Promise<AccountInfo<Buffer> | null>;
    idPDA(): [PublicKey, number];
    getRemote(connection: Connection, dstEid: number, commitmentOrConfig?: web3$1.Commitment | web3$1.GetAccountInfoConfig): Promise<Uint8Array | null>;
}

declare function extractSentPacketEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<PacketSentEvent[] | null>;
declare function extractVerifiedPacketEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<PacketVerifiedEvent[] | null>;
declare function extractReceivedPacketEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<PacketDeliveredEvent[] | null>;
declare function extractComposeSentEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<ComposeSentEvent[] | null>;
declare function extractComposeDeliveredEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<ComposeDeliveredEvent[] | null>;
declare function extractWorkerFeePaidEventByTxHash(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, commitment?: Finality | GetVersionedTransactionConfig): Promise<FeesPaidEvent[] | null>;
declare function extractEventFromTransactionSignature<E>(connection: Connection, program: PublicKey, signature: TransactionSignature | Awaited<ReturnType<typeof connection.getParsedTransaction>>, eventBeet: beet.FixableBeetArgsStruct<E> | beet.BeetArgsStruct<E>, commitment?: Finality | GetVersionedTransactionConfig): Promise<E[] | null>;
declare function generateAddressLookupTable(connection: Connection, payer: PublicKey, authority: PublicKey, addresses: PublicKey[]): Promise<{
    instructions: TransactionInstruction[];
    address: PublicKey;
}>;
declare function deactivateLookupTable(authority: PublicKey, lookupTable: PublicKey): TransactionInstruction;
declare function closeLookupTable(recipient: PublicKey, authority: PublicKey, lookupTable: PublicKey): TransactionInstruction;
declare function txWithAddressLookupTable(connection: Connection, payer: PublicKey, instructions: TransactionInstruction[], recentBlockHash?: Blockhash, tableAddr?: PublicKey): Promise<VersionedTransaction>;
declare function createNonceAccountTX(connection: Connection, auth: PublicKey, lamportsForRent?: number): Promise<{
    tx: Transaction;
    nonceAccount: Keypair;
}>;
declare function txWithNonce(connection: Connection, noncePubkey: PublicKey, instructions: TransactionInstruction[], nonceInfo?: NonceAccount): Promise<Transaction | null>;
declare function isAccountInitialized(connection: Connection, account: PublicKey, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<boolean>;
declare function buildMessageV0(connection: Connection, payerKey: PublicKey, instructions: TransactionInstruction[], commitmentOrConfig?: Commitment | GetAccountInfoConfig, blockhash?: Blockhash): Promise<MessageV0>;
declare function buildVersionedTransaction(connection: Connection, payerKey: PublicKey, instructions: TransactionInstruction[], commitmentOrConfig?: Commitment | GetAccountInfoConfig, blockhash?: Blockhash, lookupTableAddress?: PublicKey): Promise<VersionedTransaction>;
declare function instructionDiscriminator(method: string): Buffer;
declare function simulateTransaction(connection: Connection, instructions: TransactionInstruction[], programId: PublicKey, payer: PublicKey, commitment?: Commitment, blockhash?: Blockhash, lookupTableAddress?: PublicKey): Promise<Buffer>;

declare const idlTypes: string[];
declare const messageLibs: string[];
declare const FAUCET_URL: {
    [env in Environment]: string;
};

declare const AddressType: beet.ElementCollectionBeet & beet.BeetBase & beet.BeetReadWrite<number[], number[]>;
declare const MSG_TYPE_OFFSET = 0;
declare enum MessageType {
    VANILLA = 1,
    COMPOSED_TYPE = 2
}
interface LzReceiveParams {
    srcEid: number;
    sender: number[];
    nonce: bignum;
    guid: number[];
    message: Uint8Array;
    callerParams: Uint8Array;
}
declare const LzReceiveParamsBeet: FixableBeetArgsStruct<LzReceiveParams>;
/**
 *
pub from: Pubkey,
pub to: Pubkey,
pub guid: [u8; 32],
pub index: u16,
pub message: Vec<u8>,
pub extra_data: Vec<u8>,
**/
interface LzComposeParams {
    from: PublicKey;
    to: PublicKey;
    guid: number[];
    index: number;
    message: Uint8Array;
    extraData: Uint8Array;
}
/**
 * @category userTypes
 * @category generated
 */
declare const LzComposeParamsBeet: FixableBeetArgsStruct<LzComposeParams>;
interface LzReceiveAccount {
    pubkey: PublicKey;
    isSigner: boolean;
    isWritable: boolean;
}
/**
 * @category userTypes
 * @category generated
 */
declare const LzReceiveAccountBeet: BeetArgsStruct<LzReceiveAccount>;
declare enum ExecutorOptionType {
    PlaceHolder = 0,
    LzReceive = 1,
    NativeDrop = 2,
    LzCompose = 3,
    OrderExecution = 4
}
declare const MaxExecutorOptionTypeLength = 10;

/**
 * @param payer. If the msgType is COMPOSED_TYPE, then the payer is required to pay for initializing the account.
 */
declare function lzReceive(connection: Connection, payer: PublicKey, packet: Packet$2, callerParams?: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
declare function lzCompose(connection: Connection, payer: PublicKey, event: ComposeSentEvent, extraData?: Uint8Array, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<TransactionInstruction>;
declare function getLzReceiveAccounts(connection: Connection, payer: PublicKey, receiver: PublicKey, receiverProgram: PublicKey, params: LzReceiveParams, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<AccountMeta[]>;
declare function getLzComposeAccountMeta(connection: Connection, payer: PublicKey, to: PublicKey, composerProgram: PublicKey, params: LzComposeParams, commitmentOrConfig?: Commitment | GetAccountInfoConfig): Promise<AccountMeta[]>;

type SupportedPrograms = 'endpoint' | 'simple_messagelib' | 'uln' | 'blocked_messagelib' | 'executor' | 'pricefeed' | 'dvn';
interface Deployment {
    name: SupportedPrograms;
    network: Network;
    address: string;
    compatibleVersions: string[];
    deployer: string;
}
declare function getProgramKeypair(network: Network | 'default', program: SupportedPrograms): PublicKey;
declare function getEndpointProgramId(network: Network | 'default'): PublicKey;
declare function getSimpleMessageLibProgramId(network: Network | 'default'): PublicKey;
declare function getULNProgramId(network: Network | 'default'): PublicKey;
declare function getDVNProgramId(network: Network | 'default'): PublicKey;
declare function getBlockedMessageLibProgramId(network: Network | 'default'): PublicKey;
declare function getExecutorProgramId(network: Network | 'default'): PublicKey;
declare function getPricefeedProgramId(network: Network | 'default'): PublicKey;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Version
 * @category generated
 */
declare const versionStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number[];
}>;
declare const versionInstructionDiscriminator: number[];
/**
 * Creates a _Version_ instruction.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstruction(programId?: web3.PublicKey): web3.TransactionInstruction;
/**
 * Creates a _Version_ instructionAccounts.
 *
 * @category Instructions
 * @category Version
 * @category generated
 */
declare function createVersionInstructionAccounts(programId?: web3.PublicKey): web3.AccountMeta[];

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS = "2XrYqmhBMPJgDsb4SVbjV1PnJBprurd5bzRCkHwiFCJB";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID: PublicKey;

declare const index_PROGRAM_ADDRESS: typeof PROGRAM_ADDRESS;
declare const index_PROGRAM_ID: typeof PROGRAM_ID;
declare const index_createVersionInstruction: typeof createVersionInstruction;
declare const index_createVersionInstructionAccounts: typeof createVersionInstructionAccounts;
declare const index_versionInstructionDiscriminator: typeof versionInstructionDiscriminator;
declare const index_versionStruct: typeof versionStruct;
declare namespace index {
  export { index_PROGRAM_ADDRESS as PROGRAM_ADDRESS, index_PROGRAM_ID as PROGRAM_ID, index_createVersionInstruction as createVersionInstruction, index_createVersionInstructionAccounts as createVersionInstructionAccounts, index_versionInstructionDiscriminator as versionInstructionDiscriminator, index_versionStruct as versionStruct };
}

declare const IdlTypes: {
    endpoint: ({
        name: string;
        type: {
            kind: string;
            fields: {
                name: string;
                type: {
                    option: string;
                };
            }[];
            variants?: undefined;
        };
    } | {
        name: string;
        type: {
            kind: string;
            variants: {
                name: string;
            }[];
            fields?: undefined;
        };
    } | {
        name: string;
        type: {
            kind: string;
            fields: ({
                name: string;
                type: {
                    array: (string | number)[];
                    defined?: undefined;
                };
            } | {
                name: string;
                type: string;
            } | {
                name: string;
                type: {
                    defined: string;
                    array?: undefined;
                };
            })[];
            variants?: undefined;
        };
    } | {
        name: string;
        type: {
            kind: string;
            fields: ({
                name: string;
                type: string;
                index: boolean;
            } | {
                name: string;
                type: {
                    array: (string | number)[];
                };
                index: boolean;
            })[];
            variants?: undefined;
        };
    } | {
        name: string;
        type: {
            kind: string;
            fields: ({
                name: string;
                type: string;
                index: boolean;
            } | {
                name: string;
                type: {
                    option: {
                        defined: string;
                    };
                };
                index: boolean;
            })[];
            variants?: undefined;
        };
    } | {
        name: string;
        type: {
            kind: string;
            fields: {
                name: string;
                type: {
                    option: string;
                };
                index: boolean;
            }[];
            variants?: undefined;
        };
    })[];
};
declare enum SetConfigType {
    EXECUTOR = 1,
    SEND_ULN = 2,
    RECEIVE_ULN = 3
}
interface MessageLibInterface {
    program: PublicKey;
    getQuoteIXAccountMetaForCPI(connection: Connection, payer: PublicKey, path: PacketPath, commitment?: Commitment): Promise<AccountMeta[]>;
    getSendIXAccountMetaForCPI(connection: Connection, payer: PublicKey, path: PacketPath): Promise<AccountMeta[]>;
    getInitConfigIXAccountMetaForCPI(payer: PublicKey, oappID: PublicKey, eid: number): Promise<AccountMeta[]>;
    getSetConfigIXAccountMetaForCPI(endpointProgram: PublicKey, oappID: PublicKey, eid: number): Promise<AccountMeta[]>;
}

export { AddressType, BaseOApp, index as BlockedMessageLibProgram, COMPOSED_MESSAGE_HASH_SEED, CONFIRMATIONS_SEED, COUNT_SEED, DVNDeriver, dvn as DVNProgram, DVN_CONFIG_SEED, type Deployment, index$3 as DvnProgram, ENDPOINT_SEED, ENFORCED_OPTIONS_SEED, EVENT_SEED, EXECUTOR_CONFIG_SEED, EndpointPDADeriver, endpoint as EndpointProgram, EventPDADeriver, ExecutorOptionType, ExecutorPDADeriver, executor as ExecutorProgram, FAUCET_URL, IdlTypes, LZ_COMPOSE_TYPES_SEED, LZ_RECEIVE_TYPES_SEED, type LzComposeParams, LzComposeParamsBeet, type LzReceiveAccount, LzReceiveAccountBeet, type LzReceiveParams, LzReceiveParamsBeet, MESSAGE_LIB_SEED, MINT_SEED, MSG_TYPE_OFFSET, MaxExecutorOptionTypeLength, type MessageLibInterface, MessageLibPDADeriver, MessageType, NONCE_SEED, OAPP_SEED, OAppBasePDADeriver, OFT_SEED$1 as OFT_SEED, OPTIONS_SEED, index$1 as Oft, OftPDADeriver, OftTools, OmniCounterPDADeriver, PAYLOAD_HASH_SEED, PEER_SEED, PENDING_NONCE_SEED, PRICE_FEED_SEED, PriceFeedPDADeriver, pricefeed as PriceFeedProgram, RECEIVE_CONFIG_SEED, RECEIVE_LIBRARY_CONFIG_SEED, REMOTE_SEED, SEND_CONFIG_SEED, SEND_LIBRARY_CONFIG_SEED, SetConfigType, simpleMessageLib as SimpleMessageLibProgram, type SupportedPrograms, ULN_CONFIG_SEED, ULN_SEED, UlnPDADeriver, uln as UlnProgram, WORKER_SEED, buildMessageV0, buildVersionedTransaction, closeLookupTable, createNonceAccountTX, deactivateLookupTable, deriveLzComposeTypesAccountsPDA, deriveLzReceiveTypesAccountsPDA, extractComposeDeliveredEventByTxHash, extractComposeSentEventByTxHash, extractEventFromTransactionSignature, extractReceivedPacketEventByTxHash, extractSentPacketEventByTxHash, extractVerifiedPacketEventByTxHash, extractWorkerFeePaidEventByTxHash, generateAddressLookupTable, getBlockedMessageLibProgramId, getDVNProgramId, getEndpointProgramId, getExecutorProgramId, getLzComposeAccountMeta, getLzReceiveAccounts, getPricefeedProgramId, getProgramKeypair, getSimpleMessageLibProgramId, getULNProgramId, idlTypes, instructionDiscriminator, isAccountInitialized, lzCompose, lzReceive, messageLibs, oappIDPDA, simulateTransaction, txWithAddressLookupTable, txWithNonce };
